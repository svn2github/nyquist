<html><head><title>Nyquist Functions</title></head>
<body bgcolor="ffffff">
<a href = "part7.html">Previous Section</a> | <a href = "part9.html">Next Section</a> | <a href = "title.html#toc">Table of Contents</a> | <a href = "indx.html">Index</a> | <a href = "title.html">Title Page</a>
<hr>
<a name = "79"><h2>Nyquist Functions</h2></a>

This chapter provides a language reference for Nyquist.  Operations
are categorized by functionality and abstraction level.
Nyquist is implemented in two important levels: the "high level" supports
behavioral abstraction, which means that operations like <code>stretch</code> and
<code>at</code> can be applied.  These functions are the ones that typical users
are expected to use, and most of these functions are written in XLISP.
<p>
The "low-level" primitives directly operate on sounds, but know nothing of
environmental variables (such as <code>*warp*</code>, etc.).  The
names of most of these low-level functions start with "<code>snd-</code>".  In
general, programmers should avoid any function with the "<code>snd-</code>"
prefix.  Instead, use the "high-level" functions, which know about the
environment and react appropriately.  The names of high-level functions
do not have prefixes like the low-level functions.  
<p>
There are certain low-level operations that apply directly to sounds (as
opposed to behaviors) and are relatively "safe" for ordinary use.  These
are marked as such.
<p>
Nyquist uses both linear frequency and equal-temperament pitch numbers to
specify repetition rates.  Frequency is always specified in either cycles
per second (hz), or pitch numbers, also referred to as "steps," as in
steps of the chromatic scale.  Steps are floating point numbers such that 60
= Middle C, 61 = C#, 61.23 is C# plus 23 cents, etc.  The mapping from pitch
number to frequency is the standard exponential conversion, and fractional
pitch numbers are allowed:

<blockquote>frequency = 440 * 2^((pitch - 69)/12)</blockquote>
There are many
predefined pitch names.  By default these are tuned in equal temperament,
with A4 = 440Hz, but these may be changed.  (See Section <a href = "part2.html#16">"Predefined Constants"</a>).
<p>
<a name = "80"><h3>Sounds</h3></a><a name="index245">
A sound is a primitive data type in Nyquist.  Sounds can be created, passed
as parameters, garbage collected, printed, and set to variables just like
strings, atoms, numbers, and other data types.  
<p>
<a name = "81"><h4>What is a Sound?</h4></a>
Sounds have 5 components:
<ul>
<li>
<code>srate<a name="index246"></code> - the sample rate of the sound.
<li><code>samples<a name="index247"></code> - the samples.
<li><code>signal-start<a name="index248"></code> - the time of the first sample.
<li><code>signal-stop<a name="index249"></code> - the time of one past the last sample.
<li><code>logical-stop<a name="index250"></code> - the time at which the sound logically ends, e.g. a 
sound may end at the beginning of a decay.  This value defaults 
to <code>signal-stop</code>,
but may be set to any value.  
</ul>
It may seem that there should be <code>logical-start</code> to indicate the
logical or perceptual beginning of a sound as well as a <code>logical-stop</code>
to indicate the logical ending of a sound.  In practice, only
<code>logical-stop</code> is needed; this attribute tells when the next sound
should begin to form a sequence of sounds.  In this respect, Nyquist sounds
are asymmetric: it is possible to compute sequences forward in time by
aligning the logical start of each sound with the <code>logical-stop</code> of the
previous one, but one cannot compute "backwards", aligning the logical end
of each sound with the logical start of its successor.  The root of this
asymmetry is the fact that when we invoke a behavior, we say when to start,
and the result of the behavior tells us its logical duration.  There is no
way to invoke a behavior with a direct specification of when to
stop <a href = "foot.html#foot1">(Footnote 1)</a> .  
<p>
<b><i>Note:</i></b> there is no way to enforce the
intended "perceptual" interpretation of 
<code>logical-stop</code>.  As far as Nyquist is concerned, these are just numbers to
guide the alignment of sounds within various control constructs.
<p>
<a name = "82"><h4>Multichannel Sounds</h4></a>
<a name="index251">
Multichannel sounds are represented by Lisp arrays of sounds.  To create an
array of sounds the XLISP <code>vector</code> function is useful.  Most low-level 
Nyquist functions (the ones starting with <code>snd-</code>) do not operate on
multichannel sounds.  Most high-level functions do operate on multichannel
sounds.
<p>
<a name = "83"><h4>Accessing and Creating Sound</h4></a>

Several functions display information concerning a sound and can be used to
query the components of a sound. There are functions that access samples in
a sound and functions that construct sounds from samples.
<p>
<dl>
<dt>
<code>sref(<a name="index252"><a name="Sound, accessing point253"><i>sound</i>, <i>time</i>)</code> [SAL]<br>

<code>(sref <i>sound</i> <i>time</i>)</code> [LISP]<dd>Accesses <i>sound</i> at 
the point <i>time</i>, which is a local time. If <i>time</i> does not 
correspond to a sample time, then the nearest samples are linearly 
interpolated to form the result.  To access a particular sample, either 
convert the sound to an array (see <code>snd-samples</code> below), or use 
<code>snd-srate</code> and <code>snd-t0</code> (see below) to find the sample rate 
and starting time,  and compute a time (<i>t</i>) from the sample number (<i>n</i>):

<blockquote>t = (n / srate) + t0</blockquote>
Thus, the lisp code to access the n^(th) sample of a sound would look like:
<code>
(sref sound (global-to-local (+ (/ n (snd-srate sound)) (snd-t0 sound))))
</code>
Here is why <code>sref</code> interprets its time argument as a local time:
<pre>
&gt; (sref (ramp 1) 0.5) <i>; evaluate a ramp at time 0.5</i>
0.5
&gt; (at 2.0 (sref (ramp 1) 0.5)) <i>; ramp is shifted to start at 2.0</i>
		<i>; the time, 0.5, is shifted to 2.5</i>
0.5
</pre>

If you were to use <code>snd-sref</code>, which treats time as global, instead of <code>sref</code>, which treats time as local, then the first example above would return the same answer (0.5), but the second example would return 0.  Why? Because the <code>(ramp 1)</code> behavior would be shifted to start at time 2.0, but the resulting sound would be evaluated at global time 0.5.  By definition, sounds have a value of zero before their start time.<br><br>
<dt><code>sref-inverse(<a name="index254"><i>sound</i>, <i>value</i>)</code> [SAL]<br>

<code>(sref-inverse <i>sound</i> <i>value</i>)</code> [LISP]<dd>Search <i>sound</i> for the first point at which it achieves <i>value</i> and return the corresponding (linearly interpolated) time.  If no inverse exists, an error is raised.  This function is used by Nyquist in the implementation of time warping.<br><br>
<dt>
<code>snd-from-array(<a name="Sound, creating from array255"><a name="index256"><i>t0</i>, <i>sr</i>,
<i>array</i>)</code> [SAL]<br>

<code>(snd-from-array <i>t0</i> <i>sr</i> <i>array</i>)</code> [LISP]<dd>Converts a lisp array of <code>FLONUM</code>s into a sound with starting
time <i>t0</i> and sample rate <i>sr</i>.  Safe for ordinary use.  Be aware that
arrays of floating-point samples use 14 bytes per sample, and an additional
4 bytes per sample are allocated by this function to create a sound type.<br><br>
<dt><code>snd-fromarraystream(<a name="index257"><i>t0</i>, <i>sr</i>, <i>object</i>)</code> [SAL]<br>

<code>(snd-fromarraystream <i>t0</i> <i>sr</i> <i>object</i>)</code> [LISP]<dd>Creates a sound for which samples come from
<i>object</i>. The starting time is <i>t0</i> (a <code>FLONUM</code>), and the sample rate is
<i>sr</i>. The <i>object</i> is an XLISP object (see Section <a href = "part19.html#220">"Objects"</a> for
information on objects.) A sound is returned.  When the sound needs samples,
they are generated by sending the message <code>:next</code> to <i>object</i>. If
<i>object</i> returns <code>NIL</code>, the sound terminates. Otherwise, <i>object</i>
must return an array of <code>FLONUM</code>s.  The values in these arrays are
concatenated to form the samples of the resulting sound.
There is no provision for <i>object</i> to specify the
logical stop time of the sound, so the logical stop time is the termination
time. <br><br>
<dt><code>snd-fromobject(<a name="index258"><a name="index259"><i>t0</i>, <i>sr</i>, <i>object</i>)</code> [SAL]<br>

<code>(snd-fromobject <i>t0</i> <i>sr</i> <i>object</i>)</code> [LISP]<dd>Creates a sound for which samples come from
<i>object</i>. The starting time is <i>t0</i> (a <code>FLONUM</code>), and the sample rate is
<i>sr</i>. The <i>object</i> is an XLISP object (see Section <a href = "part19.html#220">"Objects"</a> for
information on objects. A sound is returned.  When the sound needs samples,
they are generated by sending the message <code>:next</code> to <i>object</i>. If
<i>object</i> returns <code>NIL</code>, the sound terminates. Otherwise, <i>object</i>
must return a <code>FLONUM</code>.  There is no provision for <i>object</i> to specify the
logical stop time of the sound, so the logical stop time is the termination
time.<br><br>
<dt><code>snd-extent(<a name="index260"><i>sound</i>, <i>maxsamples</i>)</code> [SAL]<br>

<code>(snd-extent <i>sound</i> <i>maxsamples</i>)</code> [LISP]<dd>Returns a list of two numbers: the starting time of <i>sound</i> and the terminate time of <i>sound</i>.  Finding the terminate time requires that samples be computed.  Like most Nyquist functions, this is non-destructive, so memory will be allocated to preserve the sound samples.  If the sound is very long or infinite, this may exhaust all memory, so the <i>maxsamples</i> parameter specifies a limit on how many samples to compute.  If this limit is reached, the terminate time will be (incorrectly) based on the sound having <i>maxsamples</i> samples.  This function is safe for ordinary use.<br><br>
<dt><code>snd-fetch(<a name="index261"><a name="index262"><a name="index263"><a name="index264"><i>sound</i>)</code> [SAL]<br>

<code>(snd-fetch <i>sound</i>)</code> [LISP]<dd>Reads samples
sequentially from <i>sound</i>. This returns a <code>FLONUM</code> after each call, or
<code>NIL</code> when <i>sound</i> terminates. <b><i>Note:</i></b> <code>snd-fetch</code> modifies
<i>sound</i>; it is strongly recommended to copy <i>sound</i> using
<code>snd-copy</code> and access only the copy with <code>snd-fetch</code>.<br><br>
<dt><code>snd-fetch-array(<a name="index265"><i>sound</i>, <i>len</i>,
<i>step</i>)</code> [SAL]<br>

<code>(snd-fetch-array <i>sound</i> <i>len</i> <i>step</i>)</code>
[LISP]<dd>Reads 
sequential arrays of samples from <i>sound</i>, returning either an array
of <code>FLONUM</code>s or <code>NIL</code> when the sound terminates. The <i>len</i>
parameter, a <code>FIXNUM</code>, indicates how many samples should be
returned in the result array.  After the array is returned, <i>sound</i>
is modified by skipping over <i>step</i> (a <code>FIXNUM</code>) samples. If
<i>step</i> equals <i>len</i>, then every sample is returned once.  If
<i>step</i> is less than <i>len</i>, each returned array will overlap the
previous one, so some samples will be returned more than once. If
<i>step</i> is greater than <i>len</i>, then some samples will be skipped
and not returned in any array. The <i>step</i> and <i>len</i> may change at
each call, but in the current implementation, an internal buffer is
allocated for <i>sound</i> on the first call, so subsequent calls may not
specify a greater <i>len</i> than the first. When an array is returned,
it will have <i>len</i> samples. If necessary, <code>snd-fetch-array</code>
will read zeros beyond the end of the sound to fill the array. When
this happens, <code>*rslt*</code> is set to a FIXNUM number of samples in
the array that were read from the sound before the physical stop time 
of the sound. If all samples in the array are "valid" samples from
the sound (coming from the sound before the sound
terminates), <code>*rslt*</code> is set to <code>NIL</code>. The <code>*rslt*</code>
variable is global and used to return extra results from other
functions, so programs should not assume <code>*rslt*</code> is valid after
subsequent function calls. <b><i>Note:</i></b> <code>snd-fetch-array</code> modifies
<i>sound</i>; it is strongly recommended to copy <i>sound</i> using
<code>snd-copy</code> and access only the copy with <code>snd-fetch-array</code>.<br><br>
<dt><code>snd-flatten(<a name="index266"><i>sound</i>, <i>maxlen</i>)</code> [SAL]<br>

<code>(snd-flatten <i>sound</i> <i>maxlen</i>)</code> [LISP]<dd>This function is identical 
to <code>snd-length</code>. You would use this function to force samples to be computed in memory. Normally, this is not a good thing to do, but here is one appropriate use: In the case of sounds intended for wavetables, the unevaluated 
sound may be larger than the evaluated (and typically short) one. 
Calling <code>snd-flatten</code> will compute the samples and allow the unit generators to be freed in the next garbage collection. <b><i>Note:</i></b> If a sound is computed from many instances of table-lookup oscillators, calling <code>snd-flatten</code> will free the oscillators and their tables. Calling <code>(stats)</code> will print how many total bytes have been allocated to tables.<br><br>
<dt> <code>snd-length(<a name="index267"><i>sound</i>, <i>maxlen</i>)</code> [SAL]<br>

<code>(snd-length <i>sound</i> <i>maxlen</i>)</code> [LISP]<dd>Counts the
number of samples in <i>sound</i> up to the physical stop time.  If the sound
has more than <i>maxlen</i> samples, <i>maxlen</i> is returned.  Calling this
function will cause all samples of the sound to be computed and saved in
memory (about 4 bytes per sample).  Otherwise, this function is safe for ordinary use.<br><br>
<dt> <code>snd-maxsamp(<a name="index268"><i>sound</i>)</code> [SAL]<br>

<code>(snd-maxsamp <i>sound</i>)</code> [LISP]<dd>Computes the maximum of
the absolute value of the samples in <i>sound</i>.  Calling this function will
cause samples to be computed and saved in memory.  (This function should
have a <i>maxlen</i> parameter to allow self-defense against sounds that would
exhaust available memory.)  Otherwise, this function is safe for ordinary use.
This function will probably be removed in a future version.  See <code>peak</code>, a replacement (<a href = "#99">"Signal Operations"</a>).<br><br>
<dt> <code>snd-play(<a name="index269"><i>expression</i>)</code> [SAL]<br>

<code>(snd-play <i>expression</i>)</code> [LISP]<dd>Evaluates <i>expression</i>
to obtain a sound or array of sounds, computes all of the samples (without
retaining them in memory), and returns. Originally, this was a placeholder
for a facility to play samples directly to an audio output device, but
playback is now accomplished by <code>s-save</code>.
Meanwhile, since this
function does not save samples in memory or write them to a disk, it is
useful in determining how much time is spent calculating samples.  See
<code>s-save</code> (Section <a href = "#96">"Sound File Input and Output"</a>) for saving samples to a file, and
 <code>play</code> (Section <a href = "#96">"Sound File Input and Output"</a>) to play a sound.  This function is
safe for ordinary use.<br><br>
<dt><code>snd-print-tree(<a name="index270"><i>sound</i>)</code> [SAL]<br>

<code>(snd-print-tree <i>sound</i>)</code> [LISP]<dd>Prints an ascii
representation of the internal data structures representing a sound.  This
is useful for debugging Nyquist.  This function is
safe for ordinary use.<br><br>
<dt> <code>snd-samples(<a name="index271"><a name="index272"><a name="index273"><a name="index274"><i>sound</i>, <i>limit</i>)</code> [SAL]<br>

<code>(snd-samples <i>sound</i> <i>limit</i>)</code> [LISP]<dd>Converts the
samples into a lisp array.  The data is taken directly from the samples,
ignoring shifts.  For example, if the sound starts at 3.0 seconds, the first
sample will refer to time 3.0, not time 0.0.  A maximum of <i>limit</i> samples
is returned.  This function is safe for ordinary use, but like
<code>snd-from-array</code>, it requires a total of slightly over 18 bytes per
sample.<br><br>
<dt> <code>snd-srate(<a name="index275"><i>sound</i>)</code> [SAL]<br>

<code>(snd-srate <i>sound</i>)</code> [LISP]<dd>Returns the sample rate of
the sound. Safe for ordinary use.<br><br>
<dt><code>snd-time(<a name="index276"><i>sound</i>)</code> [SAL]<br>

<code>(snd-time <i>sound</i>)</code> [LISP]<dd>Returns the start time of the
sound.  This will probably go away in a future version, so use <code>snd-t0</code>
instead.<br><br>
<dt><code>snd-t0(<a name="index277"><i>sound</i>)</code> [SAL]<br>

<code>(snd-t0 <i>sound</i>)</code> [LISP]<dd>Returns the time of the
first sample of the sound.  Note that Nyquist operators such as add always
copy the sound and are allowed to shift the copy up to one half sample
period in either direction to align the samples of two operands.  Safe for
ordinary use.<br><br>
<dt><code>snd-print(<a name="index278"><i>expression</i>, <i>maxlen</i>)</code> [SAL]<br>

<code>(snd-print <i>expression</i> <i>maxlen</i>)</code> [LISP]<dd>Evaluates
<i>expression</i> to yield a sound or an array of sounds, then prints up to
<i>maxlen</i> samples to the screen (stdout).  This is similar to
<code>snd-save</code>, but samples appear in text on the screen instead of in
binary in a file.  This function is intended for debugging<a name="index279">.
Safe for ordinary use.<br><br>
<dt> <code>snd-set-logical-stop(<a name="index280"><i>sound</i>,
<i>time</i>)</code> [SAL]<br>

<code>(snd-set-logical-stop <i>sound</i> <i>time</i>)</code> [LISP]<dd>Returns a sound which is 
<i>sound</i>, except that the logical stop of the sound occurs at <i>time</i>.
 <b><i>Note:</i></b> do not call this function.  When defining a behavior, use
<code>set-logical-stop</code> or <code>set-logical-stop-abs</code> instead.<br><br>
<dt><code>snd-sref(<a name="index281"><i>sound</i>, <i>time</i>)</code> [SAL]<br>

<code>(snd-sref <i>sound</i> <i>time</i>)</code> [LISP]<dd>Evaluates <i>sound</i> 
at the global time given by <i>time</i>.  Safe for ordinary use, but normally, you should
call <code>sref</code> instead.<br><br>
<dt> <code>snd-stop-time(<a name="index282"><i>sound</i>)</code> [SAL]<br>

<code>(snd-stop-time <i>sound</i>)</code> [LISP]<dd>Returns the stop time of <i>sound</i>.
Sounds can be "clipped" or truncated at a particular time.  This function
returns that time or MAX-STOP-TIME if he programmer has not specified a stop
time for the sound.  Safe for ordinary use.<br><br>
<dt><code>soundp(<a name="index283"><i>sound</i>)</code> [SAL]<br>

<code>(soundp <i>sound</i>)</code> [LISP]<dd>Returns true iff <i>sound</i> is a
SOUND.  Safe for ordinary use.<br><br>
<dt><code>stats(<a name="index284"><a name="index285"><a name="index286">)</code> [SAL]<br>

<code>(stats)</code> [LISP]<dd>Prints the memory usage status.  
See also the 
XLISP <code>mem</code> function.  Safe for ordinary use. This is the only way to find out how much memory is being used by table-lookup oscillator instances.<br><br>
<dt></dl><a name = "84"><h4>Miscellaneous Functions</h4></a>
These are all safe and recommended for ordinary use.
<p>
<dl>
<dt>
<code>db-to-linear(<a name="index287"><i>x</i>)</code> [SAL]<br>

<code>(db-to-linear <i>x</i>)</code> [LISP]<dd>Returns the
conversion of <i>x</i> from decibels to linear.  0dB is converted to 1.
20dB represents a linear factor of 10. If <i>x</i> is a sound, each
sample is converted and a sound is returned.  If <i>x</i> is a
multichannel sound, each channel is converted and a multichannel sound
(array) is returned.  <b><i>Note:</i></b> With sounds, conversion is only
performed on actual samples, not on the implicit zeros before the
beginning and after the termination of the sound.  Sample rates, start
times, etc. are taken from <i>x</i>. <br><br>
<dt><code>db-to-vel(<a name="index288"><i>x</i> [, <i>float</i>])</code> [SAL]<br>

<code>(db-to-vel <i>x</i> [<i>float</i>])</code> [LISP]<dd>Returns the 
conversion of <i>x</i> from decibels to MIDI velocity using a rule that
maps -60 dB to 1 and 0 dB to 127. The MIDI velocity varies linearly 
with the square root of amplitude. The default value of <i>float</i> is
<code>nil</code> and the result is a <code>FIXNUM</code> clipped to fall in the
legal range of 1-127, but if a non-<code>nil</code> value
is provided, the result is a <code>FLONUM</code> that is not 
rounded or clipped. The input parameter must be a <code>FIXNUM</code> or
<code>FLONUM</code>. Sounds are not allowed.<br><br>
<dt><code>follow(<a name="index289"><a name="index290"><a name="index291"><a name="index292"><i>sound</i>, <i>floor</i>, <i>risetime</i>, <i>falltime</i>, <i>lookahead</i>)</code> [SAL]<br>

<code>(follow <i>sound</i> <i>floor</i> <i>risetime</i> <i>falltime</i> <i>lookahead</i>)</code> [LISP]<dd>An envelope follower intended as a commponent for compressor and limiter functions. The basic goal of this function is to generate a smooth signal 
that rides on the peaks of the input signal. The usual objective is to 
produce an amplitude envelope given a low-sample rate (control rate) 
signal representing local RMS measurements. The first argument is the 
input signal. The <i>floor</i> is the minimum output value. The <i>risetime</i> 
is the time (in seconds) it takes for the output to rise (exponentially) 
from <i>floor</i> to unity (1.0) and the <i>falltime</i> is the time it takes 
for the output to fall (exponentially) from unity to <i>floor</i>. The 
algorithm looks ahead for peaks and will begin to increase the output 
signal according to <i>risetime</i> in anticipation of a peak. The amount 
of anticipation (in seconds) is given by <i>lookahead</i>.  The algorithm 
is as follows: the output value is allowed to increase according to 
<i>risetime</i> or decrease according to <i>falltime</i>. If the next input 
sample is in this range, that sample is simply output as the next output 
sample.  If the next input sample is too large, the algorithm goes back in 
time as far as necessary to compute an envelope that rises according to 
<i>risetime</i> to meet the new value. The algorithm will only work backward 
as far as <i>lookahead</i>.  If that is not far enough, then there is a final 
forward pass computing a rising signal from the earliest output sample. In 
this case, the output signal will be at least momentarily less than the 
input signal and will continue to rise exponentially until it intersects 
the input signal. If the input signal falls faster than indicated by 
<i>falltime</i>, the output fall rate will be limited by <i>falltime</i>, 
and the fall in output will stop when the output reaches <i>floor</i>. 
This algorithm can make two passes througth the buffer on sharply rising 
inputs, so it is not particularly fast. With short buffers and low sample 
rates this should not matter. See <code>snd-avg</code> for a function that 
can help to generate a low-sample-rate input for <code>follow</code>. 
See <code>snd-chase</code> in Section <a href = "#100">"Filters"</a> for a related filter.<br><br>
<dt>
<code>gate(<a name="index293"><a name="index294"><i>sound</i>, 
<i>lookahead</i>, <i>risetime</i>, <i>falltime</i>, <i>floor</i>, 
<i>threshold</i>)</code> [SAL]<br>

<code>(gate <i>sound</i> <i>lookahead</i> <i>risetime</i> <i>falltime</i> <i>floor</i> <i>threshold</i>)</code> [LISP]<dd>Generate an exponential rise and decay intended 
for noise gate implementation. The decay starts when the signal drops 
below <i>threshold</i> and stays there for longer than <i>lookahead</i> (a 
<code>FLONUM</code> in seconds). (The signal begins to drop when the signal 
crosses <i>threshold</i>, not after <i>lookahead</i>.) Decay continues until 
the value reaches <i>floor</i> (a <code>FLONUM</code>), at which point the decay 
stops and the output value is held constant. Either during the decay or 
after the floor is reached, if the signal goes above <i>threshold</i>, then 
the ouptut value will rise to unity (1.0) at the point the signal crosses 
the threshold. Because of internal lookahead, the signal actually begins 
to rise before the signal crosses <i>threshold</i>. The rise is a 
constant-rate exponential and set so that a rise from <i>floor</i> to unity 
occurs in <i>risetime</i>. Similary, the fall is a constant-rate exponential 
such that a fall from unity to <i>floor</i> takes <i>falltime</i>.<br><br>
<dt><code>hz-to-step(<a name="index295"><i>freq</i>)</code> [SAL]<br>

<code>(hz-to-step <i>freq</i>)</code> [LISP]<dd>Returns a step number for <i>freq</i> (in hz), which can be either a number of a <code>SOUND</code>. The result has the same type as the argument. See also <code>step-to-hz</code> (below).<br><br>
<dt><code>linear-to-db(<a name="index296"><i>x</i>)</code> [SAL]<br>

<code>(linear-to-db <i>x</i>)</code> [LISP]<dd>Returns the conversion of <i>x</i> from linear to decibels.  1 is converted to 0.  0 is converted to -INF (a special IEEE floating point value.)  A factor of 10 represents a 20dB change.  If <i>x</i> is a sound,  each sample is converted and a sound is returned.  If <i>x</i> is a multichannel sound, each channel is converted and a multichannel sound (array) is returned.  <b><i>Note:</i></b> With sounds, conversion is only performed on actual samples, not on the implicit zeros before the beginning and after the termination of the sound.  Start times, sample rates, etc. are taken from <i>x</i>.<br><br>
<dt><code>linear-to-vel(<a name="index297"><i>x</i> [, <i>float</i>])</code> [SAL]<br>

<code>(linear-to-vel <i>x</i> [<i>float</i>])</code> [LISP]<dd>Returns the 
conversion of <i>x</i> from linear amplitude to MIDI velocity using a rule that
maps -60 dB to 1 and 0 dB to 127. The MIDI velocity varies linearly 
with the square root of amplitude. The default value of <i>float</i> is
<code>nil</code> and the result is a <code>FIXNUM</code> clipped to fall in the
legal range of 1-127, but if a non-<code>nil</code> value
is provided, the result is a <code>FLONUM</code> that is not 
rounded or clipped. The input parameter must be a <code>FIXNUM</code> or
<code>FLONUM</code>. Sounds are not allowed.<br><br>
<dt><code>log(<a name="index298"><a name="index299"><i>x</i>)</code> [SAL]<br>

<code>(log <i>x</i>)</code> [LISP]<dd>Calculates the natural log of <i>x</i> (a <code>FLONUM</code>). (See <code>s-log</code> for a version that operates on signals.)<br><br>
<dt><code>set-control-srate(<a name="index300"><a name="index301"><i>rate</i>)</code> [SAL]<br>

<code>(set-control-srate <i>rate</i>)</code> [LISP]<dd>Sets the default sampling rate for control signals to <i>rate</i> by setting <code>*default-control-srate*</code> and reinitializing the environment.  Do not call this within any synthesis function (see the <code>control-srate-abs</code> transformation, Section <a href = "#94">"Transformations"</a>).<br><br>
<dt><code>set-sound-srate(<a name="index302"><a name="index303"><i>rate</i>)</code> [SAL]<br>

<code>(set-sound-srate <i>rate</i>)</code> [LISP]<dd>Sets the default sampling rate for audio signals to <i>rate</i> by setting <code>*default-sound-srate*</code> and reinitializing the environment.  Do not call this within any synthesis function (see the <code>sound-srate-abs</code> transformation, Section <a href = "#94">"Transformations"</a>).<br><br>
<dt><code>set-pitch-names(<a name="index304">)</code> [SAL]<br>

<code>(set-pitch-names)</code> [LIS]<dd>Initializes pitch 
variables (<code>c0</code>, <code>cs0</code>, <code>df0</code>, <code>d0</code>, ... <code>b0</code>, 
 <code>c1</code>, ... <code>b7</code>).  A440 (the default tuning) is represented by
 the step 69.0, so the variable <code>a4</code> (fourth octave A) is set to 69.0.  
You can change the tuning by 
setting <code>*A4-Hertz*</code><a name="index305"><a name="index306"><a name="index307"> to a 
value (in Hertz) and calling <code>set-pitch-names</code> to reinitialize the pitch 
variables.  Note that this will result in non-integer step values.  It does not
alter the mapping from step values to frequency.  There is no built-in 
provision for stretched scales or non-equal temperament, although users 
can write or compute any desired fractional step values.<br><br>
<dt> <code>step-to-hz(<a name="index308"><i>pitch</i>)</code> [SAL]<br>

<code>(step-to-hz <i>pitch</i>)</code> [LISP]<dd>Returns a frequency in hz
for <i>pitch</i>, a step number or a <code>SOUND</code> type representing a time-varying step number. The result is a <code>FLONUM</code> if <i>pitch</i> is a number, and a <code>SOUND</code> if <i>pitch</i> is a <code>SOUND</code>. See also <code>hz-to-step</code> (above).<br><br>
<dt><code>get-duration(<a name="index309"><i>dur</i>)</code> [SAL]<br>

<code>(get-duration <i>dur</i>)</code> [LISP]<dd>Gets the actual duration of of something starting at a local time of 0 and ending at a local time of <i>dur</i> times the current sustain. For convenience,  <code>*rslt*</code> is set to the global time corresponding to local time zero.<br><br>
<dt><code>get-loud(<a name="index310">)</code> [SAL]<br>

<code>(get-loud)</code> [LISP]<dd>Gets the current value of the <code>*loud*</code> environment variable.  If <code>*loud*</code> is a signal, it is evaluated at local time 0 and a number (<code>FLONUM</code>) is returned.<br><br>
<dt><code>get-sustain(<a name="index311">)</code> [SAL]<br>

<code>(get-sustain)</code> [LISP]<dd>Gets the current value of the <code>*sustain*</code> environment variable.  If <code>*sustain*</code> is a signal, it is evaluated at local time 0 and a number (<code>FLONUM</code>) is returned.<br><br>
<dt><code>get-transpose(<a name="index312">)</code> [SAL]<br>

<code>(get-transpose)</code> [LISP]<dd>Gets the current value of the <code>*transpose*</code> environment variable.  If <code>*transpose*</code> is a signal, it is evaluated at local time 0 and a number (<code>FLONUM</code>) is returned.<br><br>
<dt><code>get-warp(<a name="index313">)</code> [SAL]<br>

<code>(get-warp)</code> [LISP]<dd>Gets a function corresponding to 
the current value of the <code>*warp*</code> environment variable.  For 
efficiency, <code>*warp*</code> is stored in three parts representing a shift,
 a scale factor, and a continuous warp function.  <code>Get-warp</code> is used
 to retrieve a signal that maps logical time to real time.  This signal 
combines the information of all three components of <code>*warp*</code> into 
a single signal.  If the continuous warp function component is not present
 (indicating that the time warp is a simple combination of <code>at</code>
 and <code>stretch</code> transformations), an error is raised.  This 
function is mainly for internal system use.  In the future,
 <code>get-warp</code> will probably be reimplemented to always return
 a signal and never raise an error.<br><br>
<dt><code>LOCAL-to-global(<a name="index314"><i>local-time</i>)</code> [SAL]<br>

<code>(local-to-global <i>local-time</i>)</code> [LISP]<dd>Converts a score (local) time to a real (global) time according to the current environment.<br><br>
<dt><code>osc-enable(<a name="index315"><a name="index316"><a name="index317"><i>flag</i>)</code> [SAL]<br>

<code>(osc-enable <i>flag</i>)</code> [LISP]<dd>Enable or disable Open Sound Control. 
(See Appendix <a href = "part17.html#199">"Open Sound Control and Nyquist"</a>.)
Enabling creates a socket and a service that listens for UDP 
packets on port 7770. Currently, only two messages are accepted 
by Nyquist. The first is of the form <code>/slider</code>
with an integer index and a floating point value. These set internal 
slider values accessed by the <code>snd-slider</code> 
function. The second is of the form <code>/wii/orientation</code> with
two floating point values. This message is a special case to 
support the DarwiinRemoteOsc<a name="index318"> program
 which can relay data from
a Nintendo<a name="index319"> WiiMote<a name="index320">
 device to Nyquist via OSC. The two orientation
values control sliders 0 and 1.
Disabling terminates the service (polling for messages) 
and closes the socket. The <i>previous</i> state of enablement
is returned, e.g. if OSC is enabled and <i>flag</i> is <i>nil</i>, 
OSC is disabled and <code>T</code> (true) is returned because OSC 
was enabled at the time of the call. This function only exists 
if Nyquist is compiled with the compiler flag <code>OSC</code>. 
Otherwise, the function 
exists but always returns the symbol <code>DISABLED</code>. Consider 
lowering the audio latency using <code>snd-set-latency</code>.
<i>Warning:</i> there is the potential for 
network-based attacks using OSC. It is tempting to add the 
ability to evaluate XLISP expressions sent via OSC, but 
this would create
unlimited and unprotected access to OSC clients. For now, 
it is unlikely that an attacker could do more than 
manipulate slider values.<br><br>
<dt><code>snd-set-latency(<a name="index321"><a name="index322"><i>latency</i>)</code> [SAL]<br>

<code>(snd-set-latency <i>latency</i>)</code> [LISP]<dd>Set the latency requested when Nyquist plays sound to
 <i>latency</i>, a <code>FLONUM</code>. The previous value is returned. The default is 0.3 seconds. To avoid glitches, the latency should be 
greater than the time required for garbage collection and message printing and any other system activity external to Nyquist.<br><br>
<dt><code>vel-to-db(<a name="index323"><i>x</i>)</code> [SAL]<br>

<code>(vel-to-db <i>x</i>)</code> [LISP]<dd>Returns the conversion
of <i>x</i> from MIDI velocity to decibels using a rule that maps MIDI
velocity 1 to -60 dB and 127 to 0 dB. The amplitude is proportional to
the square of MIDI velocity. The input <i>x</i> can be a <code>FIXNUM</code> or
<code>FLONUM</code> but not a sound. The result is a <code>FLONUM</code>.<br><br>
<dt><code>db-to-vel(<a name="index324"><i>x</i>)</code> [SAL]<br>

<code>(db-to-vel <i>x</i>)</code> [LISP]<dd>Returns the conversion
of <i>x</i> from decibels to MIDI velocity using a rule that maps 0 dB to 
MIDI velocity 127 and -60 dB to MIDI velocity 1.
The MIDI velocity is proportional to the square root of the amplitude. 
The input <i>x</i> can be a <code>FIXNUM</code> or
<code>FLONUM</code> but not a sound. The result is a <code>FLONUM</code>.<br><br>
<dt><code>vel-to-linear(<a name="index325"><i>x</i>)</code>
[SAL]<br>
 <code>(vel-to-linear <i>x</i>)</code> [LISP]<dd>Returns
the conversion of <i>x</i> from MIDI velocity to linear amplitude
ratio using a rule that maps MIDI 
velocity 1 to -60 dB (0.001) and 127 to unity gain. The amplitude is proportional to
the square of MIDI velocity. The input <i>x</i> can be a <code>FIXNUM</code> or
<code>FLONUM</code> but not a sound. The result is a <code>FLONUM</code>.<br><br>
<dt><code>linear-to-vel(<a name="index326"><i>x</i>)</code>
[SAL]<br>
 <code>(linear-to-vel <i>x</i>)</code> [LISP]<dd>Returns
the conversion of <i>x</i> from lineary amplitude to MIDI velocity
using a rule that maps unity gain to 127 and -60 dB (0.001) to MIDI 
velocity 1. The velocity is proportional to
the square root of the linear amplitude. The input <i>x</i> can be a <code>FIXNUM</code> or
<code>FLONUM</code> but not a sound. The result is a <code>FLONUM</code>.<br><br>
<dt></dl><a name = "85"><h3>Behaviors</h3></a><a name="index327">
<a name = "86"><h4>Using Previously Created Sounds</h4></a>

These behaviors take a sound and transform that sound according to the
environment.  These are useful when writing code to make
a high-level function from a low-level function, or when cuing sounds
which were previously created:
<dl>
<dt>
<code>cue(<a name="index328"><i>sound</i>)</code> [SAL]<br>

<code>(cue <i>sound</i>)</code> [LISP]<dd>Applies <code>*loud*</code>, the starting time from <code>*warp*</code>, <code>*start*</code>,
 and <code>*stop*</code> to <i>sound</i>.<br><br>
<dt><code>cue-file(<a name="index329"><i>filename</i>)</code> [SAL]<br>

<code>(cue-file <i>filename</i>)</code> [LISP]<dd>Same as <code>cue</code>, except
the sound comes from the named file, samples from which are coerced to the current default <code>*sound-srate*</code> sample rate.<br><br>
<dt><code>sound(<a name="index330"><i>sound</i>)</code> [SAL]<br>

<code>(sound <i>sound</i>)</code> [LISP]<dd>Applies <code>*loud*</code>, <code>*warp*</code>, 
<code>*start*</code>, and <code>*stop*</code> to <i>sound</i>.<br><br>
<dt><code>control(<a name="index331"><i>sound</i>)</code> [SAL]<br>

<code>(control <i>sound</i>)</code> [LISP]<dd>This function is identical to
<code>sound</code>, but by convention is used when <i>sound</i> is a control signal
rather than an audio signal.
</dl>
<p>
<a name = "87"><h4>Sound Synthesis</h4></a>These functions provide musically interesting creation behaviors that
react to their environment; these are the "unit generators" of Nyquist:
<p>
<dl>
<dt>
<code>const(<a name="index332"><a name="index333"><i>value</i> [, <i>duration</i>])</code> [SAL]<br>

<code>(const <i>value</i> [<i>duration</i>])</code> [LISP]<dd>Creates a constant function at the <code>*control-srate*</code>.  Every sample has the given <i>value</i>, and the default <i>duration</i> is 1.0.  See also <code>s-rest</code>, which is equivalent to calling <code>const</code> with zero, and note that you can pass scalar constants (numbers) to <code>sim</code>, <code>sum</code>, and <code>mult</code> where they are handled more efficiently than constant functions.<br><br>
<dt><code>env(<a name="index334"><i>t1</i>, <i>t2</i>, <i>t4</i>, <i>l1</i>, <i>l2</i>, <i>l3</i>, 
[<i>dur</i>])</code> [SAL]<br>

<code>(env <i>t1</i> <i>t2</i> <i>t4</i> <i>l1</i> <i>l2</i> <i>l3</i> <i>dur</i>)</code> [LISP]<dd>Creates a 4-phase envelope.
<i>t<i>i</i></i> is the duration of phase <i>i</i>, and <i>l<i>i</i></i> 
is the final level of phase <i>i</i>.  <i>t3</i> is implied by the duration
<i>dur</i>, and <i>l4</i> is <code>0.0</code>.  If <i>dur</i> is not supplied, then
<code>1.0</code> is assumed.  The envelope duration is the product of <i>dur</i>,
<code>*stretch*</code>, and <code>*sustain*</code>.  If 
<i>t1</i> + <i>t2</i> + 2ms + <i>t4</i> is greater than the envelope 
duration, then a two-phase envelope is
substituted that has an attack/release time ratio of <i>t1</i>/<i>t4</i>.
The sample rate of the returned sound is <code>*control-srate*</code>.  (See
<code>pwl</code> for a more general piece-wise linear function generator.)
The effect of time warping is to warp the starting time and ending time.
The intermediate breakpoints are then computed as described above.<br><br>
<dt><code>exp-dec(<a name="index335"><a name="index336"><i>hold</i>, <i>halfdec</i>, <i>length</i>)</code> [SAL]<br>

<code>(exp-dec <i>hold</i> <i>halfdec</i> <i>length</i>)</code> [LISP]<dd>This convenient envelope shape is a special case of <code>pwev</code> (see Section <a href = "#89">"Piece-wise Approximations"</a>). The envelope starts at 1 and is constant for <i>hold</i> seconds. It then decays with a half life of <i>halfdec</i> seconds until <i>length</i>. (The total duration is <i>length</i>.) In other words, the amplitude falls by half each <i>halfdec</i> seconds. When stretched, this envelope scales linearly, which means the hold time increases and the half decay time increases.<br><br>
<dt>
<code>force-srate(<a name="index337"><a name="index338"><a name="index339"><i>srate</i>, <i>sound</i>)</code> [SAL]<br>

<code>(force-srate <i>srate</i> <i>sound</i>)</code> [LISP]<dd>Returns a sound which is up- or
down-sampled to <i>srate</i>.  Interpolation is linear, and no prefiltering is
applied in the down-sample case, so aliasing may occur. See also
<code>resample</code>.<br><br>
<dt><code>lfo(<a name="index340"><a name="index341"><i>freq</i> [, <i>duration</i>, <i>table</i>, <i>phase</i>])</code> [SAL]<br>

<code>(lfo <i>freq</i> <i>duration</i> <i>table</i> <i>phase</i>)</code> [LISP]<dd>Just
like <code>osc</code> (below)
except this computes at the <code>*control-srate*</code> and frequency
is specified in Hz.  Phase is specified in degrees.
 The <code>*transpose*</code> and <code>*sustain*</code> is not
applied.  The effect of time warping is to warp the starting and ending
times.  The signal itself will have a constant unwarped frequency.<br><br>
<dt><code>fmlfo(<a name="index342"><i>freq</i> [, <i>table</i>, <i>phase</i>])</code> [SAL]<br>

<code>(fmlfo <i>freq</i> [<i>table</i> <i>phase</i>])</code> [LISP]<dd>A low-frequency oscillator
that computes at the <code>*control-srate*</code> using a sound to specify a time-varying 
frequency in Hz. Phase is a <code>FLONUM</code> in degrees. The duration of the result is determined by <i>freq</i>.<br><br>
<dt><code>maketable(<a name="index343"><i>sound</i>)</code> [SAL]<br>

<code>(maketable <i>sound</i>)</code> [LISP]<dd>Assumes that
the samples in <i>sound</i> constitute one period of a wavetable, and returns a wavetable
suitable for use as the <i>table</i> argument to the <code>osc</code> function (see
below).  Currently, tables are limited to 1,000,000 samples.  This limit is the compile-time constant <code>max_table_len</code> set in <code>sound.h</code>.<br><br>
<dt><code>build-harmonic(<a name="index344"><a name="index345"><i>n</i>, <i>table-size</i>)</code> [SAL]<br>

<code>(build-harmonic <i>n</i> <i>table-size</i>)</code> [LISP]<dd>Intended for
constructing wavetables<a name="index346"><a name="index347">, this function returns a sound of length <i>table-size</i>
samples containing <i>n</i> periods of a sinusoid.  These can be scaled and
summed to form a waveform with the desired harmonic content.  See <a href = "part2.html#11">"Waveforms"</a> for an example.<br><br>
<dt><code>control-warp(<a name="index348"><i>warp-fn</i>, <i>signal</i>,   [<i>wrate</i>])</code> [SAL]<br>

<code>(control-warp <i>warp-fn</i> <i>signal</i> <i>wrate</i>)</code> [LISP]<dd>Applies a
warp function <i>warp-fn</i> to <i>signal</i> using function composition.  If <i>wrate</i> is omitted, linear
interpolation is used.  <i>warp-fn</i> is a mapping from score (logical) time
to real time, and <i>signal</i> is a function from score time to real values.
The result is a function from real time to real values at a sample rate of
<code>*control-srate*</code>. See <code>sound-warp</code> for an explanation of
<i>wrate</i> and high-quality warping.<br><br>
<dt>
<code>mult(<a name="index349"><i>beh1</i>, <i>beh2</i>, <span style="font-style:normal">...</span>)</code> [SAL]<br>

<code>(mult <i>beh1</i> <i>beh2 <span style="font-style:normal">...</span></i>)</code> [LISP]<dd>Returns the product of
behaviors.  The arguments may also be numbers, in which case simple multiplication is performed.  If a number and sound are mixed, the <code>scale</code> function is used to scale the sound by the number. When sounds are multiplied, the resulting sample rate is the maximum sample rate of the factors.<br><br>
<dt><code>prod(<a name="index350"><i>beh1</i>, <i>beh2</i>, <span style="font-style:normal">...</span>)</code> [SAL]<br>

<code>(prod <i>beh1</i> <i>beh2</i> <span style="font-style:normal">...</span>)</code> [LISP]<dd>Same as <code>mult</code>.<br><br>
<dt>
<code>pan(<a name="index351"><a name="index352"><i>sound</i>, <i>where</i>)</code> [SAL]<br>

<code>(pan <i>sound</i> <i>where</i>)</code> [LISP]<dd>Pans <i>sound</i> (a behavior) according  to <i>where</i> (another behavior or a number). <i>Sound</i> must be monophonic. <i>Where</i> may be a monophonic sound (e.g. <code>(ramp)</code> or simply a number (e.g. <code>0.5</code>). In either case, <i>where</i> should range from 0 to 1, where 0 means pan completely left, and 1 means pan completely right. For intermediate values, the sound to each channel is scaled linearly. Presently, <code>pan</code> does not check its arguments carefully.<br><br>
<dt><code>prod(<a name="index353"><i>beh1</i>, <i>beh2</i>, <span style="font-style:normal">...</span>)</code> [SAL]<br>

<code>(prod <i>beh1</i> <i>beh2</i> <span style="font-style:normal">...</span>)</code> [LISP]<dd>Same as <code>mult</code>.<br><br>
<dt>
<code>resample(<a name="index354"><i>sound</i>, <i>srate</i>)</code> [SAL]<br>

<code>(resample <i>sound</i> <i>srate</i>)</code> [LISP]<dd>Similar to <code>force-srate</code>, except
high-quality interpolation is used to prefilter and reconstruct the signal
at the new sample rate. Also, the result is scaled by 0.95 to reduce problems with
clipping. (See also <code>sound-warp</code>.)<br><br>
<dt>
<code>scale(<a name="index355"><i>scale</i>, <i>sound</i>)</code> [SAL]<br>

<code>(scale <i>scale</i> <i>sound</i>)</code> [LISP]<dd>Scales the amplitude of <i>sound</i> by the factor <i>scale</i>.  Identical function to <code>snd-scale</code>, except that it handles multichannel sounds.  Sample rates, start times, etc. are taken from <i>sound</i>.<br><br>
<dt><code>scale-db(<a name="index356"><i>db</i>, <i>sound</i>)</code> [SAL]<br>

<code>(scale-db <i>db</i> <i>sound</i>)</code> [LISP]<dd>Scales the amplitude of <i>sound</i> by the factor <i>db</i>, expressed in decibels.  Sample rates, start times, etc. are taken from <i>sound</i>.<br><br>
<dt><code>scale-srate(<a name="index357"><i>sound</i>, <i>scale</i>)</code> [SAL]<br>

<code>(scale-srate <i>sound</i> <i>scale</i>)</code> [LISP]<dd>Scales the sample rate of <i>sound</i> by <i>scale</i> factor.  This has the effect of linearly shrinking or stretching time (the sound is not upsampled or downsampled).  This is a special case of <code>snd-xform</code> (see Section <a href = "#99">"Signal Operations"</a>).<br><br>
<dt><code>shift-time(<a name="index358"><i>sound</i>, <i>shift</i>)</code> [SAL]<br>

<code>(shift-time <i>sound</i> <i>shift</i>)</code> [LISP]<dd>Shift <i>sound</i>
by <i>shift</i> seconds.  If the sound is 

f(t), then the result is

f(t - shift).
See Figure <a href = "#87">5</a>.  This is a special
case of <code>snd-xform</code> (see Section <a href = "#99">"Signal Operations"</a>).
</dl>
<p>
<hr>
<blockquote></blockquote>
<img src="fig5.gif"><br><br>

<p>
<b>Figure 5: </b>The <code>shift-time</code> function shifts a sound in time
according to its <i>shift</i> argument.

<hr>
<p>
<dl>
<dt>
<code>sound-warp(<a name="index359"><i>warp-fn</i>, <i>signal</i> [, <i>wrate</i>])</code> [SAL]<br>

<code>(sound-warp <i>warp-fn</i> <i>signal</i> [<i>wrate</i>])</code> [LISP]<dd>Applies a
warp function <i>warp-fn</i> to <i>signal</i> using function composition.  If the optional parameter <i>wrate</i> is omitted or NIL, linear
interpolation is used.  Otherwise, high-quality sample interpolation is used, and the
result is scaled by 0.95 to reduce problems with clipping (interpolated samples can
exceed the peak values of the input samples.) 
<i>warp-fn</i> is a mapping from score (logical) time
to real time, and <i>signal</i> is a function from score time to real values.
The result is a function from real time to real values at a sample rate of <code>*sound-srate*</code>.
See also <code>control-warp</code>.
<br><br>
<dt>
If <i>wrate</i> is not NIL, it must be a number. The parameter indicates that
high-quality resampling should be used and specifies the sample rate for the
inverse of <i>warp-fn</i>. Use the lowest number you can.
 (See below for details.) Note that high-quality resampling is
much slower than linear interpolation. 
<br><br>
<dt>
To perform high-quality resampling by a fixed ratio, as opposed to a
variable ratio allowed in <code>sound-warp</code>, use <code>scale-srate</code> to
stretch or shrink the sound, and then <code>resample</code> to restore the
original sample rate.
<br><br>
<dt>
<code>Sound-warp</code> and <code>control-warp</code> both take the inverse of
<i>warp-fn</i> to get a function from real time to score time. Each sample
of this inverse is thus a score time; <i>signal</i> is evaluated at each of
these score times to yield a value, which is the desired result. The 
sample rate of the inverse warp function is somewhat arbitrary. With linear
interpolation, the inverse warp function sample rate is taken to be the
output sample rate. Note, however, that the samples of the inverse warp
function are stored as 32-bit floats, so they have limited precision. Since
these floats represent sample times, rounding can be a problem. Rounding
in this case is equivalent to adding jitter to the sample times. Nyquist
ignores this problem for ordinary warping, but for high-quality warping, the
jitter cannot be ignored. 
<br><br>
<dt>
The solution is to use a rather low sample rate
for the inverse warp function. <code>Sound-warp</code> can then linearly
interpolate this signal using double-precision floats to minimize jitter
between samples. The sample rate is a compromise: a low sample rate
minimizes jitter, while a high sample rate does a better job of capturing
detail (e.g. rapid fluctuations) in the warp function. A good rule of thumb
is to use at most 1,000 to 10,000 samples for the inverse warp function. For
example, if the result will be 1 minute of sound, use a sample rate of
3000 samples / 60 seconds = 50 samples/second. Because Nyquist has no
advance information about the warp function, the inverse warp function
sample rate must be provided as a parameter.  When in doubt, just try
something and let your ears be the judge.<br><br>
<dt><code>integrate(<a name="index360"><a name="index361"><i>signal</i>)</code> [SAL]<br>

<code>(integrate <i>signal</i>)</code> [LISP]<dd>Computes the integral of <i>signal</i>. The start time, sample rate, etc. are taken from <i>signal</i>.<br><br>
<dt><code>slope(<a name="index362"><a name="index363"><a name="index364"><i>signal</i>)</code> [SAL]<br>

<code>(slope <i>signal</i>)</code> [LISP]<dd>Computes the first derivative (slope) of <i>signal</i>.  The start time, sample rate, etc. are taken from <i>signal</i>.
</dl>
<p>
<a name = "88"><h5>Oscillators</h5></a>

<dl>
<dt>
<code>osc(<a name="index365"><i>pitch</i> [, <i>duration</i>, <i>table</i>, <i>phase</i>])</code> [SAL]<br>

<code>(osc <i>pitch</i> [<i>duration</i> <i>table</i> <i>phase</i>])</code> [LISP]<dd>Returns 
a sound which
is the <i>table</i> oscillated at <i>pitch</i> for the given <i>duration</i>,
starting with the <i>phase</i> (in degrees).  
Defaults are:  <i>duration</i> <code>1.0</code> 
(second), <i>table</i> <code>*table*</code>,
<i>phase</i> <code>0.0</code>.  The default value of <code>*table*</code> is a sinusoid. Duration is stretched by <code>*warp*</code> and 
<code>*sustain*</code>, amplitude is nominally 1, but scaled by <code>*loudness*</code>, the start time is logical time 0, transformed by <code>*warp*</code>, and the sample rate is <code>*sound-srate*</code>.
The effect of time-warping is to warp the starting and ending times only; the
signal has a constant unwarped frequency.
 <b><i>Note 1:</i></b> <i>table</i> is a list of the form
<blockquote>
(<i>sound</i> <i>pitch-number</i> <i>periodic</i>)<br>

</blockquote>
where the first element is a sound, the second is the pitch of the sound 
(this is not redundant, because the sound may represent any number of
periods), and the third element is <code>T</code> if the sound is one period of
a periodic signal, or <code>nil</code> if the sound is a sample that should not
be looped.  The maximum table size is set by <code>max_table_len</code> in <code>sound.h</code>, and is currently set to 1,000,000.
<b><i>Note 2:</i></b> in the current implementation, it is assumed that the
output should be periodic.  See <code>snd-down</code> and <code>snd-up</code> for resampling one-shot sounds to a desired sample rate.  A future version of <code>osc</code>
will handle both cases.  
<b><i>Note 3:</i></b> When <code>osc</code> is called, memory is allocated for the table, and samples are copied from the sound (the first element of the list which is the <i>table</i> parameter) to the memory.  Every instance of <code>osc</code> has a private copy of the table, so the total storage can become large in some cases, for example in granular synthesis with many instances of <code>osc</code>. In some cases, it may make sense to use <code>snd-flatten</code> (see Section <a href = "#83">"Accessing and Creating Sound"</a>) to cause the sound to be fully realized, after which the <code>osc</code> and its table memory can be reclaimed by garbage collection. The <code>partial</code> function (see below) does not need a private table and does not use much space.<br><br>
<dt>
<code>partial(<a name="index366"><i>pitch</i>, <i>env</i>)</code> [SAL]<br>

<code>(partial <i>pitch</i> <i>env</i>)</code> [LISP]<dd>Returns a sinusoid at
the indicated pitch; the sound is multiplied by <i>env</i>.  The start time and
duration are taken from <i>env</i>, which is of course subject to
transformations.  The sample rate is <code>*sound-srate*</code>.  The <code>partial</code>
function is faster than <code>osc</code>.<br><br>
<dt>
<code>sine(<a name="index367"><i>pitch</i> [, <i>duration</i>])</code> [SAL]<br>

<code>(sine <i>pitch</i> [<i>duration</i>])</code> [LISP]<dd>Returns a sinusoid at
the indicated pitch.  The sample rate is <code>*sound-srate*</code>.  
This function is like <code>osc</code> with
respect to transformations.  The <code>sine</code> function is faster than
<code>osc</code>.<br><br>
<dt><code>hzosc(<a name="index368"><i>hz</i> [, <i>table</i>, <i>phase</i>])</code> [SAL]<br>

<code>(hzosc <i>hz</i> [<i>table</i> <i>phase</i>])</code> [LISP]<dd>Returns a sound which is the <i>table</i> oscillated at <i>hz</i> starting at <i>phase</i> degrees. The default <i>table</i> is <code>*table*</code> and the default <i>phase</i> is <i>0.0</i>. The default duration is <code>1.0</code>, but this is stretched as in <code>osc</code> (see above). The <i>hz</i> parameter may be a <code>SOUND</code>, in which case the duration of the result is the duration of <i>hz</i>. The sample rate is <code>*sound-srate*</code>.<br><br>
<dt><code>osc-saw(<a name="index369"><a name="index370"><i>hz</i>)</code> [SAL]<br>

<code>(osc-saw <i>hz</i>)</code> [LISP]<dd>Returns a sawtooth waveshape at the indicated frequency (in Hertz). The sample rate is <code>*sound-srate*</code>. The <i>hz</i> parameter may be a sound as in <i>hzosc</i> (see above).<br><br>
<dt><code>osc-tri(<a name="index371"><a name="index372"><i>hz</i>)</code> [SAL]<br>

<code>(osc-tri <i>hz</i>)</code> [LISP]<dd>Returns a triangle waveshape at the indicated frequency (in Hertz). The sample rate is <code>*sound-srate*</code>. The <i>hz</i> parameter may be a sound as in <i>hzosc</i> (see above).<br><br>
<dt><code>osc-pulse(<a name="index373"><a name="index374"><a name="index375"><a name="index376"><i>hz</i>, <i>bias</i> [, <i>compare-shape</i>])</code> [SAL]<br>

<code>(osc-pulse <i>hz</i> <i>bias</i> [<i>compare-shape</i>])</code> [LISP]<dd>Returns a square pulse with variable width at the indicated frequency (in Hertz). The <i>bias</i> parameter controls the pulse width and should be between <code>-1</code> and <code>+1</code>, giving a pulse width from 0% (always at <code>-1</code>) to 100% (always at <code>+1</code>). When bias is zero, a square wave is generated. Bias may be a <code>SOUND</code> to create varying pulse width. If bias changes rapidly, strange effects may occur. The optional <i>compare-shape</i> defaults to a hard step at zero, but other shapes may be used to achieve non-square pulses. The <code>osc-pulse</code> behavior is written in terms of other behaviors and defined in the file <code>nyquist.lsp</code> using just a few lines of code. Read the code for the complete story.<br><br>
<dt>
<code>amosc(<a name="index377"><i>pitch</i>, <i>modulation</i> [, <i>table</i>,
<i>phase</i>])</code> [SAL]<br>

<code>(amosc <i>pitch</i> <i>modulation</i> [<i>table</i> <i>phase</i>])</code> [LISP]<dd>Returns a
sound which is <i>table</i> oscillated at <i>pitch</i>.  The output
is multiplied by <i>modulation</i>
for the duration of the sound <i>modulation</i>.  
<i>osc-table</i> defaults to
<code>*table*</code>, and <i>phase</i> is the starting phase (default 0.0 degrees)
within <i>osc-table</i>.  The sample rate is <code>*sound-srate*</code>.  <br><br>
<dt>
<code>fmosc(<a name="index378"><i>pitch</i>, <i>modulation</i> [, <i>table</i>,
<i>phase</i>])</code> [SAL]<br>

<code>(fmosc <i>pitch</i> <i>modulation</i> [<i>table</i> <i>phase</i>])</code> [LISP]<dd>Returns a
sound which is <i>table</i> oscillated at <i>pitch</i> plus <i>modulation</i>
for the duration of the sound <i>modulation</i>.  
<i>osc-table</i> defaults to
<code>*table*</code>, and <i>phase</i> is the starting phase (default 0.0 degrees)
within <i>osc-table</i>.  The <i>modulation</i>
is expressed in hz, e.g. a sinusoid modulation signal with an
amplitude of 1.0 (2.0 peak to peak), will cause a +/- 1.0 hz 
frequency deviation in <i>sound</i>.  Negative frequencies are correctly
handled.  The sample rate is <code>*sound-srate*</code>.  <br><br>
<dt>
<code>fmfb(<a name="index379"><a name="index380"><i>pitch</i>, <i>index</i> [, <i>dur</i>])</code> [SAL]<br>

<code>(fmfb <i>pitch</i> <i>index</i> [<i>dur</i>])</code> [LISP]<dd>Returns
a sound generated by feedback FM synthesis. The <i>pitch</i> parameter
(given in the usual half-step units) 
controls the fundamental frequency. The <i>index</i> is the amount of
feedback, which may be a <code>SOUND</code> or a <code>FLONUM</code>. If <i>index</i> is
a <code>FLONUM</code>, <i>dur</i> must be provided (a <code>FLONUM</code>) to specify
the duration. Otherwise, <i>dur</i> is ignored if present and the duration is
determined by that of <i>index</i>. The sample rate is <code>*sound-srate*</code>.
A sinusoid table is used.
If <i>index</i> is below 1.1, this generates a sawtooth-like waveform.<br><br>
<dt>
<code>buzz(<a name="index381"><i>n</i>, <i>pitch</i>, <i>modulation</i>)</code> [SAL]<br>

<code>(buzz <i>n</i> <i>pitch</i> <i>modulation</i>)</code> [LISP]<dd>Returns a
sound with <i>n</i> harmonics of equal amplitude and a total amplitude
of 1.0, using a well-known function of two cosines. If <i>n</i> (an integer)
is less than 1, it is set to 1. Aliasing will occur if <i>n</i> is too large.
The duration is
determined by the duration of the sound <i>modulation</i>, which is a
frequency modulation term expressed in Hz (see Section <a href = "#88">"Oscillators"</a>).
Negative frequencies are correctly handled.
The sample rate is <code>*sound-srate*</code>.<br><br>
<dt>
<code>pluck(<a name="index382"><a name="index383"><a name="index384"><a name="index385"><i>pitch</i> [, <i>duration</i>, <i>final-amplitude</i>])</code> [SAL]<br>

<code>(pluck <i>pitch</i> [<i>duration</i> <i>final-amplitude</i>])</code> [LISP]<dd>Returns a sound at the 
given <i>pitch</i> created using a modified Karplus-Strong plucked string
algorithm. The tone decays from an amplitude of about 1.0 to about
<i>final-amplitude</i> in <i>duration</i> seconds. The default values are to
decay to 0.001 (-60dB) in 1 second. The sample rate is <code>*sound-srate*</code>.<br><br>
<dt>
<code>siosc(<a name="index386"><a name="index387"><i>pitch</i>,
<i>modulation</i>, <i>tables</i>)</code> [SAL]<br>

<code>(siosc <i>pitch</i> <i>modulation</i> <i>tables</i>)</code> [LISP]<dd>Returns a sound constructed by
interpolating through a succession of periodic waveforms. The frequency is
given (in half steps) by <i>pitch</i> to which a <i>modulation</i> signal (in hz)
is added, exactly as in <code>fmosc</code>. The <i>tables</i> specify a list of
waveforms as follows: (<i>table0</i> <i>time1</i> <i>table2</i> ... <i>timeN</i>
<i>tableN</i>), where each <i>table</i> is a sound representing one period. Each
<i>time</i> is a time interval measured from the starting time. The time is
scaled by the nominal duration (computed using <code>(local-to-global
(get-sustain))</code>) to get the actual time. Note that this implies linear
stretching rather than continuous timewarping of the interpolation or the
breakpoints. The waveform is <i>table0</i> at the starting time, <i>table1</i>
after <i>time1</i> (scaled as described), and so on. The duration and logical
stop time is given by <i>modulation</i>. If <i>modulation</i> is shorter than
<i>timeN</i>, then the full sequence of waveforms is not used.  If
<i>modulation</i> is longer than <i>timeN</i>, <i>tableN</i> is used after <i>timeN</i>
without further interpolation.<br><br>
<dt>
<code>sampler(<a name="index388"><i>pitch</i>, <i>modulation</i>
 [, <i>sample</i>, <i>npoints</i>])</code> [SAL]<br>

<code>(sampler <i>pitch</i> <i>modulation</i> [<i>sample</i> <i>npoints</i>])</code> [LISP]<dd>Returns a sound constructed by reading a sample from 
beginning to end and then splicing on copies of the same sound from 
a loop point to the end.  
The <i>pitch</i> and <i>modulation</i> parameters are used as in <code>fmosc</code>
described above.  The optional <i>sample</i> (which defaults to the global
variable <code>*table*</code> is a list of the form
<blockquote>
(<i>sound</i> <i>pitch-number</i> <i>loop-start</i>)<br>

</blockquote>
where the first element is a sound containing the sample, the second is the
pitch of the sample, and the third element is the time of the loop point. If
the loop point is not in the bounds of the sound, it is set to zero.
The optional <i>npoints</i> specifies how many points should be used for sample
interpolation.  Currently this parameter defaults to 2 and only 2-point
(linear) interpolation is implemented.  It is an error to modulate such that the frequency
is negative. Note also that the loop point may be fractional.
The sample rate is <code>*sound-srate*</code>.  
</dl>
<p>
<a name = "89"><h5>Piece-wise Approximations</h5></a>
<a name="index389"><a name="index390"><a name="index391">
There are a number of related behaviors for piece-wise approximations to functions.  The simplest of these, <code>pwl</code> was mentioned earlier in the manual.  It takes a list of breakpoints, assuming an initial point at (0, 0), and a final value of 0.  An analogous piece-wise exponential function, <code>pwe</code>, is provided. Its implicit starting and stopping values are 1 rather than 0.  Each of these has variants.   You can specify the initial and final values (instead of taking the default).  You can specify time in intervals rather than cummulative time.  Finally, you can pass a list rather than an argument list.  This leads to 16 versions:
<blockquote></blockquote>
<pre><b>Piece-wise Linear Functions:</b>
	<i>Cummulative Time:</i>
		<i>Default initial point at (0, 0), final value at 0:</i>
			pwl
			pwl-list
		<i>Explicit initial value:</i>
			pwlv
			pwlv-list
	<i>Relative Time:</i>
		<i>Default initial point at (0, 0), final value at 0:</i>
			pwlr
			pwlr-list
		<i>Explicit initial value:</i>
			pwlvr
			pwlvr-list
<p>
<b>Piece-wise Exponential Functions:</b>
	<i>Cummulative Time:</i>
		<i>Default initial point at (0, 1), final value at 1:</i>
			pwe
			pwe-list
		<i>Explicit initial value:</i>
			pwev
			pwev-list
	<i>Relative Time:</i>
		<i>Default initial point at (0, 1), final value at 1:</i>
			pwer
			pwer-list
		<i>Explicit initial value:</i>
			pwevr
			pwevr-list
</pre>
All of these functions are implemented in terms of <code>pwl</code> (see <code>nyquist.lsp</code> for the implementations.  There are infinite opportunities for errors in these functions: if you leave off a data point, try to specify points in reverse order, try to create an exponential that goes to zero or negative values, or many other bad things, the behavior is not well-defined.  Nyquist should not crash, but Nyquist does not necessarily attempt to report errors at this time.
<p>
<dl>
<dt>

<code>pwl(<a name="index392"><i>t1</i>, <i>l1</i>, <i>t2</i>, <i>l2</i>, <span style="font-style:normal">...</span> <i>tn</i>)</code> [SAL]<br>

<code>(pwl <i>t1</i> <i>l1</i> <i>t2</i> <i>l2</i> <span style="font-style:normal">...</span> <i>tn</i>)</code> [LISP]<dd>Creates
a piece-wise linear envelope with breakpoints at (0, 0), (<i>t1</i>,
<i>l1</i>), (<i>t2</i>, <i>l2</i>), ... (<i>tn</i>, 0).  The breakpoint
times are scaled linearly by the value of <code>*sustain*</code> (if
<code>*sustain*</code> is a <code>SOUND</code>, it is evaluated once at the starting
time of the envelope).  Each breakpoint time is then mapped according to
<code>*warp*</code>.  The result is a linear interpolation (unwarped) between 
the breakpoints.  The sample rate is <code>*control-srate*</code>.  Breakpoint
times are quantized to the nearest sample time.  If you specify one or more
breakpoints withing one sample period, <code>pwl</code> attempts to give a good
approximation to the specified function.  In particular, if two breakpoints
are simultaneous, <code>pwl</code> will move one of them to an adjacent sample,
producing a steepest possible step in the signal.  The exact details of this
"breakpoint munging" is subject to change in future versions.  Please report
any cases where breakpoint lists give unexpected behaviors.  The author will
try to apply the "principle of least surprise" to the design.  Note that
the times are relative to 0; they are not durations of each envelope
segment.<br><br>
<dt><code>pwl-list(<a name="index393"><i>breakpoints</i>)</code> [SAL]<br>

<code>(pwl-list <i>breakpoints</i>)</code> [LISP]<dd>If you have a list of
breakpoints, you can use <code>apply</code> to apply the <code>pwl</code> function to
the breakpoints, but if the list is very long (hundreds or thousands of
points), you might get a stack overflow because XLISP has a fixed-size
argument stack.  Instead, call <code>pwl-list</code>, passing one argument, the
list of breakpoints.<br><br>
<dt><code>pwlv(<a name="index394"><i>l1</i>, <i>t2</i>, <i>l2</i>, <i>t3</i>, <i>t3</i>, ... <i>tn</i>, <i>ln</i>)</code> [SAL]<br>

<code>(pwlv <i>l1</i> <i>t2</i> <i>l2</i> <i>t3</i> <i>t3</i> <span style="font-style:normal">...</span> <i>tn</i> <i>ln</i>)</code> [LISP]<dd>Creates
a piece-wise linear envelope with breakpoints at (0, l1), (<i>t2</i>, <i>l2</i>), etc., ending with (<i>tn, <i>ln</i></i>.  Otherwise, the behavior is like that of <code>pwl</code>.<br><br>
<dt><code>pwlv-list(<a name="index395"><i>breakpoints</i>)</code> [SAL]<br>

<code>(pwlv-list <i>breakpoints</i>)</code> [LISP]<dd>A version of <code>pwlv</code> that takes a single list of breakpoints as its argument.  See <code>pwl-list</code> above for the rationale.<br><br>
<dt><code>pwlr(<a name="index396"><i>i1</i>, <i>l1</i>, <i>i2</i>, <i>l2</i>, ... <i>in</i>)</code> [SAL]<br>

<code>(pwlr <i>i1</i> <i>l1</i> <i>i2</i> <i>l2</i> <span style="font-style:normal">...</span> <i>in</i>)</code> [LISP]<dd>Creates
a piece-wise linear envelope with breakpoints at (0, 0), (<i>t1</i>,
<i>l1</i>), (<i>t2</i>, <i>l2</i>), ... (<i>tn</i>, 0), where <i>tj</i> is the sum of <i>i1</i> through <i>ij</i>.  In other words, the breakpoint times are specified in terms of intervals rather than cummulative time.   Otherwise, the behavior is like that of <code>pwl</code>.<br><br>
<dt><code>pwlr-list(<a name="index397"><i>breakpoints</i>)</code> [SAL]<br>

<code>(pwlr-list <i>breakpoints</i>)</code> [LISP]<dd>A version of <code>pwlr</code> that takes a single list of breakpoints as its argument.  See <code>pwl-list</code> above for the rationale.<br><br>
<dt><code>pwlvr(<a name="index398"><i>l1</i>, <i>i2</i>, <i>l2</i>, <i>i3</i>, <i>i3</i>, ... <i>in</i>, <i>ln</i>)</code> [SAL]<br>

<code>(pwlvr <i>l1</i> <i>i2</i> <i>l2</i> <i>i3</i> <i>i3</i> <span style="font-style:normal">...</span> <i>in</i> <i>ln</i>)</code> [LISP]<dd>Creates
a piece-wise linear envelope with breakpoints at (0, l1), (<i>t2</i>, <i>l2</i>), etc., ending with (<i>tn, <i>ln</i></i>, where <i>tj</i> is the sum of <i>i2</i> through <i>ij</i>.  In other words, the breakpoint times are specified in terms of intervals rather than cummulative time.   Otherwise, the behavior is like that of <code>pwlv</code>.<br><br>
<dt><code>pwlvr-list(<a name="index399"><i>breakpoints</i>)</code> [SAL]<br>

<code>(pwlvr-list <i>breakpoints</i>)</code> [LISP]<dd>A version of <code>pwlvr</code> that takes a single list of breakpoints as its argument.  See <code>pwl-list</code> above for the rationale.<br><br>
<dt><code>pwe(<a name="index400"><i>t1</i>, <i>l1</i>, <i>t2</i>, <i>l2</i>, <span style="font-style:normal">...</span> <i>tn</i>)</code> [SAL]<br>

<code>(pwe <i>t1</i> <i>l1</i> <i>t2</i> <i>l2</i> <span style="font-style:normal">...</span> <i>tn</i>)</code> [LISP]<dd>Creates
a piece-wise exponential envelope with breakpoints at (0, 1), (<i>t1</i>,
<i>l1</i>), (<i>t2</i>, <i>l2</i>), ... (<i>tn</i>, 1).  Exponential segments means that the ratio of values from sample to sample is constant within the segment.  (The current implementation actually takes the log of each value, computes a piece-wise exponential from the points using <code>pwl</code>, then exponentiates each resulting sample.  A faster implementation is certainly possible!)  Breakpoint values (<i>lj</i>) must be greater than zero.  Otherwise, this function is similar to <code>pwl</code>, including stretch by <code>*sustain*</code>, mapping according to <code>*warp*</code>, sample rate based on <code>*control-srate*</code>, and "breakpoint munging" (see <code>pwl</code> described above).  <i>Default initial and final values are of dubious value with exponentials.  See <code>pwev</code> below for the function you are probably looking for.</i><br><br>
<dt><code>pwe-list(<a name="index401"><i>breakpoints</i>)</code> [SAL]<br>

<code>(pwe-list <i>breakpoints</i>)</code> [LISP]<dd>A version of <code>pwe</code> that takes a single list of breakpoints as its argument.  See <code>pwl-list</code> above for the rationale.<br><br>
<dt>
<code>pwev(<a name="index402"><i>l1</i>, <i>t2</i>, <i>l2</i>, <i>t3</i>, <i>t3</i>, <span style="font-style:normal">...</span> <i>tn</i>, <i>ln</i>)</code> [SAL]<br>

<code>(pwev <i>l1</i> <i>t2</i> <i>l2</i> <i>t3</i> <i>t3</i> <span style="font-style:normal">...</span> <i>tn</i> <i>ln</i>)</code> [LISP]<dd>Creates
a piece-wise exponential envelope with breakpoints at (0, <i>l1</i>), (<i>t2</i>, <i>l2</i>), etc., ending with (<i>tn</i>, <i>ln</i>).  Otherwise, the behavior is like that of <code>pwe</code>.  <br><br>
<dt><code>pwev-list(<a name="index403"><i>breakpoints</i>)</code> [SAL]<br>

<code>(pwev-list <i>breakpoints</i>)</code> [LISP]<dd>A version of <code>pwev</code> that takes a single list of breakpoints as its argument.  See <code>pwl-list</code> above for the rationale.<br><br>
<dt><code>pwer(<a name="index404"><i>i1</i>, <i>l1</i>, <i>i2</i>, <i>l2</i>, <span style="font-style:normal">...</span> <i>in</i>)</code> [SAL]<br>

<code>(pwer <i>i1</i> <i>l1</i> <i>i2</i> <i>l2</i> <span style="font-style:normal">...</span> <i>in</i>)</code> [LISP]<dd>Creates
a piece-wise exponential envelope with breakpoints at (0, 1), (<i>t1</i>,
<i>l1</i>), (<i>t2</i>, <i>l2</i>), ... (<i>tn</i>, 1), where <i>tj</i> is the sum of <i>i1</i> through <i>ij</i>.  In other words, the breakpoint times are specified in terms of intervals rather than cummulative time.   Otherwise, the behavior is like that of <code>pwe</code>.  Consider using <code>pwerv</code> instead of this one.<br><br>
<dt><code>pwer-list(<a name="index405"><i>breakpoints</i>)</code> [SAL]<br>

<code>(pwer-list <i>breakpoints</i>)</code> [LISP]<dd>A version of <code>pwer</code> that takes a single list of breakpoints as its argument.  See <code>pwl-list</code> above for the rationale.<br><br>
<dt><code>pwevr(<a name="index406"><a name="index407"><i>l1</i>, <i>i2</i>, <i>l2</i>, <i>i3</i>, <i>i3</i>, <span style="font-style:normal">...</span> <i>in</i>, <i>ln</i>)</code> [SAL]<br>

<code>(pwevr <i>l1</i> <i>i2</i> <i>l2</i> <i>i3</i> <i>i3</i> <span style="font-style:normal">...</span> <i>in</i> <i>ln</i>)</code> [LISP]<dd>Creates
a piece-wise exponential envelope with breakpoints at (0, l1), (<i>t2</i>, <i>l2</i>), etc., ending with (<i>tn, <i>ln</i></i>, where <i>tj</i> is the sum of <i>i2</i> through <i>ij</i>.  In other words, the breakpoint times are specified in terms of intervals rather than cummulative time.   Otherwise, the behavior is like that of <code>pwev</code>.  Note that this is similar to the csound GEN05 generator.  Which is uglier, <i>GEN05</i> or <i>pwevr</i>?<br><br>
<dt><code>pwevr-list(<a name="index408"><i>breakpoints</i>)</code> [SAL]<br>

<code>(pwevr-list <i>breakpoints</i>)</code> [LISP]<dd>A version of <code>pwevr</code> that takes a single list of breakpoints as its argument.  See <code>pwl-list</code> above for the rationale.
</dl>
<a name = "90"><h5>Filter Behaviors</h5></a>
<dl>
<dt>

<code>alpass(<a name="index409"><a name="index410"><a name="index411"><i>sound</i>, <i>decay</i>, <i>hz</i> [, <i>minhz</i>])</code> [SAL]<br>

<code>(alpass <i>sound</i> <i>decay</i> <i>hz</i> [<i>minhz</i>])</code> [LISP]<dd>Applies an all-pass filter to <i>sound</i>.  This all-pass filter creates a delay effect without the resonances of a comb filter. The decay time of the filter is given by <i>decay</i>.  The <i>hz</i> parameter must be a number or sound greater than zero.  It is used to compute delay, which is then rounded to the nearest integer number of samples (so the frequency is not always exact.  Higher sampling rates yield better delay resolution.)  The <i>decay</i> may be a sound or a number.  In either case, it must also be positive.  (Implementation note: an exponentiation is needed to convert <i>decay</i> into the <i>feedback</i> parameter, and exponentiation is typically more time-consuming than the filter operation itself.  To get high performance, provide <i>decay</i> at a low sample rate.)  The resulting sound will have the start time, sample rate, etc. of <i>sound</i>. If <i>hz</i> is of type <code>SOUND</code>, the delay may be time-varying. Linear interpolation is then used for fractional sample delay, but it should be noted that linear interpolation implies a low-pass transfer function. Thus, this filter may behave differently with a constant <code>SOUND</code> than it does with a <code>FLONUM</code> value for <i>hz</i>. In addition, if <i>hz</i> is of type <code>SOUND</code>, then <i>minhz</i> is required. The <i>hz</i> parameter will be clipped to be greater than <i>minhz</i>, placing an upper bound on the delay buffer length.<br><br>
<dt>
<code>comb(<a name="index412"><a name="index413"><i>sound</i>, <i>decay</i>, <i>hz</i>)</code> [SAL]<br>

<code>(comb <i>sound</i> <i>decay</i> <i>hz</i>)</code> [LISP]<dd>Applies a comb filter to <i>sound</i>.  A comb filter emphasizes (resonates at) frequencies that are multiples of a <i>hz</i>. The decay time of the resonance is given by <i>decay</i>.  This is a variation on <code>feedback-delay</code> (see below).  The <i>hz</i> parameter must be a number greater than zero.  It is used to compute delay, which is then rounded to the nearest integer number of samples (so the frequency is not always exact.  Higher sampling rates yield better delay resolution.)  The <i>decay</i> may be a sound or a number.  In either case, it must also be positive.  (Implementation note: an exponentiation is needed to convert <i>decay</i> into the <i>feedback</i> parameter for <code>feedback-delay</code>, and exponentiation is typically more time-consuming than the filter operation itself.  To get high performance, provide <i>decay</i> at a low sample rate.)  The resulting sound will have the start time, sample rate, etc. of <i>sound</i>.<br><br>
<dt>
<code>congen(<a name="index414"><a name="index415"><a name="index416"><i>gate</i>, <i>risetime</i>, <i>falltime</i>)</code> [SAL]<br>

<code>(congen <i>gate</i> <i>risetime</i> <i>falltime</i>)</code> [LISP]<dd>Implements an analog synthesizer-style contour generator. The input <i>gate</i> normally goes from 0.0 to 1.0 to create an attack and from 1.0 to 0.0 to start a release.  During the attack (output is increasing), the output converges half-way to <i>gate</i> in <i>risetime</i> (a <code>FLONUM</code>) seconds. During the decay, the half-time is <i>falltime</i> seconds. The sample rate, start time, logical stop, and terminate time all come from <i>gate</i>. If you want a nice decay, be sure that the <i>gate</i> goes to zero and stays there for awhile before <i>gate</i> terminates, because <code>congen</code> (and all Nyquist sounds) go immediately to zero at termination time.  For example, you can use <code>pwl</code> to build a pulse followed by some zero time:
<pre>
(pwl 0 1 duty 1 duty 0 1)
</pre>

Assuming <i>duty</i> is less than 1.0, this will be a pulse of duration <i>duty</i> followed by zero for a total duration of 1.0.
<pre>
(congen (pwl 0 1 duty 1 duty 0 1) 0.01 0.05)
</pre>

will have a duration of 1.0 because that is the termination time of the <code>pwl</code> input. The decaying release of the resulting envelope will be truncated to zero at time 1.0. (Since the decay is theoretically infinite, there is no way to avoid truncation, although you could multiply by another envelope that smoothly truncates to zero in the last millisecond or two to get both an exponential decay and a smooth final transition to zero.)<br><br>
<dt>
<code>convolve(<a name="index417"><a name="index418"><a name="index419"><i>sound</i>,
<i>response</i>)</code> [SAL]<br>

<code>(convolve <i>sound</i> <i>response</i>)</code> [LISP]<dd>Convolves two signals. The first can be any length, but the
computation time per sample and the total space required are proportional to
the length of <i>response</i>. The start time, logical stop time, and sample 
rate of the output match those of the input <i>sound</i>. The physical stop 
time of the result is the physical stop time of <i>sound</i> plus the duration 
of the <i>response</i> so that the result sound includes the "tail" of the 
filter response. The response is assumed to have the same sample rate as <i>sound</i>. The samples are used as is without resampling.<br><br>
<dt>
<code>feedback-delay(<a name="index420"><a name="index421"><a name="index422"><i>sound</i>, <i>delay</i>, <i>feedback</i>)</code> [SAL]<br>

<code>(feedback-delay <i>sound</i> <i>delay</i> <i>feedback</i>)</code> [LISP]<dd>Applies feedback delay to <i>sound</i>.  The <i>delay</i> must be a number (in seconds).  It is rounded to the nearest sample to determine the length of the delay.  The sample rate is the maximum from <i>sound</i> and <i>feedback</i> (if feedback is also a sound).  The amound of <i>feedback</i> should be less than one to avoid an exponential increase in amplitude.  The start time and stop time, and logical stop time are taken from <i>sound</i>.  Since output is truncated at the stop time of <i>sound</i>, you may want to append some silence to <i>sound</i> to give the filter time to decay.<br><br>
<dt>
<code>lp(<a name="index423"><a name="index424"><i>sound</i>, <i>cutoff</i>)</code> [SAL]<br>

<code>(lp <i>sound</i> <i>cutoff</i>)</code> [LISP]<dd>Filters <i>sound</i>
using a first-order Butterworth low-pass filter.  <i>Cutoff</i> may be a float
or a signal (for time-varying filtering) and expresses hertz.  Filter
coefficients (requiring trig functions) are recomputed at the sample rate of
<i>cutoff</i>.  The resulting sample rate, start time, etc. are taken from <i>sound</i>.<br><br>
<dt><code>tone(<a name="index425"><i>sound</i>, <i>cutoff</i>)</code> [SAL]<br>

<code>(tone <i>sound</i> <i>cutoff</i>)</code> [LISP]<dd>No longer defined; use <code>lp</code> instead, or define it by adding <code>(setfn tone lp)</code> to your program.<br><br>
<dt>
<code>hp(<a name="index426"><a name="index427"><i>sound</i>, <i>cutoff</i>)</code> [SAL]<br>

<code>(hp <i>sound</i> <i>cutoff</i>)</code> [LISP]<dd>Filters <i>sound</i>
using a first-order Butterworth high-pass filter.  <i>Cutoff</i> may be a
float or a signal (for time-varying filtering) and expresses hertz.  Filter
coefficients (requiring trig functions) are recomputed at the sample rate of
<i>cutoff</i>.  This filter is an exact complement of <code>lp</code>.<br><br>
<dt><code>atone(<a name="index428"><i>sound</i>, <i>cutoff</i>)</code> [SAL]<br>

<code>(atone <i>sound</i> <i>cutoff</i>)</code> [LISP]<dd>No longer defined; use <code>hp</code> instead, or define it by adding <code>(setfn atone hp)</code> to your program.<br><br>
<dt>
<code>reson(<a name="index429"><a name="index430"><i>sound</i>, <i>center</i>, <i>bandwidth</i>, <i>n</i>)</code> [SAL]<br>

<code>(reson <i>sound</i> <i>center</i> <i>bandwidth</i> <i>n</i>)</code> [LISP]<dd>Apply
a resonating filter to <i>sound</i> with center frequency <i>center</i> (in hertz),
which may be a float or a signal.  <i>Bandwidth</i> is the filter bandwidth (in
hertz), which may also be a signal.  Filter coefficients (requiring trig
functions) are recomputed at each new sample of either <i>center</i> or
<i>bandwidth</i>, and coefficients are <i>not</i> interpolated.  The last
parameter <i>n</i> specifies the type of normalization as in Csound: A value of 1 specifies a peak amplitude
response of 1.0; all frequencies other than <i>hz</i> are attenuated.  A
value of 2 specifies the overall RMS value of the amplitude response
is 1.0; thus filtered white noise would retain the same power.  A value of
zero specifies no scaling.  The resulting sample rate, start time, etc. are taken from <i>sound</i>.<br><br>
<dt>One application of <code>reson</code> is to simulate resonances in the human vocal tract.
See <code>demos/voice_synthesis.htm</code><a name="index431"><a name="index432">
for sample code and documentation.<br><br>
<dt>
<code>areson(<a name="index433"><a name="index434"><i>sound</i>, <i>center</i>, <i>bandwidth</i>, <i>n</i>)</code> [SAL]<br>

<code>(areson <i>sound</i> <i>center</i> <i>bandwidth</i> <i>n</i>)</code> [LISP]<dd>The <code>areson</code> filter is an exact
complement of <code>reson</code> such that if both are applied to the
same signal with the same parameters, the sum of the results yeilds
the original signal.<br><br>
<dt>
<code>shape(<a name="index435"><a name="index436"><a name="index437"><i>signal</i>, <i>table</i>, <i>origin</i>)</code> [SAL]<br>

<code>(shape <i>signal</i> <i>table</i> <i>origin</i>)</code> [LISP]<dd>A waveshaping function.  Use <i>table</i> as a function; apply the function to each sample of <i>signal</i> to yield a new sound.  <i>Signal</i> should range from -1 to +1.  Anything beyond these bounds is clipped.  <i>Table</i> is also a sound, but it is converted into a lookup table (similar to table-lookup oscillators).  The <i>origin</i> is a <code>FLONUM</code> and gives the time which should be considered the origin of <i>table</i>.  (This is important because <i>table</i> cannot have values at negative times, but <i>signal</i> will often have negative values.  The <i>origin</i> gives an offset so that you can produce suitable tables.)  The output at time <i>t</i> is:
<blockquote>
<i>table</i>(<i>origin</i> + clip(<i>signal</i>(<i>t</i>))<br>

</blockquote>
where clip(<i>x</i>) = <i>max</i>(1, <i>min</i>(-1, <i>x</i>)).
(E.g. if <i>table</i> is a signal defined over the interval [0, 2], then <i>origin</i> should be 1.0.  The value of <i>table</i> at time 1.0 will be output when the input signal is zero.)  The output has the same start time, sample rate, etc. as <i>signal</i>.  The <code>shape</code> function will also accept multichannel <i>signal</i>s and <i>table</i>s.<br><br>
<dt>Further discussion and examples can be found in 
<code>demos/distortion.htm</code><a name="index438"><a name="index439">. 
The <code>shape</code>
function is also used to map frequency to amplitude to achieve a spectral envelope for
Shepard tones in <code>demos/shepard.lsp</code>.<a name="index440"><a name="index441"><br><br>
<dt>
<code>biquad(<a name="index442"><i>signal</i>, <i>b0</i>, <i>b1</i>, <i>b2</i>, <i>a0</i>, <i>a1</i>, <i>a2</i>)</code> [SAL]<br>

<code>(biquad <i>signal</i> <i>b0</i> <i>b1</i> <i>b2</i> <i>a0</i> <i>a1</i> <i>a2</i>)</code> [LISP]<dd>A fixed-parameter biquad filter. All filter coefficients are <code>FLONUM</code>s. See also <code>lowpass2</code>, <code>highpass2</code>, <code>bandpass2</code>, <code>notch2</code>, <code>allpass2</code>, <code>eq-lowshelf</code>, <code>eq-highshelf</code>, <code>eq-band</code>, <code>lowpass4</code>, <code>lowpass6</code>, <code>highpass4</code>, and <code>highpass8</code> in this section for convenient variations based on the same filter. The equations for the filter are: zn = sn + a1 * zn-1 + a2 * zn-2, and yn = zn * b0 + zn-1 * b1 + zn-2 * b2.<br><br>
<dt>
<code>biquad-m(<a name="index443"><i>signal</i>, <i>b0</i>, <i>b1</i>, <i>b2</i>, <i>a0</i>, <i>a1</i>, <i>a2</i>)</code> [SAL]<br>

<code>(biquad-m <i>signal</i> <i>b0</i> <i>b1</i> <i>b2</i> <i>a0</i> <i>a1</i> <i>a2</i>)</code> [LISP]<dd>A fixed-parameter biquad filter with Matlab sign conventions for <i>a0</i>, <i>a1</i>, and <i>a2</i>. All filter coefficients are <code>FLONUM</code>s.<br><br>
<dt>
<code>lowpass2(<a name="index444"><i>signal</i>, <i>hz</i> [, <i>q</i>])</code> [SAL]<br>

<code>(lowpass2 <i>signal</i> <i>hz</i> [<i>q</i>])</code> [LISP]<dd>A fixed-parameter, second-order lowpass filter based on <code>snd-biquad</code>. The cutoff frequency is given by <i>hz</i> (a <code>FLONUM</code>) and an optional Q factor is given by <i>q</i> (a <code>FLONUM</code>).<br><br>
<dt>
<code>highpass2(<a name="index445"><i>signal</i>, <i>hz</i> [, <i>q</i>])</code> [SAL]<br>

<code>(highpass2 <i>signal</i> <i>hz</i> [<i>q</i>])</code> [LISP]<dd>A fixed-parameter, second-order highpass filter based on <code>snd-biquad</code>. The cutoff frequency is given by <i>hz</i> (a <code>FLONUM</code>) and an optional Q factor is given by <i>q</i> (a <code>FLONUM</code>).<br><br>
<dt>
<code>bandpass2(<a name="index446"><i>signal</i>, <i>hz</i> [, <i>q</i>])</code> [SAL]<br>

<code>(bandpass2 <i>signal</i> <i>hz</i> [<i>q</i>])</code> [LISP]<dd>A fixed-parameter, second-order bandpass filter based on <code>snd-biquad</code>. The center frequency is given by <i>hz</i> (a <code>FLONUM</code>) and an optional Q factor is given by <i>q</i> (a <code>FLONUM</code>).<br><br>
<dt>
<code>notch2(<a name="index447"><i>signal</i>, <i>hz</i> [, <i>q</i>])</code> [SAL]<br>

<code>(notch2 <i>signal</i> <i>hz</i> [<i>q</i>])</code> [LISP]<dd>A fixed-parameter, second-order notch filter based on <code>snd-biquad</code>. The center frequency is given by <i>hz</i> (a <code>FLONUM</code>) and an optional Q factor is given by <i>q</i> (a <code>FLONUM</code>).<br><br>
<dt>
<code>allpass2(<a name="index448"><i>signal</i>, <i>hz</i> [, <i>q</i>])</code> [SAL]<br>

<code>(allpass2 <i>signal</i> <i>hz</i> [<i>q</i>])</code> [LISP]<dd>A fixed-parameter, second-order allpass filter based on <code>snd-biquad</code>. The frequency is given by <i>hz</i> (a <code>FLONUM</code>) and an optional Q factor is given by <i>q</i> (a <code>FLONUM</code>).<br><br>
<dt>
<code>eq-lowshelf(<a name="index449"><a name="index450"><i>signal</i>, <i>hz</i>, <i>gain</i> [, <i>slope</i>])</code> [SAL]<br>

<code>(eq-lowshelf <i>signal</i> <i>hz</i> <i>gain</i> [<i>slope</i>])</code> [LISP]<dd>A fixed-parameter, second-order bass shelving equalization (EQ) filter based on <code>snd-biquad</code>. The <i>hz</i> parameter (a <code>FLONUM</code>)is the halfway point in the transition, and <i>gain</i> (a <code>FLONUM</code>) is the bass boost (or cut) in dB. The optional <i>slope</i> (a <code>FLONUM</code>) is 1.0 by default, and response becomes peaky at values greater than 1.0.<br><br>
<dt>
<code>eq-highshelf(<a name="index451"><a name="index452"><i>signal</i>, <i>hz</i>, <i>gain</i> [, <i>slope</i>])</code> [SAL]<br>

<code>(eq-highshelf <i>signal</i> <i>hz</i> <i>gain</i> [<i>slope</i>])</code> [LISP]<dd>A fixed-parameter, second-order treble shelving equalization (EQ) filter based on <code>snd-biquad</code>. The <i>hz</i> parameter (a <code>FLONUM</code>)is the halfway point in the transition, and <i>gain</i> (a <code>FLONUM</code>) is the treble boost (or cut) in dB. The optional <i>slope</i> (a <code>FLONUM</code>) is 1.0 by default, and response becomes peaky at values greater than 1.0.<br><br>
<dt>
<code>eq-band(<a name="index453"><a name="index454"><i>signal</i>, <i>hz</i>, <i>gain</i>, <i>width</i>)</code> [SAL]<br>

<code>(eq-band <i>signal</i> <i>hz</i> <i>gain</i> <i>width</i>)</code> [LISP]<dd>A fixed- or variable-parameter, second-order midrange equalization (EQ) filter based on <code>snd-biquad</code>, <code>snd-eqbandcv</code> and <code>snd-eqbandvvv</code>. The <i>hz</i> parameter (a <code>FLONUM</code>) is the center frequency, <i>gain</i> (a <code>FLONUM</code>) is the boost (or cut) in dB, and <i>width</i> (a <code>FLONUM</code>) is the half-gain width in octaves. Alternatively, <i>hz</i>, <i>gain</i>, and <i>width</i> may be <code>SOUND</code>s, but they must all have the same sample rate, e.g. they should all run at the control rate or at the sample rate.<br><br>
<dt>
<code>lowpass4(<a name="index455"><i>signal</i>, <i>hz</i>)</code> [SAL]<br>

<code>(lowpass4 <i>signal</i> <i>hz</i>)</code> [LISP]<dd>A four-pole Butterworth lowpass filter. The cutoff frequency is <i>hz</i> (a <code>FLONUM</code>).<br><br>
<dt>
<code>lowpass6(<a name="index456"><i>signal</i>, <i>hz</i>)</code> [SAL]<br>

<code>(lowpass6 <i>signal</i> <i>hz</i>)</code> [LISP]<dd>A six-pole Butterworth lowpass filter. The cutoff frequency is <i>hz</i> (a <code>FLONUM</code>).<br><br>
<dt>
<code>lowpass8(<a name="index457"><i>signal</i>, <i>hz</i>)</code> [SAL]<br>

<code>(lowpass8 <i>signal</i> <i>hz</i>)</code> [LISP]<dd>An eight-pole Butterworth lowpass filter. The cutoff frequency is <i>hz</i> (a <code>FLONUM</code>).<br><br>
<dt>
<code>highpass4(<a name="index458"><i>signal</i>, <i>hz</i>)</code> [SAL]<br>

<code>(highpass4 <i>signal</i> <i>hz</i>)</code> [LISP]<dd>A four-pole Butterworth highpass filter. The cutoff frequency is <i>hz</i> (a <code>FLONUM</code>).<br><br>
<dt>
<code>highpass6(<a name="index459"><i>signal</i>, <i>hz</i>)</code> [SAL]<br>

<code>(highpass6 <i>signal</i> <i>hz</i>)</code> [LISP]<dd>A six-pole Butterworth highpass filter. The cutoff frequency is <i>hz</i> (a <code>FLONUM</code>).<br><br>
<dt>
<code>highpass8(<a name="index460"><i>signal</i>, <i>hz</i>)</code> [SAL]<br>

<code>(highpass8 <i>signal</i> <i>hz</i>)</code> [LISP]<dd>An eight-pole Butterworth highpass filter. The cutoff frequency is <i>hz</i> (a <code>FLONUM</code>).<br><br>
<dt>
<code>tapv(<a name="index461"><a name="index462"><a name="index463"><i>sound</i>, <i>offset</i>, 
<i>vardelay</i>, <i>maxdelay</i>)</code> [SAL]<br>

<code>(tapv <i>sound</i> <i>offset</i> <i>vardelay</i> <i>maxdelay</i>)</code> [LISP]<dd>A delay line with a variable position tap. 
Identical to <code>snd-tapv</code>. See it for details (<a href = "#99">"Signal Operations"</a>).<br><br>
<dt></dl><a name = "91"><h5>Effects</h5></a>
<dl>
<dt>

<code>nrev(<a name="index464"><a name="index465"><a name="index466"><a name="index467"><i>sound</i>, <i>decay</i>, <i>mix</i>)</code> [SAL]<br>

<code>(nrev <i>sound</i> <i>decay</i> <i>mix</i>)</code> [LISP]<br><br>
<dt><code>jcrev(<a name="index468"><a name="index469"><a name="index470"><a name="index471"><i>sound</i>, <i>decay</i>, <i>mix</i>)</code> [SAL]<br>

<code>(jcrev <i>sound</i> <i>decay</i> <i>mix</i>)</code> [LISP]<br><br>
<dt><code>prcrev(<a name="index472"><a name="index473"><a name="index474"><a name="index475"><i>sound</i>, <i>decay</i>, <i>mix</i>)</code> [SAL]<br>

<code>(prcrev <i>sound</i> <i>decay</i> <i>mix</i>)</code> [LISP]
These reverbs (<code>nrev</code>, <code>jcrev</code>, and <code>prcrev</code>) are implemented 
in STK (running within Nyquist). <code>nrev</code> derives from Common Music's 
NRev,  which consists of 6 comb filters followed by 3 allpass filters, a
 lowpass filter, and another allpass in series followed by two allpass 
filters in parallel. <code>jcrev</code> is the John Chowning 
reverberator which is based on the use of networks of simple allpass 
and comb delay filters. This reverb implements three series allpass units, 
followed by four parallel comb filters, and two decorrelation delay 
lines in parallel at the output. <code>prcrev</code> is a Perry Cook's 
reverberator which is based on the Chowning/Moorer/Schroeder 
reverberators using networks of simple allpass and comb delay filters. 
This one implements two series allpass units and two parallel comb filters.
The <i>sound</i> input may be single or multi-channel. The <i>decay</i> time is
in seconds, and <i>mix</i> sets the mixture of input sound reverb sound, 
where 0.0 means input only (dry) and 1.0 means reverb only (wet).<br><br>
<dt>
<code>stkchorus(<a name="index476"><a name="index477"><a name="index478"><a name="index479"><i>sound</i>, <i>depth</i>, <i>freq</i>, <i>mix</i> [, <i>delay</i>])</code> [SAL]<br>

<code>(stkchorus <i>sound</i> <i>depth</i> <i>freq</i> <i>mix</i> [<i>delay</i>])</code> [LISP]<dd>Chorus 
implemented in STK. The input <i>sound</i> can be single or multi-channel.
The <code>FLONUM</code> parameters <i>depth</i> and <i>freq</i> set 
the modulation 
depth from 0 to 1 
and modulation frequency (in Hz), and <i>mix</i> sets the mixture
of input sound and chorused sound, where 0.0 means input sound only (dry)
and 1.0 means chorused sound only (wet). The parameter <i>delay</i> is a
 <code>FIXNUM</code> representing the median desired delay length in samples. <br><br>
<dt>
<code>pitshift(<a name="index480"><a name="index481"><a name="index482"><a name="index483"><i>sound</i>, <i>shift</i>, <i>mix</i>)</code> [SAL]<br>

<code>(pitshift <i>sound</i> <i>shift</i> <i>mix</i>)</code> [LISP]<dd>A pitch
 shifter implemented in STK. The input <i>sound</i>, a single-channel
 or multi-channel <code>SOUND</code> is pitch-shifted by <i>shift</i>, 
a <code>FLONUM</code> ratio. A value of 1.0 means no shift.  The parameter <i>mix</i>
 sets the mixture of input and shifted sounds. A value of 0.0 
means input only (dry) 
and a value of 1.0 means shifted sound only (wet).
</dl>
<p>
<a name = "92"><h5>Physical Models</h5></a>
<a name="index484">
<dl>
<dt>

<code>clarinet(<a name="index485"><a name="index486"><i>step</i>, <i>breath-env</i>)</code> [SAL]<br>

<code>(clarinet <i>step</i> <i>breath-env</i>)</code> [LISP]<dd>A 
physical model of a clarinet from STK. The <i>step</i> parameter is a <code>FLONUM</code> 
that controls the tube length, and the <i>breath-env</i> (a <code>SOUND</code>) 
controls the air pressure
and also determines the length of the resulting sound. The <i>breath-env</i> signal
should range from zero to one.<br><br>
<dt><code>clarinet-freq(<a name="index487"><a name="index488"><a name="index489"><i>step</i>, <i>breath-env</i>, <i>freq-env</i>)</code> [SAL]<br>

<code>(clarinet-freq <i>step</i> <i>breath-env</i> <i>freq-env</i>)</code> [LISP]<dd>A variation of <code>clarinet</code>
that includes a variable frequency control, <i>freq-env</i>, which specifies
frequency deviation in Hz. The duration of the resulting sound is the minimum
duration of <i>breath-env</i> and <i>freq-env</i>. These parameters may be of type
<code>FLONUM</code> or <code>SOUND</code>. <code>FLONUM</code>s are coerced into <code>SOUND</code>s
with a nominal duration arbitrarily set to 30.<br><br>
<dt><code>clarinet-all(<a name="index490"><a name="index491"><a name="index492"><i>step</i>, <i>breath-env</i>, <i>freq-env</i>, <i>vibrato-freq</i>, <i>vibrato-gain</i>, 
<i>reed-stiffness</i>, <i>noise</i>)</code> [SAL]<br>

<code>(clarinet-all <i>step</i> <i>breath-env</i> <i>freq-env</i> <i>vibrato-freq</i> <i>vibrato-gain</i> <i>reed-stiffness</i> <i>noise</i>)</code> [LISP]<dd>A variation of <code>clarinet-freq</code>
that includes controls <i>vibrato-freq</i> (a <code>FLONUM</code> for vibrato frequency in Hertz), 
<i>vibrato-gain</i> (a <code>FLONUM</code> for the amount of amplitude vibrato),
<i>reed-stiffness</i> (a <code>FLONUM</code> or <code>SOUND</code> controlling reed stiffness in the clarinet
model), and <i>noise</i> (a <code>FLONUM</code> or <code>SOUND</code> controlling noise amplitude in the input
air pressure). The <i>vibrato-gain</i> is a number from zero to one, where zero
indicates no vibrato, and one indicates a plus/minus 50% change in breath
envelope values. Similarly, the <i>noise</i> parameter ranges from zero to one where 
zero means no noise and one means white noise with a peak amplitude of
plus/minus 40% of the <i>breath-env</i>. The <i>reed-stiffness</i> parameter varies
from zero to one.
The duration of the resulting sound is the minimum duration of
<i>breath-env</i>, <i>freq-env</i>, <i>reed-stiffness</i>, and <i>noise</i>. As with
<code>clarinet-freq</code>, these parameters may be either <code>FLONUM</code>s or 
<code>SOUND</code>s, and <code>FLONUM</code>s are coerced to sounds with a nominal 
duration of 30.<br><br>
<dt>
<code>sax(<a name="index493"><a name="index494"><i>step</i>, <i>breath-env</i>)</code> [SAL]<br>

<code>(sax <i>step</i> <i>breath-env</i>)</code> [LISP]<dd>A 
physical model of a sax from STK. The <i>step</i> parameter is a <code>FLONUM</code> 
that controls the tube length, and the <i>breath-env</i> controls the air pressure
and also determines the length of the resulting sound. The <i>breath-env</i> signal
should range from zero to one.<br><br>
<dt><code>sax-freq(<a name="index495"><a name="index496"><a name="index497"><i>step</i>, <i>breath-env</i>, <i>freq-env</i>)</code> [SAL]<br>

<code>(sax-freq <i>step</i> <i>breath-env</i> <i>freq-env</i>)</code> [LISP]<dd>A variation of <code>sax</code>
that includes a variable frequency control, <i>freq-env</i>, which specifies
frequency deviation in Hz. The duration of the resulting sound is the minimum
duration of <i>breath-env</i> and <i>freq-env</i>. These parameters may be of type
<code>FLONUM</code> or <code>SOUND</code>. <code>FLONUM</code>s are coerced into <code>SOUND</code>s
with a nominal duration arbitrarily set to 30.<br><br>
<dt><code>sax-all(<a name="index498"><a name="index499"><a name="index500"><i>step</i>, <i>breath-env</i>, <i>freq-env</i>, <i>vibrato-freq</i>, <i>vibrato-gain</i>, 
<i>reed-stiffness</i>, <i>noise</i>, <i>blow-pos</i>, <i>reed-table-offset</i>)</code> [SAL]<br>

<code>(sax-all <i>step</i> <i>breath-env</i> <i>freq-env</i> <i>vibrato-freq</i> <i>vibrato-gain</i> <i>reed-stiffness</i> <i>noise</i> <i>blow-pos</i> <i>reed-table-offset</i>)</code> [LISP]<dd>A variation of
 <code>sax-freq</code>
that includes controls <i>vibrato-freq</i> (a <code>FLONUM</code> for vibrato frequency in Hertz), 
<i>vibrato-gain</i> (a <code>FLONUM</code> for the amount of amplitude vibrato),
<i>reed-stiffness</i> (a <code>SOUND</code> controlling reed stiffness in the sax
model), <i>noise</i> (a <code>SOUND</code> controlling noise amplitude in the input
air pressure), <i>blow-pos</i> (a <code>SOUND</code> controlling the point of excitation
of the air column), and <i>reed-table-offset</i> (a <code>SOUND</code> controlling a
parameter of the reed model). The <i>vibrato-gain</i> is a number from zero to one, where zero
indicates no vibrato, and one indicates a plus/minus 50% change in breath
envelope values. Similarly, the <i>noise</i> parameter ranges from zero to one where 
zero means no noise and one means white noise with a peak amplitude of
plus/minus 40% of the <i>breath-env</i>. The <i>reed-stiffness</i>, <i>blow-pos</i>, and
<i>reed-table-offset</i> parameters all vary from zero to one.
The duration of the resulting sound is the minimum duration of
<i>breath-env</i>, <i>freq-env</i>, <i>reed-stiffness</i>, <i>noise</i>, <i>breath-env</i>,
 <i>blow-pos</i>, and <i>reed-table-offset</i>. As with
<code>sax-freq</code>, these parameters may be either <code>FLONUM</code>s or 
<code>SOUND</code>s, and <code>FLONUM</code>s are coerced to sounds with a nominal 
duration of 30.<br><br>
<dt>
<code>flute(<a name="index501"><a name="index502"><i>step</i>, <i>breath-env</i>)</code> [SAL]<br>

<code>(flute <i>step</i> <i>breath-env</i>)</code> [LISP]<dd>A physical model of a flute from STK. 
The <i>step</i> parameter is a <code>FLONUM</code> that controls the tube 
length, and the <i>breath-env</i>
controls the air pressure and also determines the starting time and
length of the resulting sound. The <i>breath-env</i> signal should
 range from zero to one.<br><br>
<dt><code>flute-freq(<a name="index503"><a name="index504"><i>step</i>, <i>breath-env</i>, <i>freq-env</i>)</code> [SAL]<br>

<code>(flute-freq <i>step</i> <i>breath-env</i> <i>freq-env</i>)</code> [LISP]<dd>A variation of <code>flute</code>
 that includes a variable frequency control, <i>freq-env</i>, which
 specifies frequency deviation in Hz. The duration of the 
resulting sound is the minimum duration of <i>breath-env</i> and 
<i>freq-env</i>. These parameters may be of type <code>FLONUM</code> or
 <code>SOUND</code>. <code>FLONUM</code>s are coerced into SOUNDs with a 
nominal duration arbitrary set to 30.<br><br>
<dt><code>flute-all(<a name="index505"><a name="index506"><i>step</i>, <i>breath-env</i>, <i>freq-env</i>, <i>vibrato-freq</i>,
 <i>vibrato-gain</i>, <i>jet-delay</i>, <i>noise</i>)</code> [SAL]<br>

<code>(flute-all <i>step</i> <i>breath-env</i> <i>freq-env</i> <i>vibrato-freq</i> <i>vibrato-gain</i> <i>jet-delay</i> <i>noise</i>)</code> [LISP]<dd>A variation of 
<code>clarinet-freq</code> that includes controls <i>vibrato-freq</i> (a 
<code>FLONUM</code> for vibrato frequency in Hz), <i>vibrato-gain</i> (a
 <code>FLONUM</code> for the amount of amplitude vibrato), <i>jet-delay</i>
 (a <code>FLONUM</code> or <code>SOUND</code> controlling jet delay in the
 flute model), and 
noise (a <code>FLONUM</code> or <code>SOUND</code> controlling noise amplitude
in the input air pressure). The <i>vibrato-gain</i> is a number from zero
 to one where zero means no vibrato, and one indicates a plus/minus 
50% change in breath envelope values. Similarly, the <i>noise</i> parameter
 ranges from zero to one, where zero means no noise and one means white 
noise with a peak amplitude of
 plus/minus 40% of the <i>breath-env</i>. The <i>jet-delay</i> is a ratio
 that controls a delay length from the flute model, and therefore it 
changes the pitch of the resulting sound. A value of 0.5 will maintain 
the pitch indicated by the step parameter. The duration of the 
resulting sound is the minimum duration of <i>breath-env</i>, <i>freq-env</i>, 
<i>jet-delay</i>, and <i>noise</i>. These parameters may be either 
<code>FLONUM</code>s or <code>SOUND</code>s, and <code>FLONUM</code>s are coerced
 to sounds with a nominal duration of 30. 
  

<code>bowed(<a name="index507"><a name="index508"><i>step</i>, <i>bowpress-env</i>)</code> [SAL]<br>

<code>(bowed <i>step</i> <i>bowpress-env</i>)</code> [LISP]<dd>A physical model of a bowed string
 instrument from STK. The <i>step</i> parameter is a <code>FLONUM</code>
 that controls the string length,
 and the <i>bowpress-env</i> controls the bow pressure and also 
determines the duration of the resulting sound. The <i>bowpress-env</i>
 signal should range from zero to one.<br><br>
<dt><code>bowed-freq(<a name="index509"><a name="index510"><i>step</i>, <i>bowpress-env</i>, <i>freq-env</i>)</code> [SAL]<br>

<code>(bowed-freq <i>step</i> <i>bowpress-env</i> <i>freq-env</i>)</code> [LISP]<dd>A variation of <code>bowed</code>
 that includes a variable frequency control, <i>freq-env</i>, which
 specifies frequency deviation in Hz. The duration of the resulting
 sound is the minimum duration of <i>bowpress-env</i> and <i>freq-env</i>. 
These parameters may be of type <code>FLONUM</code> or <code>SOUND</code>. 
<code>FLONUM</code>s are coerced into <code>SOUND</code>s
 with a nominal duration arbitrarily set to 30s.<br><br>
<dt>
<code>mandolin(<a name="index511"><a name="index512"><i>step</i>, <i>dur</i>, &amp;optional <i>detune</i>)</code> [SAL]<br>

<code>(mandolin <i>step</i> <i>dur</i> <i>detune</i>)</code> [LISP]<dd>A physical model of a
 plucked double-string instrument from STK. The <i>step</i> parameter
 is a <code>FLONUM</code> wich specifies the desired pitch, <i>dur</i>
 means the duration of the resulting sound and detune is a 
<code>FLONUM</code> that controls the relative detune of the two strings. 
A value of 1.0 means unison. The default value is 4.0.
Note: <i>body-size</i> (see <code>snd-mandolin</code> does not seem to
 work correctly, so a default value is always used
 by <code>mandolin</code>.<br><br>
<dt>
<code>wg-uniform-bar(<a name="index513"><a name="index514"><i>step</i>, <i>bowpress-env</i>)</code> [SAL]<br>

<code>(wg-uniform-bar <i>step</i> <i>bowpress-env</i>)</code> [LISP]<br><br>
<dt><code>wg-tuned-bar(<a name="index515"><a name="index516"><i>step</i>, <i>bowpress-env</i>)</code> [SAL]<br>

<code>(wg-tuned-bar <i>step</i> <i>bowpress-env</i>)</code> [LISP]<br><br>
<dt><code>wg-glass-harm(<a name="index517"><a name="index518"><i>step</i>, <i>bowpress-env</i>)</code> [SAL]<br>

<code>(wg-glass-harm <i>step</i> <i>bowpress-env</i>)</code> [LISP]<br><br>
<dt><code>wg-tibetan-bowl(<a name="index519"><a name="index520"><i>step</i>, <i>bowpress-env</i>)</code> [SAL]<br>

<code>(wg-tibetan-bowl <i>step</i> <i>bowpress-env</i>)</code> [LISP]<dd>These 
sounds are presets for a Banded Wave Guide Percussion instrument implemented in STK.
The parameter <i>step</i> is a <code>FLONUM</code>
 that controls the resultant pitch, and <i>bowpress-env</i> is a <code>SOUND</code> ranging 
from zero to one that controls a parameter of the model. In addition, 
<i>bowpress-env</i> determines the duration of the resulting sound.
(Note: The <i>bowpress-env</i> does not seems influence the timbral 
quality of the resulting sound).<br><br>
<dt>
<code>modalbar(<a name="index521"><a name="index522"><i>preset</i>, <i>step</i>, <i>dur</i>)</code> [SAL]<br>

<code>(modalbar <i>preset</i> <i>step</i> <i>dur</i>)</code> [LISP]<dd>A physical model of a struck bar
 instrument implemented in STK. The parameter <i>preset</i> is one of the
symbols
<code>MARIMBA</code>, <code>VIBRAPHONE</code>, <code>AGOGO</code>, <code>WOOD1</code>, 
<code>RESO</code>, <code>WOOD2</code>, <code>BEATS</code>, <code>TWO-FIXED</code>, or
<code>CLUMP</code>. The symbol must be quoted, e.g. for SAL syntax use
<code>quote(marimba)</code>, and for Lisp syntax use <code>'marimba</code>.
The parameter <i>step</i> is a <code>FLONUM</code> that 
sets the pitch (in steps), and <i>dur</i> is the duration in seconds.<br><br>
<dt>
<code>sitar(<a name="index523"><a name="index524"><i>step</i>, <i>dur</i>)</code> [SAL]<br>

<code>(sitar <i>step</i> <i>dur</i>)</code> [LISP]<dd>A sitar physical model implemented in STK. 
The parameter <i>step</i> is a <code>FLONUM</code> that sets the pitch,
 and <i>dur</i> is the duration.
</dl>
<p>
<a name = "93"><h5>More Behaviors</h5></a>
<dl>
<dt>

<code>clip(<a name="index525"><a name="index526"><i>sound</i>, <i>peak</i>)</code> [SAL]<br>

<code>(clip <i>sound</i> <i>peak</i>)</code> [LISP]<dd>Hard limit <i>sound</i> 
to the given <i>peak</i>, a positive number. The samples of <i>sound</i> are constrained between an upper value
of <i>peak</i> and a lower value of -<i>peak</i>. If <i>sound</i> is a number, <code>clip</code> will return <i>sound</i> limited by <i>peak</i>.  If <i>sound</i> is a multichannel sound, <code>clip</code> returns a multichannel sound where each channel is clipped.  The result has the type, sample rate, starting time, etc. of <i>sound</i>.<br><br>
<dt>
<code>s-abs(<a name="index527"><a name="index528"><i>sound</i>)</code> [SAL]<br>

<code>(s-abs <i>sound</i>)</code> [LISP]<dd>A generalized absolute value function. If <i>sound</i> is a <code>SOUND</code>, compute the absolute value of each sample. If <i>sound</i> is a number, just compute the absolute value. If <i>sound</i> is a multichannel sound, return a multichannel sound with <code>s-abs</code> applied to each element. The result has the type, sample rate, starting time, etc. of <i>sound</i>.<br><br>
<dt>
<code>s-sqrt(<a name="index529"><a name="index530"><i>sound</i>)</code> [SAL]<br>

<code>(s-sqrt <i>sound</i>)</code> [LISP]<dd>A generalized square root function. If <i>sound</i> is a <code>SOUND</code>, compute the square root of each sample. If <i>sound</i> is a number, just compute the square root. If <i>sound</i> is a multichannel sound, return a multichannel sound with <code>s-sqrt</code> applied to each element. The result has the type, sample rate, starting time, etc. of <i>sound</i>. In taking square roots, if an input sample is less than zero, the corresponding output sample is zero. This is done because the square root of a negative number is undefined.<br><br>
<dt>
<code>s-exp(<a name="index531"><a name="index532"><i>sound</i>)</code> [SAL]<br>

<code>(s-exp <i>sound</i>)</code> [LISP]<dd>A generalized exponential function.  If <i>sound</i> is a <code>SOUND</code>, compute <i>e</i>^(<i>x</i>) for each sample <i>x</i>.  If <i>sound</i> is a number <i>x</i>, just compute <i>e</i>^(<i>x</i>).  If <i>sound</i> is a multichannel sound, return a multichannel sound with <code>s-exp</code> applied to each element.  The result has the type, sample rate, starting time, etc. of <i>sound</i>.<br><br>
<dt>
<code>s-log(<a name="index533"><a name="index534"><a name="index535"><i>sound</i>)</code> [SAL]<br>

<code>(s-log <i>sound</i>)</code> [LISP]<dd>A generalized natural log function.  If <i>sound</i> is a <code>SOUND</code>, compute <i>ln</i>(<i>x</i>) for each sample <i>x</i>.  If <i>sound</i> is a number <i>x</i>, just compute <i>ln</i>(<i>x</i>).  If <i>sound</i> is a multichannel sound, return a multichannel sound with <code>s-log</code> applied to each element.  The result has the type, sample rate, starting time, etc. of <i>sound</i>.  Note that the <i>ln</i> of 0 is undefined (some implementations return negative infinity), so use this function with care.<br><br>
<dt>
<code>s-max(<a name="index536"><a name="index537"><i>sound1</i>, <i>sound2</i>)</code> [SAL]<br>

<code>(s-max <i>sound1</i> <i>sound2</i>)</code> [LISP]<dd>Compute the maximum of two functions, <i>sound1</i> and <i>sound2</i>. This function also accepts numbers and multichannel sounds and returns the corresponding data type. The start time of the result is the maximum of the start times of <i>sound1</i> and <i>sound2</i>. The logical stop time and physical stop time of the result is the minimum of the logical stop and physical stop times respectively of <i>sound1</i> and <i>sound2</i>. Note, therefore, that the result value is zero except within the bounds of <i>both</i> input sounds.<br><br>
<dt><code>s-min(<a name="index538"><a name="index539"><i>sound1</i>, <i>sound2</i>)</code> [SAL]<br>

<code>(s-min <i>sound1</i> <i>sound2</i>)</code> [LISP]<dd>Compute the minimum of two functions, <i>sound1</i> and <i>sound2</i>. This function also accepts numbers and multichannel sounds and returns the corresponding data type. The start time of the result is the maximum of the start times of <i>sound1</i> and <i>sound2</i>. The logical stop time and physical stop time of the result is the minimum of the logical stop and physical stop times respectively of <i>sound1</i> and <i>sound2</i>. Note, therefore, that the result value is zero except within the bounds of <i>both</i> input sounds.<br><br>
<dt><code>osc-note(<a name="index540"><i>pitch</i> [, <i>duration</i>, <i>env</i>, <i>loud</i>, 
<i>table</i>])</code> [SAL]<br>

<code>(osc-note <i>pitch</i> [<i>duration</i> <i>env</i> <i>loud</i> <i>table</i>])</code> [LISP]<dd>Same as <code>osc</code>, but <code>osc-note</code>
multiplies the result by <i>env</i>.  The <i>env</i> may be a sound, 
or a list supplying (<i>t1</i> <i>t2</i> 
<i>t4</i> <i>l1</i> <i>l2</i> <i>l3</i>).  The result has a sample rate of <code>*sound-srate*</code>.<br><br>
<dt>
<code>quantize(<a name="index541"><i>sound</i>, <i>steps</i>)</code> [SAL]<br>

<code>(quantize <i>sound</i> <i>steps</i>)</code> [LISP]<dd>Quantizes <i>sound</i> as follows: <i>sound</i> is multiplied by <i>steps</i> and rounded to the nearest integer. The result is then divided by <i>steps</i>. For example, if <i>steps</i> is 127, then a signal that ranges from -1 to +1 will be quantized to 255 levels (127 less than zero, 127 greater than zero, and zero itself). This would match the quantization Nyquist performs when writing a signal to an 8-bit audio file. The <i>sound</i> may be multi-channel.<br><br>
<dt><code>ramp(<a name="index542">[<i>duration</i>])</code> [SAL]<br>

<code>(ramp [<i>duration</i>])</code> [LISP]<dd>Returns a
linear ramp from 0 to 1
over <i>duration</i> (default is 1).  The function actually reaches 1 at
<i>duration</i>, and therefore has one extra sample, making the total duration
be <i>duration</i> + 1/<code>*Control-srate*</code>.  See Figure <a href = "#93">6</a> for
more detail.  Ramp is unaffected by the <code>sustain</code> transformation.  The
effect of time warping is to warp the starting and ending times only.  The
ramp itself is unwarped (linear).  The sample rate is <code>*control-srate*</code>.<br><br>
<dt>
<code>rms(<a name="index543"><i>sound</i> [, <i>rate</i>, <i>window-size</i>])</code> [SAL]<br>

<code>(rms <i>sound</i> [<i>rate</i> <i>window-size</i>])</code> [LISP]<dd>Computes the RMS of <i>sound</i> using a square window of size <i>window-size</i>. The result has a sample rate of <i>rate</i>. The default value of <i>rate</i> is 100 Hz, and the default window size is 1/rate seconds (converted to samples). The <i>rate</i> is a <code>FLONUM</code> and <i>window-size</i> is a <code>FIXNUM</code>.
</dl>
<p>
<hr>
<blockquote></blockquote>
<img src="fig6.gif"><br><br>

<p>
<b>Figure 6: </b>Ramps generated by <code>pwl</code> and <code>ramp</code> functions.  The
<code>pwl</code> version ramps toward the breakpoint (1, 1), but in order to ramp
back to zero at breakpoint (1, 0), the function never reaches an amplitude
of 1.  If used at the beginning of a <code>seq</code> construct, the next sound
will begin at time 1.  The <code>ramp</code> version actually reaches breakpoint
(1, 1); notice that it is one sample longer than the <code>pwl</code> version.  If
used in a sequence, the next sound after <code>ramp</code> would start at time 1 +
<i>P</i>, where <i>P</i> is the sample period.

<hr>
<p>
<dl>
<dt>

<code>recip(<a name="index544"><a name="index545"><a name="index546"><i>sound</i>)</code> [SAL]<br>

<code>(recip <i>sound</i>)</code> [LISP]<dd>A generalized reciprocal function.  
If <i>sound</i> is a <code>SOUND</code>, compute 1/<i>x</i> for each sample <i>x</i>.  If <i>sound</i> is a number <i>x</i>, just compute 1/<i>x</i>.  If <i>sound</i> is a multichannel sound, return a multichannel sound with <code>recip</code> applied to each element.  The result has the type, sample rate, starting time, etc. of <i>sound</i>.  Note that the reciprocal of 0 is undefined (some implementations return  infinity), so use this function with care on sounds.  Division of sounds is accomplished by multiplying by the reciprocal.  Again, be careful not to divide by zero.<br><br>
<dt><code>s-rest(<a name="index547"><a name="index548">[<i>duration</i>])</code> [SAL]<br>

<code>(s-rest [<i>duration</i>])</code> [LISP]<dd>Create silence (zero samples)
for the given 
<i>duration</i> at the sample rate <code>*sound-srate*</code>.  
Default duration is 1.0 sec, and the sound is transformed in time according
to <code>*warp*</code>.  <b><i>Note:</i></b> <code>rest</code> is a Lisp function that is equivalent to <code>cdr</code>.  Be careful to use <code>s-rest</code> when you need a sound!<br><br>
<dt>
<code>noise(<a name="index549">[<i>duration</i>])</code> [SAL]<br>

<code>(noise <i>duration</i>)</code> [LISP]<dd>Generate noise with the given 
<i>duration</i>.  Duration (default is 1.0) 
is transformed according to <code>*warp*</code>.  The
sample rate is <code>*sound-srate*</code> and the amplitude is +/- <code>*loud*</code>.<br><br>
<dt>
<code>yin(<a name="index550"><a name="index551"><a name="index552"><a name="index553"><a name="index554"><a name="index555"><i>sound</i>, <i>minstep</i>, <i>maxstep</i>, <i>stepsize</i>)</code> [SAL]<br>

<code>(yin <i>sound</i> <i>minstep</i> <i>maxstep</i> <i>stepsize</i>)</code> [LISP]<dd>Fundamental 
frequency estimation (pitch detection. Use the YIN algorithm to estimate
the fundamental frequency of <i>sound</i>, which must be a <code>SOUND</code>. 
The <i>minstep</i>, a <code>FLONUM</code>, is the minimum frequency considered (in steps), 
<i>maxstep</i>, a <code>FLONUM</code>, is the maximum frequency considered (in steps), and 
<i>stepsize</i>, a <code>FIXNUM</code>, is the desired hop size.  The result is 
a "stereo" signal,
i.e. an array of two <code>SOUND</code>s, both at the same sample rate, which is 
approximately the sample rate of <i>sound</i> divided by <i>stepsize</i>. 
The first <code>SOUND</code> consists of frequency estimates (in units of
steps, i.e. middle C = 60). The second sound consists
of values that measure the confidence or reliability of the frequency estimate.
A small value (less than 0.1) indicates fairly high confidence. A larger value
indicates lower confidence. This number can also be thought of as a ratio of 
non-periodic power to periodic power. When the number is low, it means the signal
is highly periodic at that point in time, so the period estimate will be 
reliable.
Hint #1: See 
Alain de Cheveigne and Hideki Kawahara's article "YIN, a Fundamental Frequency
Estimator for Speech and Music" in the Journal of the 
Acoustic Society of America, April 2002 for details on the yin algorithm.  
Hint #2: Typically, the <i>stepsize</i> should be at least the expected number
of samples in one period so that the 
fundamental frequency estimates are calculated at a rate far below
the sample rate of the signal. Frequency does not change rapidly and
the yin algorithm is fairly slow. To optimize speed, 
you may want to use less than 44.1 kHz sample rates for input sounds. Yin
uses interpolation to achieve potentially fractional-sample-accurate estimates, 
so higher sample rates do not necessarily help the algorithm and definitely
slow it down. The computation time is O(<i>n</i>^(2)) per estimate, 
where <i>n</i> is the number
of samples in the longest period considered. Therefore, each increase
of <i>minstep</i> by 12 (an octave) gives you a factor of 4 speedup, and 
each decrease of the sample rate of <i>sound</i> by a factor of
two gives you another factor of 4 speedup. Finally, the number of estimates is
inversely proportional to <i>stepsize</i>.
Hint #3: Use <code>snd-srate</code> (see Section <a href = "#83">"Accessing and Creating Sound"</a>) to get
the exact sample rate of the result, which will be the sample rate of
 <i>sound</i> divided by <i>stepsize</i>. 
E.g. <code>(snd-srate (aref yin-output 0))</code>,
where <code>yin-output</code> is a result returned by <code>yin</code>, will be the 
sample rate of the estimates. <br><br>
<dt></dl><a name = "94"><h3>Transformations</h3></a><a name="index556">

These functions change the environment that is seen by other high-level
functions.  Note that these changes are usually relative to the
current environment.  There are also "absolute" versions of each
transformation function, with the exception of <code>seq</code>,
 <code>seqrep</code>, <code>sim</code>, and <code>simrep</code>.  The
"absolute" versions (starting or ending with "abs") do not look at the
current environment, but rather set an environment variable to a specific value.
In this way, sections of code can be insulated from external
transformations.
<p>
<dl>
<dt>
<code>abs-env(<a name="index557"><i>beh</i>)</code> [SAL]<br>

<code>(abs-env <i>beh</i>)</code> [LISP]<dd>Compute <i>beh</i> in the default environment.  
This is useful for computing waveform tables and signals that are 
"outside" of
time.  For example, <code>(at 10.0 (abs-env (my-beh)))</code> is equivalent to
<code>(abs-env (my-beh))</code> because <code>abs-env</code> forces the default environment. Or in SAL, we would say <code>abs-env(my-beh()) @ 10</code> is equivalent to <code>abs-env(my-beh())</code>.<br><br>
<dt><code>at(<a name="index558"><i>time</i>, <i>beh</i>)</code> [SAL]<br>

<code>(at <i>time</i> <i>beh</i>)</code> [LISP]<dd>Evaluate <i>beh</i> with
<code>*warp*<a name="index559"></code> shifted by <i>time</i>. In SAL, you can use the infix
operator <code>@</code> as in <code><i>beh</i> @ <i>time</i></code>. To discover how the
environment is shifting time, use <code>local-to-global(<i>time</i>)</code>. Most
commonly, you call <code>local-to-global(0)</code> to find when a sound created
in the current environment will start, expressed in absolute (global) terms.  
This can be regarded as the "current time."<br><br>
<dt><code>at-abs(<a name="index560"><i>time</i>, <i>beh</i>)</code> [SAL]<br>

<code>(at-abs <i>time</i> <i>beh</i>)</code> [LISP]<dd>Evaluate <i>beh</i> with
<code>*warp*<a name="index561"></code> shifted so that local time 0 maps to <i>time</i>. In SAL, you can use the infix operator <code>@@</code> as in <code><i>beh</i> @@ <i>time</i></code>.<br><br>
<dt>
<code>continuous-control-warp(<a name="index562"><i>beh</i>)</code> [SAL]<br>

<code>(continuous-control-warp <i>beh</i>)</code> [LISP]<dd>Applies the current warp environment to the signal returned by <i>beh</i>. The result has the default control sample rate <code>*control-srate*</code>. Linear interpolation is currently used. Implementation: <i>beh</i> is first evaluated without any shifting, stretching, or warping. The result is functionally composed with the inverse of the environment's warp function.<br><br>
<dt>
<code>continuous-sound-warp(<a name="index563"><i>beh</i>)</code> [SAL]<br>

<code>(continuous-sound-warp <i>beh</i>)</code> [LISP]<dd>Applies the current warp environment to the signal returned by <i>beh</i>. The result has the default sound sample rate <code>*sound-srate*</code>. Linear interpolation is currently used. See <code>continuous-control-warp</code> for implementation notes.<br><br>
<dt>
<code>control-srate-abs(<a name="index564"><i>srate</i>, 
<i>beh</i>)</code> [SAL]<br>

<code>(control-srate-abs <i>srate</i> <i>beh</i>)</code> [LISP]<dd>Evaluate <i>beh</i> with <code>*control-srate*<a name="index565"></code>
set to sample rate <i>srate</i>.  <b><i>Note:</i></b> there is no "relative" version of 
this function.<br><br>
<dt><code>extract(<a name="index566"><i>start</i>, <i>stop</i>, <i>beh</i>)</code> [SAL]<br>

<code>(extract <i>start</i> <i>stop</i> <i>beh</i>)</code> [LISP]<dd>Returns a sound 
which is the portion of
<i>beh</i> between <i>start</i> and <i>stop</i>.  Note that this is done 
relative to the current <code>*warp*</code>.  The result is shifted
to start according to <code>*warp*</code>, so normally the result will start without a delay of <i>start</i>.<br><br>
<dt><code>extract-abs(<a name="index567"><i>start</i>, <i>stop</i>, <i>beh</i>)</code> [SAL]<br>

<code>(extract-abs <i>start</i> <i>stop</i> <i>beh</i>)</code> [LISP]<dd>Returns a sound which
is the portion of
<i>beh</i> between <i>start</i> and <i>stop</i>, independent of the 
current <code>*warp*</code>.  The result is shifted
to start according to <code>*warp*</code>.<br><br>
<dt><code>loud(<a name="index568"><i>volume</i>, <i>beh</i>)</code> [SAL]<br>

<code>(loud <i>volume</i> <i>beh</i>)</code> [LISP]<dd>Evaluates <i>beh</i> with <code>*loud*</code>
incremented by <i>volume</i>. (Recall that <code>*loud*</code> is in decibels, so increment is the proper operation.)<br><br>
<dt><code>loud-abs(<a name="index569"><i>volume</i>, <i>beh</i>)</code> [SAL]<br>

<code>(loud-abs <i>volume</i> <i>beh</i>)</code> [LISP]<dd>Evaluates <i>beh</i> with <code>*loud*</code>
set to <i>volume</i>.<br><br>
<dt>
<code>sound-srate-abs(<a name="index570"><i>srate</i>, <i>beh</i>)</code> [SAL]<br>

<code>(sound-srate-abs <i>srate</i> <i>beh</i>)</code> [LISP]<dd>Evaluate <i>beh</i> with <code>*sound-srate*<a name="index571"></code> set to sample rate <i>srate</i>.  <b><i>Note:</i></b> there is no "relative" version of this function.  <br><br>
<dt><code>stretch(<a name="index572"><i>factor</i>, <i>beh</i>)</code> [SAL]<br>

<code>(stretch <i>factor</i> <i>beh</i>)</code> [LISP]<dd>Evaluates <i>beh</i> with
<code>*warp*</code> scaled by <i>factor</i>.  The effect is to "stretch" the result
of <i>beh</i> (under the current environment) by <i>factor</i>.  See Chapter
<a href = "part5.html#37">"Continuous Transformations and Time Warps"</a> for more information. Use <code>get-duration(<i>dur</i>)</code> to 
get the nominal actual duration of a behavior that locally has a duration
of <i>dur</i>. Here, "nominal" means what would be expected if the behavior
obeys the shift, stretch, and warp components of the environment. (Any 
behavior is free to deviate from the nominal timing. For example, a percussion
sound might have a fixed duration independent of the stretch factor.) Also,
"actual" means global or absolute time, and "locally" means within the
environment where <code>get-duration</code> is called. <code>get-duration</code> works
by mapping the current time (local time 0) using <code>local-to-global</code> to
obtain an actual start time, and mapping <i>dur</i> to obtain an actual end time.
The difference is returned.<br><br>
<dt><code>stretch-abs(<a name="index573"><i>factor</i>, <i>beh</i>)</code> [SAL]<br>

<code>(stretch-abs <i>factor</i> <i>beh</i>)</code> [LISP]<dd>Evaluates <i>beh</i> with <code>*warp*</code> set to a linear time transformation where each unit of logical time maps to <i>factor</i> units of real time.  The effect is to stretch the nominal behavior of <i>beh</i> (under the default global environment) by <i>factor</i>.  See Chapter <a href = "part5.html#37">"Continuous Transformations and Time Warps"</a> for more information.<br><br>
<dt><code>sustain(<a name="index574"><a name="index575"><a name="index576"><a name="index577"><i>factor</i>, <i>beh</i>)</code> [SAL]<br>

<code>(sustain <i>factor</i> <i>beh</i>)</code> [LISP]<dd>Evaluates <i>beh</i> with <code>*sustain*</code> scaled by <i>factor</i>. The effect is to "stretch" the result of <i>beh</i> (under the current environment) by <i>factor</i>; however, the logical stop times are not stretched. Therefore, the overall duration of a sequence is not changed, and sounds will tend to overlap if <code>*sustain*</code> is greater than one (legato) and be separated by silence if <code>*sustain*</code> is less than one.<br><br>
<dt><code>sustain-abs(<a name="index578"><i>factor</i>, <i>beh</i>)</code> [SAL]<br>

<code>(sustain-abs <i>factor</i> <i>beh</i>)</code> [LISP]<dd>Evaluates <i>beh</i> with <code>*sustain*</code> set to <i>factor</i>. (See <code>sustain</code>, above.)<br><br>
<dt><code>transpose(<a name="index579"><i>amount</i>, <i>beh</i>)</code> [SAL]<br>

<code>(transpose <i>amount</i> <i>beh</i>)</code> [LISP]<dd>Evaluates <i>beh</i> with 
<code>*transpose*</code> shifted by <i>amount</i>.  The effect is relative transposition by <i>amount</i> semitones.<br><br>
<dt><code>transpose-abs(<a name="index580"><i>amount</i>, <i>beh</i>)</code> [SAL]<br>

<code>(transpose-abs <i>amount</i> <i>beh</i>)</code> [LISP]<dd>Evaluates <i>beh</i> with 
<code>*transpose*</code> set to <i>amount</i>.  The effect is the transposition of the nominal pitches in <i>beh</i> (under the default global environment) by <i>amount</i>.<br><br>
<dt><code>warp(<a name="index581"><i>fn</i>, <i>beh</i>)</code> [SAL]<br>

<code>(warp <i>fn</i> <i>beh</i>)</code> [LISP]<dd>Evaluates <i>beh</i> with <code>*warp*</code> modified by <i>fn</i>.  The idea is that <i>beh</i> and <i>fn</i> are written in the same time system, and <i>fn</i> warps that time system to local time.  The current environment already contains a mapping from local time to global (real) time.  The value of <code>*warp*</code> in effect when <i>beh</i> is evaluated is the functional composition of the initial <code>*warp*</code> with <i>fn</i>.<br><br>
<dt><code>warp-abs(<a name="index582"><i>fn</i>, <i>beh</i>)</code> [SAL]<br>

<code>(warp-abs <i>fn</i> <i>beh</i>)</code> [LISP]<dd>Evaluates <i>beh</i> with <code>*warp*</code> set to <i>fn</i>.  In other words, the current <code>*warp*</code> is ignored and not composed with <i>fn</i> to form the new <code>*warp*</code>.
</dl>
<p>
<a name = "95"><h3>Combination and Time Structure</h3></a><a name="index583"><a name="index584">
These behaviors combine component behaviors into structures, including
sequences (melodies), simultaneous sounds (chords), and structures based
on iteration.
<p>
<dl>
<dt>

 <code>seq(<a name="index585"><i>beh1</i> [, <i>beh2</i>, <span style="font-style:normal">...</span>])</code> [SAL]<br>

<code>(seq <i>beh1</i> [<i>beh2</i> <span style="font-style:normal">...</span>])</code> [LISP]<dd>Evaluates the first behavior
<i>beh1</i> according to <code>*time*</code> and each successive behavior at the
<code>logical-stop</code> time of the previous one.  The results are summed to form a
sound whose <code>logical-stop</code> is
the <code>logical-stop</code> of the last behavior in the sequence.  Each behavior
can result in a multichannel sound, in which case, the logical stop time is
considered to be the maximum logical stop time of any channel.  The number
of channels in the result is the number of channels of the first behavior.
If other behaviors return fewer channels, new channels are created containing
constant zero signals until the required number of channels is obtained.  If
other behaviors return a simple sound rather than multichannel sounds, the
sound is automatically assigned to the first channel of a multichannel sound
that is then filled out with zero signals.  If another behavior returns more
channels than the first behavior, the error is reported and the computation
is stopped.  Sample rates are converted up or down to match the sample rate of the first sound in a sequence.<br><br>
<dt><code>seqrep(<a name="index586"><i>var</i>, <i>limit</i>, <i>beh</i>)</code> [SAL]<br>

<code>(seqrep <i>var</i> <i>limit</i> <i>beh</i>)</code> [LISP]<dd>Iteratively 
evaluates <i>beh</i> with the atom
<i>var</i> set with values from 0 to <i>limit</i>-1, inclusive.  These sounds
are placed sequentially in time as if by <code>seq</code>. The symbol <i>var</i> is
a <i>read-only</i> local variable to <i>beh</i>. Assignments are not restricted
or detected, but may cause a run-time error or crash. In LISP, the syntax is
 <code>(seqrep (<i>var</i> <i>limit</i>) <i>beh</i>)</code>.<br><br>
<dt>
<code>sim(<a name="index587">[<i>beh1</i>, <i>beh2</i>, <span style="font-style:normal">...</span>])</code> [SAL]<br>

<code>(sim [<i>beh1</i> <i>beh2</i> <span style="font-style:normal">...</span>])</code> [LISP]<dd>Returns a sound which is the 
sum of the given behaviors evaluated with current value of <code>*warp*</code>.
If behaviors return multiple channel sounds, the corresponding channels are
added.  If the number of channels does not match, the result has the
maximum.  For example, if a two-channel sound [L, R] is added to a four-channel
sound [C1, C2, C3, C4], the result is [L + C1, R + C2, C3, C4].  Arguments to <code>sim</code> may also be numbers.  If all arguments are numbers, <code>sim</code> is equivalent (although slower than) the <code>+</code> function.  If a number is added to a sound, <code>snd-offset</code> is used to add the number to each sample of the sound.  The result of adding a number to two or more sounds with different durations is not defined.  Use <code>const</code> to coerce a number to a sound of a specified duration.  An important limitation of <code>sim</code> is that it cannot handle hundreds of behaviors due to a stack size limitation in XLISP.  To compute hundreds of sounds (e.g. notes) at specified times, see <code>timed-seq</code>, below.
See also <code>sum</code> below.<br><br>
<dt><code>simrep(<a name="index588"><i>var</i>, <i>limit</i>, <i>beh</i>)</code> [SAL]<br>

<code>(simrep <i>var</i> <i>limit</i> <i>beh</i>)</code> [LISP]<dd>Iteratively 
evaluates <i>beh</i> with the atom
<i>var</i> set with values from 0 to <i>limit</i>-1, inclusive.  These sounds
are then placed simultaneously in time as if by <code>sim</code>.
In LISP, the syntax is
 <code>(seqrep (<i>var</i> <i>limit</i>) <i>beh</i>)</code>.<br><br>
<dt>
<code>trigger(<a name="index589"><i>s</i>, <i>beh</i>)</code> [SAL]<br>

<code>(trigger <i>s</i> <i>beh</i>)</code> [LISP]<dd>Returns a sound which is the
sum of instances of the behavior <i>beh</i>. One instance is created each time
<code>SOUND</code> <i>s</i> makes a transition from less than or equal to zero to
greater than zero. (If the first sample of <i>s</i> is greater than zero, an
instance is created immediately.) The sample rate of <i>s</i> and all behaviors
must be the same, and the behaviors must be (monophonic) <code>SOUND</code>s.
This function is particularly designed to allow behaviors to be invoked
in real time by making <i>s</i> a function of a Nyquist slider, which can be
controlled by a graphical interface or by OSC messages. See <code>snd-slider</code>
in Section <a href = "#98">"Creating Sounds"</a>.<br><br>
<dt><code>set-logical-stop(<a name="index590"><i>beh</i>, <i>time</i>)</code> [SAL]<br>

<code>(set-logical-stop <i>beh</i> <i>time</i>)</code> [LISP]<dd>Returns a sound with <i>time</i> as 
the logical stop time.<br><br>
<dt><code>sum(<a name="index591"><a name="index592"><i>a</i> [, <i>b</i>, <span style="font-style:normal">...</span>])</code> [SAL]<br>

<code>(sum <i>a</i> [<i>b</i> <span style="font-style:normal">...</span>])</code> [LISP]<dd>Returns the sum of <i>a</i>, <i>b</i>, ..., allowing mixed addition of sounds, multichannel sounds and numbers.  Identical to <i>sim</i>. In SAL, use the infix "+" operator.<br><br>
<dt><code>mult(<a name="index593"><a name="index594"><a name="index595"><i>a</i> [, <i>b</i>, <span style="font-style:normal">...</span>])</code> [SAL]<br>

<code>(mult <i>a</i> [<i>b</i> <span style="font-style:normal">...</span>])</code> [LISP]<dd>Returns the product of <i>a</i>, <i>b</i>, ..., allowing mixed multiplication of sounds, multichannel sounds and numbers.<br><br>
<dt><code>diff(<a name="index596"><a name="index597"><i>a</i>, <i>b</i>)</code> [SAL]<br>

<code>(diff <i>a</i> <i>b</i>)</code> [LISP]<dd>Returns the difference between <i>a</i> and <i>b</i>. This function is defined as <code>(sum a (prod -1 b))</code>.<br><br>
<dt>
<code>timed-seq(<a name="index598"><a name="index599"><a name="index600"><i>score</i>)</code> [SAL]<br>

<code>(timed-seq <i>score</i>)</code> [LISP]<dd>Computes sounds from a note list or "score." The <i>score</i> 
is of the form: <code>`((<i>time1</i> <i>stretch1</i> <i>beh1</i>) (<i>time2</i> 
<i>stretch2</i> <i>beh2</i>) <span style="font-style:normal">...</span>)</code>, where <i>timeN</i> is the starting time, 
<i>stretchN</i> is the stretch factor, and <i>behN</i> is the behavior. Note 
that <i>score</i> is normally a <i>quoted list</i>! The times must be in 
increasing order, and each <i>behN</i> is evaluated using lisp's <code>eval</code>, 
so the <i>behN</i> behaviors cannot refer to local parameters or local 
variables. The advantage of this form over <code>seq</code> is that the 
behaviors are evaluated one-at-a-time which can take much less stack 
space and overall memory. One special "behavior" expression is
interpreted directly by <code>timed-seq</code>: <code>(SCORE-BEGIN-END)</code> 
is ignored, not evaluated as a function. Normally, this special
behavior is placed at time 0 and has two parameters: the score
start time and the score end time. These are used in Xmusic
functions. If the behavior has a <code>:pitch</code> keyword parameter
which is a list, the list represents a chord, and the expression is 
replaced by a set of behaviors, one for each note in the chord. 
It follows that if <code>:pitch</code> is <code>nil</code>, the behavior 
represents a rest and is ignored.<br><br>
<dt></dl><a name = "96"><h3>Sound File Input and Output</h3></a>
<a name="index601">
<dl>
<dt>

<code>play <a name="index602"><i>sound</i></code> [SAL]<br>

<code>(play <i>sound</i>)</code> [LISP]<dd>Play the sound 
through the DAC.  
Note that <code>play</code> is a command in SAL. In XLISP, it is a function,
so the syntax is <code>(play <i>sound</i>)</code>, and in SAL, you can call the
XLISP function as <code>#play(<i>sound</i>)</code>.
The <code>play</code> command or function 
writes a file and plays it.  The details of this
are system-dependent, but <code>play</code> is defined in the file
<code>system.lsp</code>.  The variable <code>*default-sf-dir*</code><a name="index603"><a name="index604"><a name="index605"><a name="index606">
<a name="index607"> names a directory into which to save a sound file. Be careful not to call <code>play</code> or <code>sound-play</code> within a function and then
invoke that function from another <code>play</code> command.<br><br>
<dt>By default, Nyquist will try to normalize sounds using the method named by 
<code>*autonorm-type*</code>, which is <code>'lookahead</code> by default. 
The <i>lookahead</i> method precomputes and buffers <code>*autonorm-max-samples*</code>
samples, finds the peak value, and normalizes accordingly. The 
<code>'previous</code> method bases the normalization of the current sound on the peak value of the (entire) previous sound. This might be good if you are working with long sounds that start rather softly. See Section <a href = "part6.html#45">"Memory Space and Normalization"</a> for more details.<br><br>
<dt>If you want precise control over output levels, you should turn this feature off by typing (using SAL syntax):
<pre>
autonorm-off()<a name="index608">
</pre>

Reenable the automatic normalization feature by typing:
<pre>
autonorm-on()<a name="index609">
</pre>

Play normally produces real-time output.  The default is to send audio data to the DAC as it is computed in addition to saving samples in a file.  If computation is slower than real-time, output will be choppy, but since the samples end up in a file, you can type <code>(r)</code> to replay the stored sound. Real-time playback can be disabled by (using SAL syntax):
<pre>
sound-off()<a name="index610">
</pre>

and reenabled by:
<pre>
sound-on()<a name="index611">
</pre>

Disabling real-time playback has no effect on <code>(play-file)</code> or <code>(r)</code>.<br><br>
<dt>While sounds are playing, typing control-A<a name="index612"> to Nyquist will push the estimated
elapsed<a name="index613"> audio time onto the head of the list 
stored in <code>*audio-markers*</code>.
<a name="index614"><a name="index615"><a name="index616">
Because samples are computed in blocks and because there is latency 
between sample computation and sample playback, the elapsed time may not
be too accurate, and the computed elapsed time may not advance after all
samples have been computed but the sound is still playing.<br><br>
<dt><code>play-file(<a name="index617"><i>filename</i>)</code> [SAL]<br>

<code>(play-file <i>filename</i>)</code> [LISP]<dd>Play the contents of a sound file named by <i>filename</i>. The <code>s-read</code> function is used to read the file, and unless 
<i>filename</i> specifies an absolute path or starts with ".", it will be read from 
<code>*default-sf-dir*</code>.<br><br>
<dt><code>autonorm-on(<a name="index618">)</code> [SAL]<br>

<code>(autonorm-on)</code> [LISP]<dd>Enable automatic adjustment of a scale factor applied to sounds computed using the <code>play</code> command.<br><br>
<dt><code>autonorm-off(<a name="index619">)</code> [SAL]<br>

<code>(autonorm-off)</code> [LISP]<dd>Disable automatic adjustment of a scale factor applied to sounds computed using the <code>play</code> command.<br><br>
<dt><code>sound-on(<a name="index620">)</code> [SAL]<br>

<code>(sound-on)</code> [LISP]<dd>Enable real-time audio output when sound is computed by the the <code>play</code> command.<br><br>
<dt><code>sound-off(<a name="index621">)</code> [SAL]<br>

<code>(sound-off)</code> [LISP]<dd>Disable real-time audio output when sound is computed by the the <code>play</code> command.<br><br>
<dt>
<code>s-save(<a name="index622"><a name="index623"><a name="index624"><a name="index625"><i>expression</i>, <i>maxlen</i>,
<i>filename</i>, format: <i>format</i>, mode: <i>mode</i>, bits: <i>bits</i>, swap: <i>flag</i>, play: <i>play</i>)</code> [SAL]<br>

<code>(s-save <i>expression</i> <i>maxlen</i> <i>filename</i> :format <i>format</i> :mode <i>mode</i> :bits <i>bits</i> :swap <i>flag</i> :play <i>play</i>)</code> [LISP]<dd>Evaluates the <i>expression</i>, which should result in a sound
or an array of sounds, and writes the result to the given <i>filename</i>.  A
<code>FLONUM</code> is returned giving the maximum absolute value of all samples
written. (This is useful for normalizing sounds and detecting sample
overflow.) If <i>play</i> is not <code>NIL</code>, the sound will be output
through the computer's audio output system. (<i>play:</i> [SAL]
or <i>:play</i> [LISP] is not implemented on all systems; if it is implemented, and <i>filename</i> is <code>NIL</code>, then this will play the file without also writing a file.)
The latency (length of audio buffering) used to play the sound is 0.3s by default, but see <code>snd-set-latency</code>.
If
a multichannel sound (array) is written, the channels are up-sampled to the
highest rate in any channel so that all channels have the same sample rate.
The maximum number of samples written per channel is given by <i>maxlen</i>,
which allows writing the initial part of a very long or infinite sound. A
header is written according to <i>format</i>, samples are encoded according to
<i>mode</i>, using <i>bits</i> bits/sample, and bytes are swapped if <i>flag</i> is not NIL.  Defaults for these are
<code>*default-sf-format*</code>, <code>*default-sf-mode*</code>, and
<code>*default-sf-bits*</code>. The default for <i>flag</i> is NIL.
The <i>bits</i> parameter may be 8, 16, or 32.  The values for the <i>format</i> and <i>mode</i> options are described below:
</dl>
<b>Format</b>
<dl>
<dt>
<code>snd-head-none</code><dd>The format is unknown and should be determined
by reading the file.<br><br>
<dt><code>snd-head-raw</code><dd>A raw format file has no header. <br><br>
<dt><code>snd-head-AIFF</code><dd>AIFF format header.<br><br>
<dt><code>snd-head-IRCAM</code><dd>IRCAM format header.<br><br>
<dt><code>snd-head-NeXT</code><dd>1024-byte NeXT/SUN format header followed by IRCAM
header ala CMIX.  Note that the NeXT/SUN format has a header-length field,
so it really is legal to have a large header, even though the normal minimal
header is only 24 bytes.  The additional space leaves room for maximum
amplitudes, which can be used for normalizing floating-point soundfiles, and
for other data.  Nyquist follows the CMIX convention of placing an IRCAM
format header immediately after the NeXT-style header.<br><br>
<dt><code>snd-head-Wave</code><dd>Microsoft Wave format header.<br><br>
<dt><code>snd-head-flac</code><dd>FLAC lossless compressed audio.<br><br>
<dt><code>snd-head-ogg</code><dd>OGG-VORBIS compressed audio.<br><br>
<dt><code>snd-head-*</code><dd>See sndfnint.lsp in the <code>nyquist/runtime</code> directory
 for more formats. The current list includes
<code>paf</code>, <code>svx</code>, <code>nist</code>, <code>voc</code>, <code>w64</code>, <code>mat4</code>, <code>mat5</code>,
<code>pvf</code>, <code>xi</code>, <code>htk</code>, <code>sds</code>, <code>avr</code>, <code>sd2</code>, and <code>caf</code>.
</dl>
<p>
<b>Mode</b>
<dl>
<dt>
<code>snd-mode-adpcm</code><dd>ADPCM mode (not supported).<br><br>
<dt><code>snd-mode-pcm</code><dd>signed binary PCM mode.<br><br>
<dt><code>snd-mode-ulaw</code><dd>8-bit U-Law mode.<br><br>
<dt><code>snd-mode-alaw</code><dd>8-bit A-Law mode (not supported).<br><br>
<dt><code>snd-mode-float</code><dd>32-bit floating point mode.<br><br>
<dt><code>snd-mode-upcm</code><dd>unsigned binary PCM mode.<br><br>
<dt><code>snd-mode-*</code><dd>See sndfnint.lsp in the <code>nyquist/runtime</code> for more modes. The current list includes 
<code>double</code>, <code>gsm610</code>, <code>dwvw</code>, <code>dpcm</code>, and <code>msadpcm</code>.
</dl>
<p>
The defaults for format, mode, and bits are as follows:
<dl>
<dt>
NeXT and Sun machines:<dd><code>snd-head-NeXT</code>, <code>snd-mode-pcm</code>,
<code>16</code><br><br>
<dt>SGI and Macintosh machines:<dd><code>snd-head-AIFF</code>, <code>snd-mode-pcm</code>, <code>16</code><br><br>
<dt></dl><dl>
<dt>

<code>s-read(<a name="index626"><a name="index627"><i>filename</i>, time-offset: <i>offset</i>, srate: <i>sr</i>, dur: <i>dur</i>, nchans: <i>chans</i>,
 format: <i>format</i>, mode: <i>mode</i>, bits: <i>n</i>, swap: <i>flag</i>)</code> [SAL]<br>

<code>(s-read <i>filename</i> :time-offset <i>offset</i> :srate <i>sr</i>
 :dur <i>dur</i> :nchans <i>chans</i> :format <i>format</i> :mode <i>mode</i> :bits <i>n</i>
 :swap <i>flag</i>)</code> [LISP]<dd>Reads a sound from
 <i>filename</i>. The global <code>*default-sf-dir*</code> applies. If a header is
detected, the header is used to determine the format
of the file, and header information overrides format information provided by
keywords (except for <code>time-offset:</code> and <code>dur:</code>). 
<pre>
s-read("mysound.snd", srate: 44100)
</pre>

specifies a sample rate of 44100 hz, but if the file has a header specifying 22050 hz, the resulting sample rate will be 22050.  The parameters are:
<ul>
<li>
 <i>offset</i> - the amount of time (in seconds) to skip from
the beginning of the file.  The default is 0.0.
<li><i>sr</i> - the sample rate of the samples in the file.  Default is
<code>*default-sf-srate*</code> <a name="index628">, which is normally 44100.
<li> <i>dur</i> - the maximum duration in seconds to read.  Default is
10000.
<li> <i>chans</i> - the number of channels to read.  It is assumed that
samples from each channel are interleaved.  Default is 1.
<li> <i>format</i> - the header format.  See <code>s-save</code> for details.
Default is <code>*default-sf-format*</code>, although this parameter is currently
ignored.
<li> <i>mode</i> - the sample representation, e.g. PCM or float.  See
<code>s-save</code> for details.  Default is <code>*default-sf-format*</code>.
<li> <i>n</i> - the number of bits per sample.  See <code>s-save</code> for
details.  Default is <code>*default-sf-bits*</code>.
<li> <i>flag</i> - (T or NIL) swap byte order of each sample. Default is NIL.
</ul>
If there is an error, for example if <i>offset</i> is greater than the length of the file, then <code>NIL</code> is returned rather than a sound. Information about the sound is also returned by <code>s-read</code> through <code>*rslt*</code> <a href = "foot.html#foot2">(Footnote 2)</a> . The list assigned to <code>*rslt*</code> is of the form: (<i>format</i> <i>channels</i> <i>mode</i> <i>bits</i> <i>samplerate</i> <i>duration</i> <i>flags</i> <i>byte-offset</i>), which are defined as follows:
<ul>
<li>
<i>format</i> - the header format. See <code>s-save</code> for details.
<li><i>channels</i> - the number of channels.
<li><i>mode</i> - the sample representation, e.g. PCM or float. See <code>s-save</code> for details.
<li><i>bits</i> - the number of bits per sample.
<li><i>samplerate</i> - the sample rate, expressed as a <code>FLONUM</code>.
<li><i>duration</i> - the duration of the sound, in seconds.
<li><i>flags</i> - The values for <i>format</i>, <i>channels</i>, <i>mode</i>, <i>bits</i>, <i>samplerate</i>, and <i>duration</i> are initially just the values passed in as parameters or default values to <code>s-read</code>.  If a value is actually read from the sound file header, a flag is set.  The flags are: <code>snd-head-format</code>, <code>snd-head-channels</code>, <code>snd-head-mode</code>, <code>snd-head-bits</code>, <code>snd-head-srate</code>, and <code>snd-head-dur</code>.  For example,
<pre>
(let ((flags (caddr (cddddr  *rslt*))))
  (not (zerop (logand flags snd-head-srate))))
</pre>

tells whether the sample rate was specified in the file. See also <code>sf-info</code> below.
<li><i>byte-offset</i> - the byte offset into the file of the first sample
to be read (this is used by the <code>s-overwrite</code> and <code>s-add-to</code>
functions).
</ul><br><br>
<dt><code>s-add-to(<a name="index629"><a name="index630"><a name="index631"><i>expression</i>, <i>maxlen</i>, 
<i>filename</i> [, <i>offset</i>])</code> [SAL]<br>

<code>(s-add-to <i>expression</i> <i>maxlen</i> <i>filename</i> [<i>offset</i>])</code> [LISP]<dd>Evaluates the <i>expression</i>, which should result in a sound
or an array of sounds, and adds the result to the given <i>filename</i>.  
The global <code>*default-sf-dir*</code> applies. A <code>FLONUM</code> is returned, 
giving the maximum absolute value of all samples written. The
sample rate(s) of <i>expression</i> must match those of the file.
The maximum number of samples written per channel is given by <i>maxlen</i>,
which allows writing the initial part of a very long or infinite sound. 
If <i>offset</i> is specified, the new sound is added to the file beginning at
an <i>offset</i> from the beginning (in seconds).  The file is extended if
necessary to accommodate the new addition, but if <i>offset</i>
falls outside of the original file, the file is not modified. (If necessary,
use <code>s-add-to</code> to extend the file with zeros.) 
The file must be a recognized
sound file with a header (not a raw sound file).<br><br>
<dt><code>s-overwrite(<a name="index632"><a name="index633"><a name="index634"><i>expression</i>, <i>maxlen</i>, <i>filename</i> [, <i>offset</i>])</code> [SAL]<br>

<code>(s-overwrite <i>expression</i> <i>maxlen</i> <i>filename</i> [<i>offset</i>])</code> [LISP]<dd>Evaluates 
the <i>expression</i>, which should result in a sound
or an array of sounds, and replaces samples in the given <i>filename</i>.  
The global <code>*default-sf-dir*</code> applies.
A <code>FLONUM</code> is returned, giving the maximum absolute value of all 
samples written. The
sample rate(s) of <i>expression</i> must match those of the file.
The maximum number of samples written per channel is given by <i>maxlen</i>,
which allows writing the initial part of a very long or infinite sound. 
If <i>offset</i> is specified, the new sound is written to the file beginning at
an <i>offset</i> from the beginning (in seconds). The file is extended if
necessary to accommodate the new insert, but if <i>offset</i> falls outside of
the original file, the file is not modified. (If necessary, use
<code>s-add-to</code> to extend the file with zeros.) The file must be a recognized
sound file with a header (not a raw sound file).<br><br>
<dt><code>sf-info(<a name="index635"><a name="index636"><i>filename</i>)</code> [SAL]<br>

<code>(sf-info <i>filename</i>)</code> [LISP]<dd>Prints information about a sound file. The parameter <i>filename</i> is a string.  The file is assumed to be in *default-sf-dir* (see <code>soundfilename</code> below) unless the filename begins with "." or "/". The source for this function is in the <code>runtime</code> and provides an example of how to determine sound file parameters. <br><br>
<dt><code>soundfilename(<a name="index637"><i>name</i>)</code> [SAL]<br>

<code>(soundfilename <i>name</i>)</code> [LISP]<dd>Converts a string <i>name</i> to a soundfile name.  If <i>name</i> begins with "." or "/", the name is returned without alteration.  Otherwise,  a path taken from <code>*default-sf-dir*</code> is prepended to <i>name</i>.  The <code>s-plot</code>, <code>s-read</code>, and <code>s-save</code> functions all use <code>soundfilename</code> translate filenames.<br><br>
<dt><code>s-plot(<a name="index638"><a name="index639"><i>sound</i> 
 [, <i>dur</i>, <i>n</i>])</code> [SAL]<br>

<code>(s-plot <i>sound</i> 
 [<i>dur</i> <i>n</i>])</code> [LISP]<dd>Plots sound in a window.  This function was designed to run a <code>plot</code> program on a Unix workstation, but now is
primarily used with <code>NyquistIDE</code>, which has self-contained plotting. Normally,
time/value pairs in ascii are written to <code>points.dat</code> and system-dependent code
(or the <code>NyquistIDE</code> program) takes it from there. If the <i>sound</i> is 
longer than the optional <i>dur</i> (default is 2 seconds), only the 
first <i>dur</i> seconds are plotted. 
If there are more than <i>n</i> samples to be plotted, the signal is interpolated
to have <i>n</i> samples before plotting.
The data file used is <code>*default-plot-file*</code>:<br><br>
<dt><code>*default-plot-file*</code><a name="index640"><dd>The file containing the data points, defaults to "points.dat".<br><br>
<dt><code>s-print-tree(<a name="index641"><a name="index642"><i>sound</i>)</code> [SAL]<br>

<code>(s-print-tree <i>sound</i>)</code> [LISP]<dd>Prints an ascii
representation of the internal data structures representing a sound.  This
is useful for debugging<a name="index643"> Nyquist.  Identical to <code>snd-print-tree</code>.<br><br>
<dt></dl><a name = "97"><h3>Low-level Functions</h3></a>
Nyquist includes many low-level functions that are used to implement the functions and behaviors described in previous sections. For completeness, these functions are described here.  Remember that
these are low-level functions that are not intended for normal use.  Unless
you are trying to understand the inner workings of Nyquist, you can skip this section.
<p>
<a name = "98"><h4>Creating Sounds</h4></a>
The basic operations that create sounds are described here.  
<p>
<dl>
<dt><code>snd-const(<a name="index644"><i>value</i>, <i>t0</i>, <i>srate</i>,
<i>duration</i>)</code> [SAL]<br>

<code>(snd-const <i>value</i> <i>t0</i> <i>srate</i> <i>duration</i>)</code> [LISP]<dd>Returns a sound with constant <i>value</i>, starting at <i>t0</i>
with the given <i>duration</i>, at the sample rate <i>srate</i>.  You might want
to use <code>pwl</code> (see Section <a href = "#89">"Piece-wise Approximations"</a>) instead.<br><br>
<dt><code>snd-read(<a name="index645"><i>filename</i>, <i>offset</i>, <i>t0</i>, <i>format</i>,
<i>channels</i>, <i>mode</i>, <i>bits</i>, <i>swap</i>, <i>sr</i>,
<i>dur</i>)</code> [SAL]<br>

<code>(snd-read <i>filename</i> <i>offset</i> <i>t0</i> <i>format</i> <i>channels</i> <i>mode</i> <i>bits</i> <i>swap</i> <i>sr</i> <i>dur</i>)</code> [LISP]<dd>Loads a sound from a file with name <i>filename</i>.  Files are
assumed to consist of a header followed by frames consisting of one sample
from each channel.  The <i>format</i> specifies the type of header, but this
information is currently ignored.  Nyquist looks for a number of header
formats and automatically figures out which format to read.  If a header can
be identified, the header is first read from the file.  Then, the file
pointer is advanced by the indicated
<i>offset</i> (in seconds).  If there is an unrecognized header, Nyquist will
assume the file has no header.  If the header size is a multiple of the
frame size (bytes/sample * number-of-channels), you can use <i>offset</i> to
skip over the header.  To skip N bytes, use an <i>offset</i> of:
<pre>
(/ (float N) <i>sr</i> (/ <i>bits</i> 8) <i>channels</i>)
</pre>

If the header is not a multiple of the frame size, either write a header or
contact the author (dannenberg@cs.cmu.edu) for assistance.  Nyquist will
round <i>offset</i> to the nearest sample.  The resulting sound will start at
time <i>t0</i>.  If a header is found, the file will be interpreted according
to the header information.  If no header was found, <i>channels</i> tells how
many channels there are, the samples are encoded according to <i>mode</i>, the
sample length is <i>bits</i>, and <i>sr</i> is the sample rate.  The <i>swap</i> flag is 0 or 1, where 1 means to swap sample bytes. The duration to
be read (in seconds) is given by <i>dur</i>.  If <i>dur</i> is longer than the
data in the file, then a shorter duration will be returned.  If the file
contains one channel, a sound is returned.  If the file contains 2 or more
channels, an array of sounds is returned.  <b><i>Note:</i></b> you probably want to
call <code>s-read</code> (see Section <a href = "#96">"Sound File Input and Output"</a>) instead of
<code>snd-read</code>.  Also, see Section <a href = "#96">"Sound File Input and Output"</a> for information on the
<i>mode</i> and <i>format</i> parameters.<br><br>
<dt><code>snd-save(<a name="index646"><i>expression</i>, <i>maxlen</i>,
<i>filename</i>, <i>format</i>, <i>mode</i>, <i>bits</i>, <i>swap</i>, <i>play</i>)</code> [SAL]<br>

<code>(snd-save <i>expression</i> <i>maxlen</i> <i>filename</i> <i>format</i> <i>mode</i> <i>bits</i> <i>swap</i> <i>play</i>)</code> [LISP]<dd>Evaluates 
the <i>expression</i>, which should result in a sound
or an array of sounds, and writes the result to the given <i>filename</i>.  If
a multichannel sound (array) is written, the channels are up-sampled to the
highest rate in any channel so that all channels have the same sample rate.
The maximum number of samples written per channel is given by <i>maxlen</i>,
which allows writing the initial part of a very long or infinite sound. A
header is written according to <i>format</i>, samples are encoded according to
<i>mode</i>, using <i>bits</i> bits/sample, and swapping bytes if <i>swap</i> is 1 (otherwise it should be 0).  
If <i>play</i> is not null, the audio is played in real time (to the extent possible) as it is computed. The peak value of the sound is returned. In addition,
the symbol <code>*RSLT*</code> is bound to a list containing the sample rate, 
number of channels, and duration (in that order) of the saved sound.
<b><i>Note:</i></b> you probably want to call
<code>s-save</code> (see Section <a href = "#96">"Sound File Input and Output"</a>) instead.  The <i>format</i> and
<i>mode</i> parameters are described in Section <a href = "#96">"Sound File Input and Output"</a>.<br><br>
<dt><code>snd-overwrite(<a name="index647"><i>expression</i>, <i>maxlen</i>, <i>filename</i>, <i>offset</i>, <i>format</i>, <i>mode</i>, <i>bits</i>, <i>swap</i>)</code> [SAL]<br>

<code>(snd-overwrite <i>expression</i> <i>maxlen</i> <i>filename</i> <i>offset</i> <i>format</i> <i>mode</i> <i>bits</i> <i>swap</i>)</code> [LISP]<dd>Evaluates 
the <i>expression</i>, which should result in a sound
or an array of sounds, and replaces samples in the given <i>filename</i>, 
writing the first frame at a time of <i>offset</i> seconds. The <i>offset</i> must 
be less than or equal to the duration of the existing file. The 
duration of the written samples may
be greater than that of the file, in which case the file is extended 
as necessary. The
sample rate(s) of <i>expression</i> and the number of channels 
must match those of the file. If <i>format</i> is
 <code>SND-HEAD-RAW</code>, then the file
format is given by <i>mode</i> (see 
<code>snd-save</code>, <i>bits</i> (per channel), <i>swap</i> (1 means to 
swap bytes and 0 means write them in the native byte order), and the 
number of channels and sample rate of the sound returned by evaluating
<i>expression</i>. If the 
file is a known
audio file format, <i>format</i> should be <code>SND-HEAD-NONE</code>, and the
other parameters are ignored. Up to a maximum of <i>maxlen</i>
samples will be written per channel. The peak value of the sound is returned.
In addition, the symbol <code>*RSLT*</code> is bound to a list containing the
duration of the written sound (which may not be the duration of the sound
file).
Use <code>s-add-to</code> (in Section <a href = "#96">"Sound File Input and Output"</a> or
<code>s-overwrite</code> (in Section <a href = "#96">"Sound File Input and Output"</a> instead of this function.<br><br>
<dt><code>snd-coterm(<a name="index648"><a name="index649"><a name="index650"><i>s1</i>, <i>s2</i>)</code> [SAL]<br>

<code>(snd-coterm <i>s1</i> <i>s2</i>)</code> [LISP]<dd>Returns a copy of <i>s1</i>, except the start
time is the maximum of the start times of <i>s1</i> and <i>s2</i>, and the
termination time is the minimum of <i>s1</i> and <i>s2</i>. (After the termination
time, the sound is zero as if <i>s1</i> is gated by <i>s2</i>.)  Some rationale
follows: In order to implement <code>s-add-to</code>, we need to read from the
target sound file, add the sounds to a new sound, and overwrite the result
back into the file.  We only want to write as many samples into the file as
there are samples in the new sound. However, if we are adding
in samples read from
the file, the result of a <code>snd-add</code> in Nyquist will have the maximum
duration of either sound.  Therefore, we may read to the end of the file.
What we need is a way to truncate the read, but we cannot easily do that,
because we do not know in advance how long the new sound will be. The
solution is to use <code>snd-coterm</code>, which will allow us to truncate the
sound that is read from the file (<i>s1</i>) according to the duration of the
new sound (<i>s2</i>).  When this truncated sound is added to the new sound,
the result will have only the duration of the new sound, and this can be
used to overwrite the file. This function is used in the implementation of
<code>s-add-to</code>, which is defined in <code>runtime/fileio.lsp</code>.<br><br>
<dt><code>(snd-from-array <span style="font-style:normal">...</span>)</code> [SAL]<br>

<code>(snd-from-array <span style="font-style:normal">...</span>)</code> [LISP]<dd>See <a href = "#83">"Accessing and Creating Sound"</a>.<br><br>
<dt><code>snd-white(<a name="index651"><i>t0</i>, <i>sr</i>, <i>d</i>)</code> [SAL]<br>

<code>(snd-white <i>t0</i> <i>sr</i> <i>d</i>)</code> [LISP]<dd>Generate white noise, starting at
<i>t0</i>, with sample rate <i>sr</i>, and duration <i>d</i>.  You probably want to
use <code>noise</code> (see Section <a href = "#93">"More Behaviors"</a>).<br><br>
<dt> <code>snd-zero(<a name="index652"><i>t0</i>, <i>srate</i>)</code> [SAL]<br>

<code>(snd-zero <i>t0</i> <i>srate</i>)</code> [LISP]<dd>Creates a sound that is
zero everywhere, starts at <i>t0</i>, and has sample rate <i>srate</i>.  The
logical stop time is immediate, i.e. also at <i>t0</i>.  You probably want
to use <code>pwl</code> (see Section <a href = "#89">"Piece-wise Approximations"</a>) instead.<br><br>
<dt> <code>get-slider-value(<a name="index653"><i>index</i>)</code> [SAL]<br>

<code>(get-slider-value <i>index</i>)</code> [LISP]<dd>Return the current value of the slider
named by <i>index</i> (an integer index into the array of sliders). 
Note that this "slider" is just a floating point
value in an array. Sliders can be changed by OSC messages (see <code>osc-enable</code>) and by sending character
sequences to Nyquist's standard input. (Normally, these character sequences would 
not be typed but generated by the NyquistIDE interactive development environment, which
runs Nyquist as a sub-process, and which present the user with graphical sliders.) <br><br>
<dt><code>snd-slider(<a name="index654"><i>index</i>, <i>t0</i>, <i>srate</i>, <i>duration</i>)</code> [SAL]<br>

<code>(snd-slider <i>index</i> <i>t0</i> <i>srate</i> <i>duration</i>)</code> [LISP]<dd>Create
a sound controlled by the slider named by <i>index</i> (an integer 
index into the array of sliders; see <code>get-slider-value</code> for more information). 
The function returns a sound. Since Nyquist sounds are computed in blocks of samples, 
and each block is computed at once, each block will contain copies of the current slider
value. To obtain reasonable responsiveness, slider sounds should have high (audio) 
sample rates so that the block rate will be reasonably high. Also, consider lowering the audio
latency using <code>snd-set-latency</code>. To "trigger" a Nyquist behavior using slider input, see the <code>trigger</code> function in Section <a href = "#95">"Combination and Time Structure"</a>.<br><br>
<dt></dl><a name = "99"><h4>Signal Operations</h4></a>
This next set of functions take sounds as arguments, operate on them, and
return a sound.
<p>
<dl>
<dt>
<code>snd-abs(<a name="index655"><a name="index656"><i>sound</i>)</code> [SAL]<br>

<code>(snd-abs <i>sound</i>)</code> [LISP]<dd>Computes a new 
sound where each sample is the absolute value of the corresponding sample in
<i>sound</i>. You should probably use <code>s-abs</code> instead. (See Section <a href = "#93">"More Behaviors"</a>.)<br><br>
<dt><code>snd-sqrt(<a name="index657"><a name="index658"><i>sound</i>)</code> [SAL]<br>

<code>(snd-sqrt <i>sound</i>)</code> [LISP]<dd>Computes a new 
sound where each sample is the square root of the corresponding sample in
<i>sound</i>. If a sample is negative, it is taken to be zero to avoid raising a floating point error. You should probably use <code>s-sqrt</code> instead. (See Section <a href = "#93">"More Behaviors"</a>.)<br><br>
<dt> <code>snd-add(<a name="index659"><i>sound1</i>, <i>sound</i>)</code> [SAL]<br>

<code>(snd-add <i>sound1</i> <i>sound</i>)</code> [LISP]<dd>Adds two sounds.  The
resulting start time is the minimum of the two parameter start times, the
logical stop time is the maximum of the two parameter stop times, and the
sample rate is the maximum of the two parameter sample rates.  Use
<code>sim</code> or <code>sum</code> instead of <code>snd-add</code> (see Section <a href = "#95">"Combination and Time Structure"</a>).<br><br>
<dt><code>snd-offset(<a name="index660"><a name="index661"><a name="index662"><i>sound</i>, <i>offset</i>)</code> [SAL]<br>

<code>(snd-offset <i>sound</i> <i>offset</i>)</code> [LISP]<dd>Add an offset to a sound. The 
resulting start time, logical stop time, stop time, and sample rate are 
those of <i>sound</i>. Use <code>sum</code> instead (see Section <a href = "#95">"Combination and Time Structure"</a>).<br><br>
<dt><code>snd-avg(<a name="index663"><a name="index664"><a name="index665"><a name="index666"><i>sound</i>, <i>blocksize</i>, <i>stepsize</i>, <i>operation</i>)</code> [SAL]<br>

<code>(snd-avg <i>sound</i> <i>blocksize</i> <i>stepsize</i> <i>operation</i>)</code> [LISP]<dd>Computes the averages 
or peak values of blocks of samples. Each output sample is an average or 
peak of <i>blocksize</i> (a fixnum) adjacent samples from the input <i>sound</i>. 
After each average or peak is taken, the input is advanced by <i>stepsize</i>, 
a fixnum which may be greater or less than <i>blocksize</i>.  The output 
sample rate is the <i>sound</i> (input) sample rate divided by
<i>stepsize</i>. The duration of the output is the same (approximately,
due to rounding) as that of <i>sound</i>. Notice however, that the
features of the input will appear earlier in the output by half the
window size. For example, a sharp peak in the input will result in a
smoothed peak (using <code>OP-AVERAGE</code>) one half <i>blocksize</i>
earlier. You can correct for this shift by inserting one half
<i>blocksize</i> of silence before <i>sound</i>,
e.g. if <code>s</code> has a sample rate of 44100 Hz, then
<code>snd-avg(seq(s-rest(0.01), cue(s)), 882, 441, OP-AVERAGE)</code> will
shift <code>s</code> by 0.01 s to compensate for the shift introduced by a
smoothing window of size 0.02 s (882/44100).
This function is useful for computing low-sample-rate rms or peak 
amplitude signals for input to <code>snd-gate</code> or <code>snd-follow</code>.  
To select the operation, <i>operation</i> should be one of <code>OP-AVERAGE</code> 
or <code>OP-PEAK</code>.  (These are global lisp variables; the actual 
<i>operation</i> parameter is an integer.) For RMS computation, see 
<code>rms</code> in Section <a href = "#93">"More Behaviors"</a>.<br><br>
<dt><code>snd-clip(<a name="index667"><a name="index668"><i>sound</i>, <i>peak</i>)</code> [SAL]<br>

<code>(snd-clip <i>sound</i> <i>peak</i>)</code> [LISP]<dd>Hard limit <i>sound</i> 
to the given <i>peak</i>, a positive number. The samples of <i>sound</i> are constrained between an upper value
of <i>peak</i> and a lower value of -<i>peak</i>. Use <code>clip</code> instead (see Section <a href = "#93">"More Behaviors"</a>).<br><br>
<dt><code>snd-compose(<a name="index669"><a name="index670"><a name="index671"><i>f</i>, <i>g</i>)</code> [SAL]<br>

<code>(snd-compose <i>f</i> <i>g</i>)</code> [LISP]<dd>Compose two signals, i.e.
compute <i>f</i>(<i>g</i>(<i>t</i>)), where <i>f</i> and <i>g</i> are sounds. This function
is used primarily to implement time warping, but it can be used in other
applications such as frequency modulation.  For each sample <i>x</i> in <i>g</i>,
<i>snd-compose</i> looks up the value of <i>f</i>(<i>x</i>) using linear
interpolation.  The resulting sample rate, start time, etc. are taken from
<i>g</i>.  The sound <i>f</i> is used in effect as a lookup table, but it is
assumed that <i>g</i> is non-decreasing, so that <i>f</i> is accessed in time
order.  This allows samples of <i>f</i> to be computed and discarded
incrementally.  If in fact <i>g</i> decreases, the current sample of <i>g</i>  is
replaced by the previous one, forcing <i>g</i> into compliance with the
non-decreasing restriction.  See also <code>sref</code>, <code>shape</code>, and
<code>snd-resample</code>.  <br><br>
<dt>For an extended example that uses <code>snd-compose</code> for variable pitch shifting,
see <code>demos/pitch_change.htm</code>.<a name="index672"><a name="index673">
<a name="index674"><a name="index675"><br><br>
<dt>
<code>snd-tapv(<a name="index676"><a name="index677"><a name="index678"><a name="index679"><a name="index680"><i>sound</i>, <i>offset</i>, <i>vardelay</i>, <i>maxdelay</i>)</code> [SAL]<br>

<code>(snd-tapv <i>sound</i> <i>offset</i> <i>vardelay</i> <i>maxdelay</i>)</code> [LISP]<dd>A 
variable delay: <i>sound</i> is delayed by the sum of <i>offset</i> (a <code>FIXNUM</code> or <code>FLONUM</code>) 
and <i>vardelay</i> (a <code>SOUND</code>).  The specified delay is adjusted to lie in the range 
of zero to <i>maxdelay</i> seconds to yield the actual delay, and the delay is 
implemented using linear interpolation. This function was designed specifically 
for use in a chorus effect: the <i>offset</i> is set to half of <i>maxdelay</i>, and 
the <i>vardelay</i> input is a slow sinusoid. The maximum delay is limited to 
<i>maxdelay</i>, which determines the length of a fixed-sized buffer. The function
<code>tapv</code> is equivalent and preferred (see Section <a href = "#90">"Filter Behaviors"</a>).<br><br>
<dt><code>snd-tapf(<a name="index681"><a name="index682"><a name="index683"><i>sound</i>, <i>offset</i>, <i>vardelay</i>, <i>maxdelay</i>)</code> [SAL]<br>

<code>(snd-tapf <i>sound</i> <i>offset</i> <i>vardelay</i> <i>maxdelay</i>)</code> [LISP]<dd>A
variable delay like <code>snd-tapv</code> except there is no linear interpolation. By 
eliminating interpolation, the output is an exact copy of the input with no filtering
or distortion. On the other hand, delays jump by samples causing samples to double or
skip even when the delay is changed smoothly.<br><br>
<dt><code>snd-copy(<a name="index684"><i>sound</i>)</code> [SAL]<br>

<code>(snd-copy <i>sound</i>)</code> [LISP]<dd>Makes a copy of <i>sound</i>.
Since operators always make (logical) copies of their sound parameters, this
function should never be needed.  This function is here for debugging<a name="index685">.<br><br>
<dt><code>snd-down(<a name="index686"><i>srate</i>, <i>sound</i>)</code> [SAL]<br>

<code>(snd-down <i>srate</i> <i>sound</i>)</code> [LISP]<dd>Linear interpolation
of samples down to the given sample rate <i>srate</i>, which must be lower than
the sample rate of <i>sound</i>.  Do not call this function.  Nyquist performs
sample-rate conversion automatically as needed.  If you want to force a
conversion, call <code>force-srate</code> (see Section <a href = "#87">"Sound Synthesis"</a>).<br><br>
<dt><code>snd-exp(<a name="index687"><i>sound</i>)</code> [SAL]<br>

<code>(snd-exp <i>sound</i>)</code> [LISP]<dd>Compute the exponential of each sample of <i>sound</i>. Use <code>s-exp</code> instead (see Section <a href = "#93">"More Behaviors"</a>).<br><br>
<dt>
<code>snd-follow(<a name="index688"><a name="index689"><a name="index690"><i>sound</i>, <i>floor</i>, <i>risetime</i>, <i>falltime</i>, <i>lookahead</i>)</code> [SAL]<br>

<code>(snd-follow <i>sound</i> <i>floor</i> <i>risetime</i> <i>falltime</i> <i>lookahead</i>)</code> [LISP]<dd>An envelope 
follower. The basic goal of this function is to generate a smooth signal 
that rides on the peaks of the input signal. The usual objective is to 
produce an amplitude envelope given a low-sample rate (control rate) 
signal representing local RMS measurements. The first argument is the 
input signal. The <i>floor</i> is the minimum output value. The <i>risetime</i> is the time (in seconds) it takes for the output to rise (exponentially) from <i>floor</i> to unity (1.0) and the <i>falltime</i> is the time it takes for the output to fall (exponentially) from unity to <i>floor</i>. The algorithm looks ahead for peaks and will begin to increase the output signal according to <i>risetime</i> in anticipation of a peak. The amount of anticipation (in sampless) is given by <i>lookahead</i>.  The algorithm is as follows: the output value is allowed to increase according to <i>risetime</i> or decrease according to <i>falltime</i>. If the next input sample is in this range, that sample is simply output as the next output sample.  If the next input sample is too large, the algorithm goes back in time as far as necessary to compute an envelope that rises according to <i>risetime</i> to meet the new value. The algorithm will only work backward as far as <i>lookahead</i>.  If that is not far enough, then there is a final forward pass computing a rising signal from the earliest output sample. In this case, the output signal will be at least momentarily less than the input signal and will continue to rise exponentially until it intersects the input signal. If the input signal falls faster than indicated by <i>falltime</i>, the output fall rate will be limited by <i>falltime</i>, and the fall in output will stop when the output reaches <i>floor</i>. This algorithm can make two passes througth the buffer on sharply rising inputs, so it is not particularly fast. With short buffers and low sample rates this should not matter. See <code>snd-avg</code> above for a function that can help to generate a low-sample-rate input for <code>snd-follow</code>. See <code>snd-chase</code> in Section <a href = "#100">"Filters"</a> for a related filter.<br><br>
<dt><code>snd-gate(<a name="index691"><a name="index692"><a name="index693"><i>sound</i>, <i>lookahead</i>, <i>risetime</i>, <i>falltime</i>, <i>floor</i>, <i>threshold</i>)</code> [SAL]<br>

<code>(snd-gate <i>sound</i> <i>lookahead</i> <i>risetime</i> <i>falltime</i> <i>floor</i> <i>threshold</i>)</code> [LISP]<dd>This function generates an exponential rise and decay intended for noise gate implementation. The decay starts when the signal drops below threshold and stays there for longer than lookahead. Decay continues until the value reaches floor, at which point the decay stops and the output value is held constant. Either during the decay or after the floor is reached, if the signal goes above threshold, then the output value will rise to unity (1.0) at the point the signal crosses the threshold. Again, look-ahead is used, so the rise actually starts before the signal crosses the threshold. The rise is a constant-rate exponential and set so that a rise from <i>floor</i> to unity occurs in <i>risetime</i>.  Similarly, the fall is a constant-rate exponential such that a fall from unity to <i>floor</i> takes <i>falltime</i>. The result is delayed by <i>lookahead</i>, so the output is not actually synchronized with the input. To compensate, you should drop the initial <i>lookahead</i> of samples. Thus, <code>snd-gate</code> is not recommended for direct use. Use <code>gate</code> instead (see Section <a href = "#84">"Miscellaneous Functions"</a>).<br><br>
<dt><code>snd-inverse(<a name="index694"><a name="index695"><i>signal</i>, <i>start</i>, <i>srate</i>)</code> [SAL]<br>

<code>(snd-inverse <i>signal</i> <i>start</i> <i>srate</i>)</code> [LISP]<dd>Compute the function inverse of <i>signal</i>, that is, compute <i>g</i>(<i>t</i>) such that <i>signal</i>(<i>g</i>(<i>t</i>)) = <i>t</i>.  This function assumes that <i>signal</i> is non-decreasing, it uses linear interpolation, the resulting sample rate is <i>srate</i>, and the result is shifted to have a starting time of <i>start</i>.  If <i>signal</i> decreases, the true inverse may be undefined, so we define <code>snd-inverse</code> operationally as follows: for each output time point <i>t</i>, scan ahead in <i>signal</i> until the value of signal exceeds <i>t</i>.  Interpolate to find an exact time point <i>x</i> from <i>signal</i> and output <i>x</i> at time <i>t</i>.  This function is intended for internal system use in implementing time warps.<br><br>
<dt><code>snd-log(<a name="index696"><i>sound</i>)</code> [SAL]<br>

<code>(snd-log <i>sound</i>)</code> [LISP]<dd>Compute the natural logorithm of each sample of <i>sound</i>. Use <code>s-log</code> instead (see Section <a href = "#93">"More Behaviors"</a>).<br><br>
<dt>
<code>peak(<a name="index697"><a name="index698"><i>expression</i>, <i>maxlen</i>)</code> [SAL]<br>

<code>(peak <i>expression</i> <i>maxlen</i>)</code> [LISP]<dd>Compute the maximum absolute value of the amplitude of a sound.  The sound is created by evaluating <i>expression</i> (as in <code>s-save</code>).  Only the first <i>maxlen</i> samples are evaluated. The <i>expression</i> is automatically quoted (<code>peak</code> is a macro), so do not quote this parameter.  If <i>expression</i> is a variable, then the <i>global binding</i> of that variable will be used.  Also, since the variable retains a reference to the sound, the sound will be evaluated and left in memory.  See Section <a href = "part6.html#45">"Memory Space and Normalization"</a> on <a href = "part6.html#45">"Memory Space and Normalization"</a> for examples.<br><br>
<dt>
<code>snd-max(<a name="index699"><a name="index700"><i>expression</i>, <i>maxlen</i>)</code> [SAL]<br>

<code>(snd-max <i>expression</i> <i>maxlen</i>)</code> [LISP]<dd>Compute the maximum absolute value of the amplitude of a sound.  The sound is created by evaluating <i>expression</i> (as in <code>snd-save</code>), which is therefore normally quoted by the caller.  At most <i>maxlen</i> samples are computed.  The result is the maximum of the absolute values of the samples.  <b><i>Notes:</i></b> It is recommended to use <code>peak</code> (see above) instead.  If you want to find the maximum of a sound bound to a local variable and it is acceptable to save the samples in memory, then this is probably the function to call.  Otherwise, use <code>peak</code>.<br><br>
<dt><code>snd-maxv(<a name="index701"><a name="index702"><i>sound1</i>, <i>sound2</i>)</code> [SAL]<br>

<code>(snd-maxv <i>sound1</i> <i>sound2</i>)</code> [LISP]<dd>Compute the maximum of <i>sound1</i> and <i>sound2</i> on a sample-by-sample basis. The resulting
sound has its start time at the maximum of the input start times and a logical stop
at the minimum logical stop of the inputs. The physical stop time is the minimum of 
the physical stop times of the two sounds. <i>Note that this violates the "normal" 
interpretation that sounds are zero outside their start and stop times. For
example, even if</i> sound1 <i>extends beyond</i> sound2 <i>and is greater than zero,
the result
value in this extension will be zero because it will be after the physical stop time,
whereas if we simply treated</i> sound2 <i>as zero in this region and took the maximum, we
would get a non-zero result.</i> Use <code>s-max</code> instead (see Section <a href = "#93">"More Behaviors"</a>).<br><br>
<dt><code>snd-normalize(<a name="index703"><i>sound</i>)</code> [SAL]<br>

<code>(snd-normalize <i>sound</i>)</code> [LISP]<dd>Internally, sounds
are stored with a scale factor that applies to all samples of the sound.
All operators that take sound arguments take this scale factor into account
(although it is not always necessary to perform an actual multiply per
sample), so you should never need to call this function.  This function
multiplies each sample of a sound by its scale factor, returning a sound
that represents the same signal, but whose scale factor is 1.0.  <br><br>
<dt><code>snd-oneshot(<a name="index704"><a name="index705"><a name="index706"><i>sound</i>, <i>threshold</i>, <i>ontime</i>)</code> [SAL]<br>

<code>(snd-oneshot <i>sound</i> <i>threshold</i> <i>ontime</i>)</code> [LISP]<dd>Computes a new sound that is zero
except where <i>sound</i> exceeds threshold. From these points, the result is 
1.0 until <i>sound</i> remains below <i>threshold</i> for <i>ontime</i> (in seconds).
The result has the same sample rate, start time, logical stop time, and 
duration as <i>sound</i>.<br><br>
<dt><code>snd-prod(<a name="index707"><a name="index708"><a name="index709"><i>sound1</i>, <i>sound2</i>)</code> [SAL]<br>

<code>(snd-prod <i>sound1</i> <i>sound2</i>)</code> [LISP]<dd>Computes the
product of <i>sound1</i> and <i>sound2</i>.  The resulting sound has its start
time at the maximum of the input start times and a logical stop at the minimum
logical stop of the inputs.  Do not use this function.  Use <code>mult</code> or
<code>prod</code> instead (see Section <a href = "#87">"Sound Synthesis"</a>).  Sample rate, start time, etc. are taken from <i>sound</i>.<br><br>
<dt><code>snd-pwl(<a name="index710"><a name="index711"><i>t0</i>, <i>sr</i>,
<i>lis</i>)</code> [SAL]<br>

<code>(snd-pwl <i>t0</i> <i>sr</i> <i>lis</i>)</code> [LISP]<dd>Computes a piece-wise linear function according to the breakpoints
in <i>lis</i>.  The starting time is <i>t0</i>, and the sample rate is <i>sr</i>.
The breakpoints are passed in an XLISP list (of type <code>LVAL</code>) where the
list alternates sample numbers (<code>FIXNUM</code>s, computed in samples 
from the beginning of the pwl function) and values (the value of the pwl
function, given as a <code>FLONUM</code>).  There is an implicit starting
point of (0, 0).  The list must contain an odd number of points, the omitted 
last
value being implicitly zero (0).  The list is assumed to be well-formed.  Do
not call this function.  Use <code>pwl</code> instead (see Section <a href = "#89">"Piece-wise Approximations"</a>).<br><br>
<dt><code>snd-quantize(<a name="index712"><i>sound</i>, <i>steps</i>)</code> [SAL]<br>

<code>(snd-quantize <i>sound</i> <i>steps</i>)</code> [LISP]<dd>Quantizes a sound. See Section
<a href = "#93">"More Behaviors"</a> for details.<br><br>
<dt><code>snd-recip(<a name="index713"><i>sound</i>)</code> [SAL]<br>

<code>(snd-recip <i>sound</i>)</code> [LISP]<dd>Compute the reciprocal of each sample of <i>sound</i>. Use <code>recip</code> instead (see Section <a href = "#93">"More Behaviors"</a>).<br><br>
<dt><code>snd-resample(<a name="index714"><a name="index715"><i>f</i>,
<i>rate</i>)</code> [SAL]<br>

<code>(snd-resample <i>f</i> <i>rate</i>)</code> [LISP]<dd>Resample sound <i>f</i> using high-quality interpolation, yielding
a new sound with the specified <i>rate</i>. The result is scaled by 0.95 because often,
in resampling, interpolated values exceed the original sample values, and this 
could lead to clipping.
The resulting start time, etc. are taken from
<i>f</i>. Use <code>resample</code> instead.<br><br>
<dt><code>snd-resamplev(<a name="index716"><a name="index717"><a name="index718"><i>f</i>, <i>rate</i>, <i>g</i>)</code> [SAL]<br>

<code>(snd-resamplev <i>f</i> <i>rate</i> <i>g</i>)</code> [LISP]<dd>Compose two
signals, i.e.  compute <i>f</i>(<i>g</i>(<i>t</i>)), where <i>f</i> and <i>g</i> are
sounds. The result has sample rate given by <i>rate</i>.  At each time <i>t</i>
(according to the <i>rate</i>), <i>g</i> is linearly interpolated to yield an
increasing sequence of high-precision score-time values. <i>f</i> is then
interpolated at each value to yield a result sample. If in fact <i>g</i>
decreases, the current sample of <i>g</i>  is replaced by the previous one,
forcing <i>g</i> into compliance with the non-decreasing restriction. 
The result is scaled by 0.95 because often,
in resampling, interpolated values exceed the original sample values, and this 
could lead to clipping. Note that
if <i>g</i> has a high sample rate, this may introduce unwanted jitter into
sample times. See <code>sound-warp</code> for a detailed discussion. See
<code>snd-compose</code> for a fast, low-quality alternative to this function.
Normally, you should use <code>sound-warp</code> instead of this function.<br><br>
<dt><code>snd-scale(<a name="index719"><i>scale</i>, <i>sound</i>)</code> [SAL]<br>

<code>(snd-scale <i>scale</i> <i>sound</i>)</code> [LISP]<dd>Scales the amplitude of <i>sound</i> by the factor <i>scale</i>.  Use <code>scale</code> instead (see Section
<a href = "#87">"Sound Synthesis"</a>).<br><br>
<dt><code>snd-shape(<a name="index720"><i>signal</i>, <i>table</i>, <i>origin</i>)</code> [SAL]<br>

<code>(snd-shape <i>signal</i> <i>table</i> <i>origin</i>)</code> [LISP]<dd>A waveshaping function.  This is the primitive upon which <code>shape</code> is based. The <code>snd-shape</code> function is like <code>shape</code> except that <i>signal</i> and <i>table</i> must be (single-channel) sounds.  Use <code>shape</code> instead (see Section <a href = "#90">"Filter Behaviors"</a>).<br><br>
<dt><code>snd-up(<a name="index721"><i>srate</i>, <i>sound</i>)</code> [SAL]<br>

<code>(snd-up <i>srate</i> <i>sound</i>)</code> [LISP]<dd>Increases sample rate by linear
interpolation.  The <i>sound</i> is the signal to be up-sampled, and <i>srate</i>
is the output sample rate.  Do not call this function.  Nyquist performs
sample-rate conversion automatically as needed.  If you want to force a
conversion, call <code>force-srate</code> (see Section <a href = "#87">"Sound Synthesis"</a>).<br><br>
<dt>
<code>snd-xform(<a name="index722"><i>sound</i>, <i>sr</i>, <i>time</i>, <i>start</i>,
<i>stop</i>, <i>scale</i>)</code> [SAL]<br>

<code>(snd-xform <i>sound</i> <i>sr</i> <i>time</i> <i>start</i> <i>stop</i> <i>scale</i>)</code> [LISP]<dd>Makes a copy of <i>sound</i> and then alters it in
the following order:  (1) the start time (<code>snd-t0</code>) of the sound is shifted to 
<i>time</i>, (1) the sound is stretched as a result of setting the sample rate
to <i>sr</i> (the start time is unchanged by this), (3) the sound is clipped
 from <i>start</i> to <i>stop</i>, (4) if <i>start</i> is greater than <i>time</i>, the sound is shifted
shifted by <i>time</i> - <i>start</i>, so that the start time is <i>time</i>, (5) the
sound is scaled by <i>scale</i>.  An empty (zero) sound at <i>time</i> will be
returned if all samples are clipped.  Normally, you should accomplish all
this using transformations.  A transformation applied to a sound has no
effect, so use <code>cue</code> to create a transformable sound (see Section
<a href = "#86">"Using Previously Created Sounds"</a>).<br><br>
<dt>
<code>snd-yin(<a name="index723"><i>sound</i>, <i>minstep</i>, <i>maxstep</i>, <i>rate</i>)</code> [SAL]<br>

<code>(snd-yin <i>sound</i> <i>minstep</i> <i>maxstep</i> <i>rate</i>)</code> [LISP]<dd>Identical to
<code>yin</code>. See Section <a href = "#93">"More Behaviors"</a>.<br><br>
<dt></dl><a name = "100"><h4>Filters</h4></a>
These are also "Signal Operators," the subject of the previous section, 
but there are so many filter functions, they are
documented in this special section.
<p>
Some filters allow time-varying filter parameters.  In these functions,
filter coefficients are calculated at the sample rate of the filter
parameter, and coefficients are not interpolated.
<p>
<dl>
<dt><code>snd-alpass(<a name="index724"><i>sound</i>, <i>delay</i>, <i>feedback</i>)</code> [SAL]<br>

<code>(snd-alpass <i>sound</i> <i>delay</i> <i>feedback</i>)</code> [LISP]<dd>An all-pass filter.  This produces a repeating echo effect without the resonances of <code>snd-delay</code>.  The <i>feedback</i> should be less than one to avoid exponential amplitude blowup.  Delay is rounded to the nearest sample.  You should use <code>alpass</code> instead (see Section <a href = "#90">"Filter Behaviors"</a>).<br><br>
<dt><code>snd-alpasscv(<a name="index725"><i>sound</i>, <i>delay</i>,
<i>feedback</i>)</code> [SAL]<br>

<code>(snd-alpasscv <i>sound</i> <i>delay</i> <i>feedback</i>)</code> [LISP]<dd>An all-pass filter with variable <i>feedback</i>.  
This is just like <i>snd-alpass</i> except <i>feedback</i> is a sound.
You should use <code>alpass</code> instead (see Section <a href = "#90">"Filter Behaviors"</a>).<br><br>
<dt><code>snd-alpassvv(<a name="index726"><i>sound</i>, <i>delay</i>, <i>feedback</i>, <i>maxdelay</i>)</code> [SAL]<br>

<code>(snd-alpassvv <i>sound</i> <i>delay</i> <i>feedback</i> <i>maxdelay</i>)</code> [LISP]<dd>An all-pass filter with variable <i>feedback</i> and <i>delay</i>. This is just like <i>snd-alpass</i> except <i>feedback</i> and <i>delay</i> are sounds, and there is an additional <code>FLONUM</code> parameter, <i>maxdelay</i>, that gives an upper bound on the value of <i>delay</i>. <b><i>Note:</i></b> <i>delay</i> must remain between zero and <i>maxdelay</i>. If not, results are undefined, and Nyquist may crash. You should use <code>alpass</code> instead (see Section <a href = "#90">"Filter Behaviors"</a>).<br><br>
<dt><code>snd-areson(<a name="index727"><i>sound</i>, <i>hz</i>, <i>bw</i>,
<i>normalization</i>)</code> [SAL]<br>

<code>(snd-areson <i>sound</i> <i>hz</i> <i>bw</i> <i>normalization</i>)</code> [LISP]<dd>A notch filter modeled after the <code>areson</code>
unit generator in Csound.  The <code>snd-areson</code> filter is an exact
complement of <code>snd-reson</code> such that if both are applied to the
same signal with the same parameters, the sum of the results yeilds
the original signal.  Note that because of this complementary design,
the power is not normalized as in <code>snd-reson</code>.  See <code>snd-reson</code>
for details on <i>normalization</i>.  You should use <code>areson</code> instead (see
Section <a href = "#90">"Filter Behaviors"</a>).<br><br>
<dt><code>snd-aresoncv(<a name="index728"><i>sound</i>, <i>hz</i>, <i>bw</i>,
<i>normalization</i>)</code> [SAL]<br>

<code>(snd-aresoncv <i>sound</i> <i>hz</i> <i>bw</i> <i>normalization</i>)</code> [LISP]<dd>This function is identical to <code>snd-areson</code> except
the <i>bw</i> (bandwidth) parameter is a sound.  Filter coefficients are
updated at the sample rate of <i>bw</i>.  The "<code>cv</code>" suffix stands for Constant,
Variable, indicating that <i>hz</i> and <i>bw</i> are constant (a number) and
variable (a sound), respectively.  This naming convention is used throughout.
You should use <code>areson</code> instead (see
Section <a href = "#90">"Filter Behaviors"</a>).<br><br>
<dt><code>snd-aresonvc(<a name="index729"><i>sound</i>, <i>hz</i>, <i>bw</i>,
<i>normalization</i>)</code> [SAL]<br>

<code>(snd-aresonvc <i>sound</i> <i>hz</i> <i>bw</i> <i>normalization</i>)</code> [LISP]<dd>This function is identical to <code>snd-areson</code> except
the <i>hz</i> (center frequency) parameter is a sound.  Filter coefficients are
updated at the sample rate of <i>hz</i>.  
You should use <code>areson</code> instead (see
Section <a href = "#90">"Filter Behaviors"</a>).<br><br>
<dt><code>snd-aresonvv(<a name="index730"><i>sound</i>, <i>hz</i>, <i>bw</i>,
<i>normalization</i>)</code> [SAL]<br>

<code>(snd-aresonvv <i>sound</i> <i>hz</i> <i>bw</i> <i>normalization</i>)</code> [LISP]<dd>This function is identical to <code>snd-areson</code> except
both <i>hz</i> (center frequency) and <i>bw</i> (bandwidth) are sounds.  Filter
coefficients are updated at the next sample of either <i>hz</i> or <i>bw</i>.
You should use <code>areson</code> instead (see
Section <a href = "#90">"Filter Behaviors"</a>).<br><br>
<dt><code>snd-atone(<a name="index731"><i>sound</i>, <i>hz</i>)</code> [SAL]<br>

<code>(snd-atone <i>sound</i> <i>hz</i>)</code> [LISP]<dd>A high-pass filter 
modeled after the <code>atone</code> unit generator in Csound.  The <code>snd-atone</code> filter is an exact
complement of <code>snd-tone</code> such that if both are applied to the
same signal with the same parameters, the sum of the results yeilds
the original signal.  You should use <code>hp</code> instead (see
Section <a href = "#90">"Filter Behaviors"</a>).<br><br>
<dt><code>snd-atonev(<a name="index732"><i>sound</i>, <i>hz</i>)</code> [SAL]<br>

<code>(snd-atonev <i>sound</i> <i>hz</i>)</code> [LISP]<dd>This is just like
<code>snd-atone</code> except that the <i>hz</i> cutoff frequency is a sound.  Filter
coefficients are updated at the sample rate of <i>hz</i>.  You should use
<code>hp</code> instead (see Section <a href = "#90">"Filter Behaviors"</a>).<br><br>
<dt><code>snd-biquad(<a name="index733"><i>sound</i>, <i>b0</i>, <i>b1</i>, <i>b2</i>, <i>a1</i>, <i>a2</i>, <i>z1init</i>, <i>z2init</i>)</code> [SAL]<br>

<code>(snd-biquad <i>sound</i> <i>b0</i> <i>b1</i> <i>b2</i> <i>a1</i> <i>a2</i> <i>z1init</i> <i>z2init</i>)</code> [LISP]<dd>A general second order IIR filter, where <i>a0</i> is assumed to be unity. For <i>a1</i> and <i>a2</i>, the sign convention is opposite to that of Matlab. All parameters except the input <i>sound</i> are of type <code>FLONUM</code>. You should probably use one of <code>lowpass2</code>, <code>highpass2</code>, <code>bandpass2</code>, <code>notch2</code>, <code>allpass2</code>, <code>eq-lowshelf</code>, <code>eq-highshelf</code>, <code>eq-band</code>, <code>lowpass4</code>, <code>lowpass6</code>, <code>lowpass8</code>, <code>highpass4</code>, <code>highpass6</code>, or <code>highpass8</code>, which are all based on <code>snd-biquad</code> and described in Section <a href = "#90">"Filter Behaviors"</a>. For completeness, you will also find <code>biquad</code> and <code>biquad-m</code> described in that section.<br><br>
<dt>
<code>snd-chase(<a name="index734"><i>sound</i>, <i>risetime</i>, <i>falltime</i>)</code> [SAL]<br>

<code>(snd-chase <i>sound</i> <i>risetime</i> <i>falltime</i>)</code> [LISP]<dd>A slew rate limiter. The output "chases" the input at rates determined by <i>risetime</i> and <i>falltime</i>.  If the input changes too fast, the output will lag behind the input. This is a form of lowpass filter, but it was created to turn hard-switching square waves into smoother control signals that could be used for linear crossfades. If the input switches from 0 to 1, the output will linearly rise to 1 in <i>risetime</i> seconds. If the input switches from 1 to 0, the output will linearly fall to 0 in <i>falltime</i> seconds.  The generated slope is constant; the transition is linear; this is not an exponential rise or fall.  The <i>risetime</i> and <i>falltime</i> must be scalar constants; complain to the author if this is not adequate. The <code>snd-chase</code> function is safe for ordinary use. See <code>snd-follow</code> in Section <a href = "#99">"Signal Operations"</a> for a related function. <br><br>
<dt><code>snd-congen(<a name="index735"><i>gate</i>, <i>risetime</i>, <i>falltime</i>)</code> [SAL]<br>

<code>(snd-congen <i>gate</i> <i>risetime</i> <i>falltime</i>)</code> [LISP]<dd>A simple "contour generator" based 
on analog synthesizers.  The <i>gate</i> is a sound that normally steps from 0.0 to 1.0 at the start of an envelop and goes from
1.0 back to 0.0 at the beginning of the release. At each sample, the output converges to the input exponentially.  If <i>gate</i> is greater than the output, e.g. the attack, then the output converges half-way to the output in <i>risetime</i>.  If the <i>gate</i> is less than the output, the half-time is <i>falltime</i>.  The sample rate, starting time, logical-stop-time, and terminate time are taken from  <i>gate</i>. You should use <code>congen</code> instead (see Section <a href = "#90">"Filter Behaviors"</a>.<br><br>
<dt><code>snd-convolve(<a name="index736"><i>sound</i>, <i>response</i>)</code> [SAL]<br>

<code>(snd-convolve <i>sound</i> <i>response</i>)</code> [LISP]<dd>Convolves
<i>sound</i> by <i>response</i> using a simple O(N x M) algorithm. The <i>sound</i>
can be any length, but the <i>response</i> is computed and stored in a table. The required compuation time per sample and total space are proportional to the
length of <i>response</i>. Use <code>convolve</code> instead (see Section
<a href = "#90">"Filter Behaviors"</a>).<br><br>
<dt><code>snd-delay(<a name="index737"><i>sound</i>, <i>delay</i>, <i>feedback</i>)</code> [SAL]<br>

<code>(snd-delay <i>sound</i> <i>delay</i> <i>feedback</i>)</code> [LISP]<dd>Feedback
delay.  The output, initially <i>sound</i>, is recursively delayed by <i>delay</i>, scaled by <i>feedback</i>, and added to itself, producing an repeating echo effect.  The <i>feedback</i> should be less than one to avoid exponential amplitude blowup.  Delay is rounded to the nearest sample.  You should use <code>feedback-delay</code> instead (see Section <a href = "#90">"Filter Behaviors"</a>)<br><br>
<dt><code>snd-delaycv(<a name="index738"><i>sound</i>, <i>delay</i>,
<i>feedback</i>)</code> [SAL]<br>

<code>(snd-delaycv <i>sound</i> <i>delay</i> <i>feedback</i>)</code> [LISP]<dd>Feedback delay with variable <i>feedback</i>.  This is just like
<i>snd-delay</i> except <i>feedback</i> is a sound.  You should use
<code>feedback-delay</code> instead (see Section <a href = "#90">"Filter Behaviors"</a>).<br><br>
<dt><code>snd-reson(<a name="index739"><i>sound</i>, <i>hz</i>, <i>bw</i>, <i>normalization</i>)</code> [SAL]<br>

<code>(snd-reson <i>sound</i> <i>hz</i> <i>bw</i> <i>normalization</i>)</code> [LISP]<dd>A
second-order resonating (bandpass) filter with center frequency <i>hz</i> and
bandwidth <i>bw</i>, modeled after the <code>reson</code> unit generator in Csound.  
The <i>normalization</i> parameter must be an integer and (like in Csound)
specifies a scaling factor.  A value of 1 specifies a peak amplitude
response of 1.0; all frequencies other than <i>hz</i> are attenuated.  A
value of 2 specifies the overall RMS value of the amplitude response
is 1.0; thus filtered white noise would retain the same power.  A value of
zero specifies no scaling.  The result sample rate, start time, etc. are takend from <i>sound</i>.
You should use <code>reson</code> instead (see Section
<a href = "#90">"Filter Behaviors"</a>).<br><br>
<dt><code>snd-resoncv(<a name="index740"><i>sound</i>, <i>hz</i>, <i>bw</i>,
<i>normalization</i>)</code> [SAL]<br>

<code>(snd-resoncv <i>sound</i> <i>hz</i> <i>bw</i> <i>normalization</i>)</code> [LISP]<dd>This function is identical to <code>snd-reson</code> except
<i>bw</i> (bandwidth) is a sound.  Filter coefficients are updated at the
sample rate of <i>bw</i>.  You should use <code>reson</code> instead (see Section
<a href = "#90">"Filter Behaviors"</a>).<br><br>
<dt><code>snd-resonvc(<a name="index741"><i>sound</i>, <i>hz</i>, <i>bw</i>,
<i>normalization</i>)</code> [SAL]<br>

<code>(snd-resonvc <i>sound</i> <i>hz</i> <i>bw</i> <i>normalization</i>)</code> [LISP]<dd>This function is identical to <code>snd-reson</code> except
<i>hz</i> (center frequency) is a sound.  Filter coefficients are updated at the
sample rate of <i>hz</i>.  You should use <code>reson</code> instead (see Section
<a href = "#90">"Filter Behaviors"</a>).<br><br>
<dt><code>snd-resonvv(<a name="index742"><i>sound</i>, <i>hz</i>, <i>bw</i>,
<i>normalization</i>)</code> [SAL]<br>

<code>(snd-resonvv <i>sound</i> <i>hz</i> <i>bw</i> <i>normalization</i>)</code> [LISP]<dd>This function is identical to <code>snd-reson</code> except
botth <i>hz</i> (center frequency) and <i>bw</i> (bandwidth) are sounds.  Filter
coefficients are updated at the next sample from either <i>hz</i> or <i>bw</i>.  You should use <code>reson</code> instead (see Section
<a href = "#90">"Filter Behaviors"</a>).<br><br>
<dt><code>snd-stkchorus(<a name="index743"><a name="index744"><a name="index745"><a name="index746"><i>sound</i>, <i>delay</i>, <i>depth</i>, <i>freq</i>, <i>mix</i>)</code> [SAL]<br>

<code>(snd-stkchorus <i>sound</i> <i>delay</i> <i>depth</i> <i>freq</i> <i>mix</i>)</code> [LISP]<dd>A chorus implemented in STK. The parameter <i>delay</i> is a <code>FIXNUM</code> 
representing the median desired delay length in samples. A typical
value is 6000. The <code>FLONUM</code> parameters <i>depth</i> and <i>freq</i> set the modulation
depth (from 0 to 1) and modulation frequency (in Hz), <i>mix</i> sets the mixture
of input sound and chorused sound, where a value of 0.0 means input sound 
only (dry) and a value of 1.0 means chorused sound only (wet). 
You should use <code>pitshift</code> instead
(see Section <a href = "#91">"Effects"</a>).<br><br>
<dt><code>snd-stkpitshift(<a name="index747"><a name="index748"><a name="index749"><a name="index750"><i>sound</i>, <i>shift</i>, <i>mix</i>)</code> [SAL]<br>

<code>(snd-stkpitshift <i>sound</i> <i>shift</i> <i>mix</i>)</code> [LISP]<dd>A 
pitch shifter implemented in STK. The <i>sound</i> is shifted in pitch by
<i>shift</i>, a <code>FLONUM</code> representing the shift factor. A value of 1.0 means
 no shift.  The parameter <i>mix</i> sets the mixture of input and shifted sounds.
A value of 0.0 means input only (dry) and a value of 1.0 means shifted 
sound only (wet). You should use <code>pitshift</code> instead
(see Section <a href = "#91">"Effects"</a>).<br><br>
<dt><code>snd-stkrev(<a name="index751"><a name="index752"><a name="index753"><a name="index754"><i>rev-type</i>, <i>sound</i>, <i>decay</i>, <i>mix</i>)</code> [SAL]<br>

<code>(snd-stkrev <i>rev-type</i> <i>sound</i> <i>decay</i> <i>mix</i>)</code> [LISP]<dd>A reverb implemented in STK. The parameter rev-type is a 
 <code>FIXNUM</code> ranging from zero to 
two and selects the type of reverb. Zero selects NRev type, one selects JCRev, 
and two selects PRCRev. The input <i>sound</i> is processed by the reverb with
a <i>decay</i> time in seconds (a <code>FLONUM</code>). The <i>mix</i>, a <code>FLONUM</code>, 
sets the 
mixture of dry input and reverb output. A value of 0.0 means input only (dry)
and a value of 1.0 means reverb only (wet). The sample rate 
is that of <i>sound</i>. You
should use <code>nrev</code>, <code>jcrev</code> or <code>prcrev</code> instead (see 
Section <a href = "#91">"Effects"</a>).<br><br>
<dt><code>snd-tone(<a name="index755"><a name="index756"><i>sound</i>, <i>hz</i>)</code> [SAL]<br>

<code>(snd-tone <i>sound</i> <i>hz</i>)</code> [LISP]<dd>A
first-order recursive low-pass filter, based on the <i>tone</i> unit generator
of Csound.  The <i>hz</i> parameter is the cutoff frequency, the response
curve's half-power point.  The result sample rate, start time, etc. are takend from <i>sound</i>.
You should use <code>lp</code> instead (see Section
<a href = "#90">"Filter Behaviors"</a>).<br><br>
<dt><code>snd-tonev(<a name="index757"><i>sound</i>, <i>hz</i>)</code> [SAL]<br>

<code>(snd-tonev <i>sound</i> <i>hz</i>)</code> [LISP]<dd>This function is
identical to <code>snd-tone</code> except <i>hz</i> (cutoff frequency) is a sound.
The filter coefficients are updated at the sample rate of <i>hz</i>.  You
should use <code>lp</code> instead (see Section
<a href = "#90">"Filter Behaviors"</a>).<br><br>
<dt></dl><a name = "101"><h4>Table-Lookup Oscillator Functions</h4></a>
These functions all use a sound to describe one period of a periodic
waveform.  In the current implementation, the sound samples are copied to an
array (the waveform table) when the function is called.  To make a
table-lookup oscillator generate a specific pitch, we need to have several
pieces  of information:
<ul>
<li>
A waveform to put into the table.  This comes from the <i>sound</i> parameter.
<li>The length (in samples) of the waveform.  This is obtained by reading
samples (starting at the sound's start time, not necessarily at time zero)
until the physical stop time of the sound.  (If you read the waveform from a
file or generate it with functions like <code>sim</code> and <code>sine</code>, then the
physical and logical stop times will be the same and will correspond to the
duration you specified, rounded to the nearest sample.)  
<li>The intrinsic sample rate of the waveform.  This sample rate is simply the
sample rate property of <i>sound</i>.
<li>The pitch of the waveform.  This is supplied by the <i>step</i> parameter and
indicates the pitch (in steps) of <i>sound</i>.  You might expect that the
pitch would be related to the period (length) of <i>sound</i>, but there is the
interesting case that synthesis based on sampling often loops over multiple
periods.  This means that the fundamental frequency of a generated tone may
be some multiple of the looping rate.  In Nyquist, you always specify the
perceived pitch of the looped <i>sound</i> if the sound is played at the
<i>sound</i>'s own sample rate.
<li>The desired pitch.  This is specified by the <i>hz</i> parameter
in Hertz (cycles per second) in these low-level functions.  Note that this
is not necessarily the "loop" rate at which the table is scanned.
Instead, Nyquist figures what sample rate conversion would be necessary to
"transpose" from the <i>step</i> which specifies the original pitch of
<i>sound</i> to <i>hz</i>, which gives the desired pitch.  The mixed use of steps
and Hertz came about because it seemed that sample tables would be tagged
with steps ("I sampled a middle-C"), whereas frequency deviation in the
<code>fmosc</code> function is linear, thus calling for a specification in Hertz.
<li>The desired sample rate.  This is given by the <i>sr</i> parameter in Hertz.
</ul>
<p>
Other parameters common to all of these oscillator functions are:
<ul>
<li>
<i>t0</i>, the starting time, and
<li><i>phase</i>, the starting phase in degrees.  Note that if the <i>step</i>
parameter indicates that the table holds more than one fundamental period, then a starting phase of 360 will be different than a starting phase of 0.
</ul>
<p>
<dl>
<dt>
 <code>snd-amosc(<a name="index758"><i>sound</i>, <i>step</i>, <i>sr</i>, <i>hz</i>, <i>t0</i>,
<i>am</i>, <i>phase</i>)</code> [SAL]<br>

<code>(snd-amosc <i>sound</i> <i>step</i> <i>sr</i> <i>hz</i> <i>t0</i> <i>am</i> <i>phase</i>)</code> [LISP]<dd>An oscillator with amplitude modulation.  The sound
<i>am</i> specifies the amplitude and the logical stop time.  The physical stop
time is also that of <i>am</i>.  You should use <code>amosc</code> instead (see
Section <a href = "#88">"Oscillators"</a>).<br><br>
<dt><code>snd-fmosc(<a name="index759"><i>s</i>, <i>step</i>, <i>sr</i>, <i>hz</i>, <i>t0</i>, <i>fm</i>,
<i>phase</i>)</code> [SAL]<br>

<code>(snd-fmosc <i>s</i> <i>step</i> <i>sr</i> <i>hz</i> <i>t0</i> <i>fm</i> <i>phase</i>)</code> [LISP]<dd>A Frequency Modulation oscillator.  The sound <i>fm</i> specifies
frequency deviation (in Hertz) from <i>hz</i>.  You should use <code>fmosc</code>
instead (see Section <a href = "#88">"Oscillators"</a>).<br><br>
<dt><code>snd-fmfb(<a name="index760"><i>t0</i>, <i>hz</i>, <i>sr</i>, <i>index</i>, <i>dur</i>)</code> [SAL]<br>

<code>(snd-fmfb <i>t0</i> <i>hz</i> <i>sr</i> <i>index</i> <i>dur</i>)</code> [LISP]<dd>A Feedback FM oscillator. The resulting sound starts
at <i>t0</i>, has a fundamental frequency of <i>hz</i>, a sample rate of <i>sr</i>,
and a duration of <i>dur</i> seconds. The <i>index</i> is a <code>FLONUM</code> that
specifies the amount of feedback. You should use <code>fmfb</code> instead (see
Section <a href = "#88">"Oscillators"</a>).<br><br>
<dt><code>snd-fmfbv(<a name="index761"><i>t0</i>, <i>hz</i>, <i>sr</i>, <i>index</i>)</code><br>

<code>(snd-fmfv <i>t0</i> <i>hz</i> <i>sr</i> <i>index</i>)</code> [LISP]<dd>A
 Feedback FM oscillator. The resulting sound starts
at <i>t0</i>, has a fundamental frequency of <i>hz</i>, and
a sample rate of <i>sr</i>. The <i>index</i> is a <code>SOUND</code> that
specifies the amount of feedback and determines the duration. 
You should use <code>fmfb</code> instead (see Section <a href = "#88">"Oscillators"</a>).<br><br>
<dt><code>snd-buzz(<a name="index762"><i>n</i>, <i>sr</i>, <i>hz</i>, <i>t0</i>, <i>fm</i>)</code> [SAL]<br>

<code>(snd-buzz <i>n</i> <i>sr</i> <i>hz</i> <i>t0</i> <i>fm</i>)</code> [LISP]<dd>A
buzz oscillator, which generates <i>n</i> harmonics of equal amplitude.
The <i>fm</i> specifies
frequency deviation (in Hertz) from <i>hz</i>.  You should use <code>buzz</code>
instead (see Section <a href = "#88">"Oscillators"</a>).<br><br>
<dt><code>snd-pluck(<a name="index763"><i>sr</i>, <i>hz</i>, <i>t0</i>, <i>d</i>,
 <i>final-amp</i>)</code> [SAL]<br>

<code>(snd-pluck <i>sr</i> <i>hz</i> <i>t0</i> <i>d</i> <i>final-amp</i>)</code> [LISP]<dd>A Karplus-Strong plucked string oscillator with sample rate
<i>sr</i>, fundamental frequency <i>hz</i>, starting time <i>t0</i>, duration <i>d</i>,
initial amplitude approximately 1.0 (not exact because the string is
initialized with random values) and final amplitude approximately 
<i>final-amp</i>. You should use <code>pluck</code> instead (see Section
 <a href = "#88">"Oscillators"</a>).<br><br>
<dt><code>snd-osc(<a name="index764"><i>s</i>, <i>step</i>, <i>sr</i>, <i>hz</i>, <i>t0</i>, <i>d</i>, <i>phase</i>)</code> [SAL]<br>

<code>(snd-osc <i>s</i> <i>step</i> <i>sr</i> <i>hz</i> <i>t0</i> <i>d</i> <i>phase</i>)</code> [LISP]<dd>A simple table lookup oscillator with fixed frequency.  The duration
is <i>d</i> seconds.  You should use <code>osc</code> instead (see Section
<a href = "#88">"Oscillators"</a>).<br><br>
<dt><code>snd-partial(<a name="index765"><i>sr</i>, <i>hz</i>, <i>t0</i>, <i>env</i>)</code> [SAL]<br>

<code>(snd-partial <i>sr</i> <i>hz</i> <i>t0</i> <i>env</i>)</code> [LISP]<dd>This is a
special case of <code>snd-amosc</code> that generates a sinusoid starting at phase
0 degrees.  The <i>env</i> parameter gives the envelope or any other amplitude
modulation.  You should use <code>partial</code> instead (see Section
<a href = "#88">"Oscillators"</a>).<br><br>
<dt><code>snd-sine(<a name="index766"><i>t0</i>, <i>hz</i>, <i>sr</i>, <i>d</i>)</code> [SAL]<br>

<code>(snd-sine <i>t0</i> <i>hz</i> <i>sr</i> <i>d</i>)</code> [LISP]<dd>This is a
special case of <code>snd-osc</code> that always generates a sinusoid with initial
phase of 0 degrees.  You should use <code>sine</code> instead (see Section
<a href = "#88">"Oscillators"</a>).<br><br>
<dt><code>snd-sampler(<a name="index767"><i>s</i>, <i>step</i>,
<i>start</i>, <i>sr</i>, <i>hz</i>, <i>t0</i>, <i>fm</i>, <i>npoints</i>)</code> [SAL]<br>

<code>(snd-sampler <i>s</i> <i>step</i> <i>start</i> <i>sr</i> <i>hz</i>
<i>t0</i> <i>fm</i> <i>npoints</i>)</code> [LISP]<dd>Returns a sound constructed
by reading a sample from beginning to end and then splicing on copies
of the same sound from a loop point to the end.  
The sound <i>s</i> is the source sound to be looped, and <i>step</i> (a
FLONUM) is the nominal fundamental frequency (in steps, not Hz) of
<i>s</i>. The <i>start</i> (a FLONUM) is the time in seconds at which to
start the loop, <i>sr</i> (a FLONUM) is the desired sample rate of the
output, <i>hz</i> is the nominal fundamental frequency of the output,
<i>t0</i> (a FLONUM) is the starting time of the output, and <i>fm</i> (a
SOUND) is frequency modulation that is added to <i>hz</i> to determine
the output fundamental frequency. The parameter <i>npoints</i> (a FIXNUM)
specifies how many points should be used for sample
interpolation.  Currently this parameter defaults to 2 and only 2-point
(linear) interpolation is implemented.  It is an error to modulate
such that the frequency is negative. Note also that the loop point may
be fractional. This function implements a typical sampling synthesis
algorithm, looping and resampling the input according to the ratio
between the desired fundamental frequency (which is the sum of <i>hz</i>
and <i>fm</i>) and the nominal fundamental of the looped sound (which is
assumed to be given by <i>step</i>). You should use <code>sampler</code>
instead (see Section <a href = "#88">"Oscillators"</a>).<br><br>
<dt><code>snd-siosc(<a name="index768"><i>tables</i>, <i>sr</i>, <i>hz</i>, <i>t0</i>,
<i>fm</i>)</code> [SAL]<br>

<code>(snd-siosc <i>tables</i> <i>sr</i> <i>hz</i> <i>t0</i> <i>fm</i>)</code> [LISP]<dd>A Spectral Interpolation Oscillator with frequency modulation. The
<i>tables</i> is a list of sounds and sample counts as follows: (<i>table0</i>
<i>count1</i> <i>table1</i> ... <i>countN</i> <i>tableN</i>). The initial waveform is given by <i>table0</i>, which is interpolated linearly to <i>table1</i> over the first
<i>count1</i> samples. From <i>count1</i> to <i>count2</i> samples, the waveform is
interpolated from <i>table1</i> to <i>table2</i>, and so on.  If more than
<i>countN</i> samples are generated, <i>tableN</i> is used for the remainder of
the sound. The duration and logical stop time  of the sound is taken from
<i>fm</i>, which specified frequency modulation (deviation) in Hertz. You
should use <code>siosc</code> instead (see Section <a href = "#88">"Oscillators"</a>).<br><br>
<dt></dl><a name = "102"><h4>Physical Model Functions</h4></a>
These functions perform some sort of physically-based modeling synthesis.
<dl>
<dt>
<code>(snd-bandedwg<a name="index769"><a name="index770"> <i>freq</i> <i>bowpress-env</i> <i>preset</i> <i>sr</i>)</code><br>

<code>(snd-bandedwg <i>freq</i> <i>bowpress-env</i> <i>preset</i> <i>sr</i>)</code> [LISP]<dd>A Banded Wave Guide 
Percussion instrument implemented in STK. The parameter <i>freq</i> is a 
<code>FLONUM</code> in Hz, <i>bowpress-env</i> is 
a <code>SOUND</code> that ranges from zero to one, <i>preset</i> is a <code>FIXNUM</code>, 
and <i>sr</i> is the desired sample rate in Hz. Currently, there are four 
presets: uniform-bar (0), tuned-bar (1), glass-harmonica (2), and 
tibetan-bowl (3). You should use <code>wg-uniform-bar</code>, <code>wg-tuned-bar</code>,
 <code>wg-glass-harm</code>, or <code>wg-tibetan-bowl</code> instead (see Section 
<a href = "#92">"Physical Models"</a>).<br><br>
<dt><code>snd-bowed(<a name="index771"><a name="index772"><i>freq</i>,
<i>bowpress-env</i>, <i>sr</i>)</code> [SAL]<br>

<code>(snd-bowed <i>freq</i> <i>bowpress-env</i> <i>sr</i>)</code> [LISP]<dd>A bowed string instrument implemented in
STK. The freq is a <code>FLONUM</code> in Hertz, bowpress-env is a
 <code>SOUND</code> that ranges from z
ero to one, and sr is the desired sample rate (a <code>FLONUM</code>). 
You should use bowed instead  (see Section <a href = "#92">"Physical Models"</a>).<br><br>
<dt><code>snd-bowed-freq(<a name="index773"><a name="index774"><i>freq</i>, <i>bowpress-env</i>, <i>freq-env</i>, <i>sr</i>)</code> [SAL]<br>

<code>(snd-bowed-freq <i>freq</i> <i>bowpress-env</i> <i>freq-env</i> <i>sr</i>)</code> [LISP]<dd>A bowed model just like <code>snd-bowed</code> but with 
an additional parameter for continuous frequency control. You should use 
<code>bowed-freq</code> instead (see Section <a href = "#92">"Physical Models"</a>).<br><br>
<dt><code>snd-clarinet(<a name="index775"><a name="index776"><i>freq</i>, <i>breath-env</i>, <i>sr</i>)</code> [SAL]<br>

<code>(snd-clarinet <i>freq</i> <i>breath-env</i> <i>sr</i>)</code> [LISP]<dd>A clarinet
model implemented in STK. The <i>freq</i> is a <code>FLONUM</code> in Hertz,
 <i>breath-env</i> is
a <code>SOUND</code> that ranges from zero to one, and <i>sr</i> is the
 desired sample
rate (a <code>FLONUM</code>). You should use <code>clarinet</code> instead
 (see Section 
<a href = "#92">"Physical Models"</a>).<br><br>
<dt><code>snd-clarinet-freq(<a name="index777"><a name="index778"><i>freq</i>, <i>breath-env</i>, <i>freq-env</i>, <i>sr</i>)</code> [SAL]<br>

<code>(snd-clarinet-freq <i>freq</i> <i>breath-env</i> <i>freq-env</i> <i>sr</i>)</code> [LISP]<dd>A clarinet model just like <code>snd-clarinet</code> but with 
an additional parameter for continuous frequency control. You should use 
<code>clarinet-freq</code> instead (see Section <a href = "#92">"Physical Models"</a>).<br><br>
<dt><code>snd-clarinet-all(<a name="index779"><i>freq</i>, <i>vibrato-freq</i>,
<i>vibrato-gain</i>, <i>freq-env</i>, <i>breath-env</i>,
<i>reed-stiffness</i>, <i>noise</i>, <i>sr</i>)</code> [SAL]<br>

<code>(snd-clarinet-all <i>freq</i> <i>vibrato-freq</i> <i>vibrato-gain</i> <i>freq-env</i> <i>breath-env</i> <i>reed-stiffness</i> <i>noise</i> <i>sr</i>)</code> [LISP]<dd>A clarinet model just like 
<code>snd-clarinet-freq</code> but with 
additional parameters for vibrato generation and continuous control of
reed stiffness and breath noise. You should use 
<code>clarinet-all</code> instead (see Section <a href = "#92">"Physical Models"</a>).<br><br>
<dt><code>snd-flute(<a name="index780"><a name="index781"><i>freq</i>,
 <i>breath-env</i>, <i>sr</i>)</code> [SAL]<br>

<code>(snd-flute <i>freq</i> <i>breath-env</i> <i>sr</i>)</code> [LISP]<dd>A flute implemented in STK. The <i>freq</i> is a 
<code>FLONUM</code> in Hertz, <i>breath-env</i> is a <code>SOUND</code>
 that ranges from zero to one, and <i>sr</i> is
 the desired sample rate (a <code>FLONUM</code>). You should use <code>flute</code>
 instead (see Section <a href = "#92">"Physical Models"</a>).<br><br>
<dt><code>snd-flute-freq(<a name="index782"><a name="index783"><i>freq</i>, <i>breath-env</i>,
<i>freq-env</i>, <i>sr</i>)</code> [SAL]<br>

<code>(snd-flute-freq <i>freq</i> <i>breath-env</i> <i>freq-env</i> <i>sr</i>)</code> [LISP]<dd>A flute model just like <code>snd-flute</code> but with 
an additional parameter for continuous frequency control. You should use 
<code>flute-freq</code> instead (see Section <a href = "#92">"Physical Models"</a>).<br><br>
<dt><code>snd-flute-all(<a name="index784"><a name="index785"><i>freq</i>, <i>vibrato-freq</i>, <i>vibrato-gain</i>, <i>freq-env</i>, <i>breath-env</i>,
<i>jet-delay</i>, <i>noise</i>, <i>sr</i>)</code> [SAL]<br>

<code>(snd-flute-all <i>freq</i> <i>vibrato-freq</i> <i>vibrato-gain</i> <i>freq-env</i> <i>breath-env</i> <i>jet-delay</i> <i>noise</i> <i>sr</i>)</code> [LISP]<dd>A flute model just like 
<code>snd-flute-freq</code> but with 
additional parameters for vibrato generation and continuous control of
breath noise. You should use 
<code>flute-all</code> instead (see Section <a href = "#92">"Physical Models"</a>).<br><br>
<dt><code>snd-mandolin(<a name="index786"><a name="index787"><i>t0</i>, <i>freq</i>, <i>dur</i>, <i>body-size</i>, <i>detune</i>, <i>sr</i>)</code> [SAL]<br>

<code>(snd-mandolin <i>t0</i> <i>freq</i> <i>dur</i> <i>body-size</i> <i>detune</i> <i>sr</i>)</code> [LISP]<dd>A plucked
 double-string instrument model implemented in STK. The <i>t0</i> parameter
 is the starting time (in seconds), <i>freq</i> is a <code>FLONUM</code> in
 Hz, <i>body-size</i> and <i>detune</i> are <code>FLONUM</code>s, and <code>sr</code>
 is the desired sample
 rate. You should use <code>mandolin</code> instead (see Section <a href = "#92">"Physical Models"</a>).<br><br>
<dt><code>snd-modalbar(<a name="index788"><a name="index789"><i>t0</i>, <i>freq</i>, <i>preset</i>, <i>dur</i>, <i>sr</i>)</code> [SAL]<br>

<code>(snd-modalbar <i>t0</i> <i>freq</i> <i>preset</i> <i>dur</i> <i>sr</i>)</code> [LISP]<dd>Struck bar instrument
 model implemented in STK. The parameter <i>t0</i> is the starting 
time (in seconds), <i>freq</i> is a <code>FLONUM</code> in Hz,
 <code>preset</code> is a <code>FIXNUM</code> ranging from 0 to 8, <i>dur</i> is a 
<code>FLONUM</code> that
 sets the duration (in seconds) and <i>sr</i> is the desired sample rate. You 
should use <code>modalbar</code> instead (see Section <a href = "#92">"Physical Models"</a>).<br><br>
<dt><code>snd-sax(<a name="index790"><a name="index791"><i>freq</i>, <i>breath-env</i>, <i>sr</i>)</code> [SAL]<br>

<code>(snd-sax <i>freq</i> <i>breath-env</i> <i>sr</i>)</code> [LISP]<dd>A sax
model implemented in STK. The <i>freq</i> is a <code>FLONUM</code> in Hertz, <i>breath-env</i> is
a <code>SOUND</code> that ranges from zero to one, and <i>sr</i> is the desired sample
rate (a <code>FLONUM</code>). You should use <code>sax</code> instead (see Section 
<a href = "#92">"Physical Models"</a>).<br><br>
<dt><code>snd-sax-freq(<a name="index792"><i>freq</i>, <i>freq-env</i>, <i>breath-env</i>,
 <i>sr</i>)</code> [SAL]<br>

<code>(snd-sax-freq <i>freq</i> <i>freq-env</i> <i>breath-env</i> <i>sr</i>)</code> [LISP]<dd>A sax model just like <code>snd-sax</code> but with 
an additional parameter for continuous frequency control. You should use 
<code>sax-freq</code> instead (see Section <a href = "#92">"Physical Models"</a>).<br><br>
<dt><code>snd-sax-all(<a name="index793"><i>freq</i>, <i>vibrato-freq</i>,
<i>vibrato-gain</i>, <i>freq-env</i>, <i>breath-env</i>,
<i>reed-stiffness</i>, <i>noise</i>, <i>blow-pos</i>, <i>reed-table-offset</i>, <i>sr</i>)</code> [SAL]<br>

<code>(snd-sax-all <i>freq</i> <i>vibrato-freq</i> <i>vibrato-gain</i> <i>freq-env</i> <i>breath-env</i> <i>reed-stiffness</i> <i>noise</i> <i>blow-pos</i> <i>reed-table-offset</i> <i>sr</i>)</code> [LISP]<dd>A 
sax model just like 
<code>snd-sax-freq</code> but with 
additional parameters for vibrato generation and continuous control of
reed stiffness, breath noise, excitation position, and reed table offset.
 You should use 
<code>sax-all</code> instead (see Section <a href = "#92">"Physical Models"</a>).<br><br>
<dt><code>snd-sitar(<a name="index794"><a name="index795"><i>t0</i>,
<i>freq</i>, <i>dur</i>, <i>sr</i>)</code> [SAL]<br>

<code>(snd-sitar <i>t0</i> <i>freq</i> <i>dur</i> <i>sr</i>)</code> [LISP]<dd>A sitar model implemented in STK. The parameter 
<i>t0</i> is the starting time, <i>freq</i> is a <code>FLONUM</code> (in Hz), E
<i>dur</i> sets the duration and <i>sr</i> is the sample rate (in Hz) 
of the resulting sound. You should use <code>sitar</code> instead (see Section
<a href = "#92">"Physical Models"</a>).<br><br>
<dt></dl><a name = "103"><h4>Sequence Support Functions</h4></a>
The next two functions are used to implement Nyquist's <code>seq</code> construct.
<p>
<dl>
<dt>
<code>snd-seq(<a name="index796"><i>sound</i>, <i>closure</i>)</code> [SAL]<br>

<code>(snd-seq <i>sound</i> <i>closure</i>)</code> [LISP]<dd>This function returns
<i>sound</i> until the logical stop time of <i>sound</i>.  Then, the XLISP 
<i>closure</i>
is evaluated, passing it the logical stop time of <i>sound</i> as a
parameter.  The closure must return a sound, which is then added to
<i>sound</i>.  (An add is used so that <i>sound</i> can continue past its logical
stop if desired.)  Do not call this function.  See <code>seq</code> in Section
<a href = "#95">"Combination and Time Structure"</a>.<br><br>
<dt><code>snd-multiseq(<a name="index797"><i>array</i>, <i>closure</i>)</code> [SAL]<br>

<code>(snd-multiseq <i>array</i> <i>closure</i>)</code> [LISP]<dd>This
function is similar to <code>snd-seq</code> except the first parameter is a
multichannel sound rather than a single sound.  A multichannel sound is
simply an XLISP array of sounds.  An array of sounds is returned which is
the sum of <i>array</i> and another array of sounds returned by <i>closure</i>.
The <i>closure</i> is passed the logical stop time of the multichannel sound,
which is the maximum logical stop time of any element of <i>array</i>.    Do
not call this function.  See <code>seq</code> in Section <a href = "#95">"Combination and Time Structure"</a>.
</dl>
<p>
<dl>
<dt>
<code>snd-trigger(<a name="index798"><i>s</i>, <i>closure</i>)</code> [SAL]<br>

<code>(snd-trigger <i>s</i> <i>closure</i>)</code> [LISP]<dd>This is one of
the only ways in which a behavior instance can be created by changes in a
signal. When <i>s</i> (a <code>SOUND</code>) makes a transition from less than or 
equal to zero to greater than zero, the closure, which takes a starting
time parameter, is evaluated. The closure must return a <code>SOUND</code>. The
sum of all these sounds is returned. If there are no sounds, the result will
be zero. The stop time of the result is the maximum stop time of <i>s</i> and
all sounds returned by the closure. The sample rate of the return value is
the sample rate of <i>s</i>, and the sounds returned by the closure must all
have that same sample rate. Do not call this function. 
See <code>trigger</code> in Section <a href = "#95">"Combination and Time Structure"</a>.<br><br>
<dt>An implementation note: There is no way to have <code>snd-trigger</code> return
a multichannel sound. An alternative implementation would be a built-in
function to scan ahead in a sound to find the time of the next zero crossing.
This could be combined with some LISP code similar to <code>seq</code> to sum up
instances of the closure. However, this would force arbitrary look-ahead
and therefore would not work with real-time inputs, which was the motivation
for <code>snd-trigger</code> in the first place.
</dl>
<p>
<hr>
<a href = "part7.html">Previous Section</a> | <a href = "part9.html">Next Section</a> | <a href = "title.html#toc">Table of Contents</a> | <a href = "indx.html">Index</a> | <a href = "title.html">Title Page</a>
</body></html>

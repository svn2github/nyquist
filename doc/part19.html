<a href = "part18.html">Previous Section</a> | <a href = "indx.html">Next Section (Index)</a> | <a href = "title.html#toc">Table of Contents</a> | <a href = "title.html">Title Page</a>
<hr>
<html><head><title>Appendix 4: XLISP: An Object-oriented Lisp</title></head>
<a name = "209"><h2>Appendix 4: XLISP: An Object-oriented Lisp</h2></a>

<blockquote><b>Version 2.0</b>
<p>
February 6, 1988
<p>
by<br>

<b>David Michael Betz</b><br>

127 Taylor Road<br>

Peterborough, NH 03458
<p>
Copyright (c) 1988, by David Michael Betz<br>

All Rights Reserved<br>

Permission is granted for unrestricted non-commercial use<br>

</blockquote>






<a name = "210"><h3>Introduction</h3></a>
        XLISP is an experimental programming language combining some of
        the features of Common Lisp with an object-oriented extension
        capability.  It was implemented to allow experimentation with
        object-oriented programming on small computers.
<p>
        Implementations of XLISP run on virtually every operating system.
        XLISP is completely written in the programming language
        C and is easily extended with user written built-in functions
        and classes.  It is available in source form to non-commercial
        users.
<p>
        Many Common Lisp functions are built into XLISP.  In addition,
        XLISP defines the objects Object and Class as primitives.
        Object is the only class that has no superclass and hence is
        the root of the class hierarchy tree.  Class is the class of
        which all classes are instances (it is the only object that is
        an instance of itself).
<p>
        This document is a brief description of XLISP.  It assumes some
        knowledge of LISP and some understanding of the concepts of
        object-oriented programming.
<p>
        I recommend the book <i>Lisp</i> by Winston and Horn and published by
        Addison Wesley for learning Lisp.  The first edition of this
        book is based on MacLisp and the second edition is based on
        Common Lisp. 
<p>
        You will probably also need a copy of <i>Common Lisp: The
        Language</i> by Guy L. Steele, Jr., published by Digital Press to
        use as a reference for some of the Common Lisp functions that
        are described only briefly in this document.
<p>
        <a name = "211"><h3>A Note From The Author</h3></a>        If you have any problems with XLISP, feel free to contact me [me being David Betz - RBD] for
        help or advice.  Please remember that since XLISP is available
        in source form in a high level language, many users [e.g. that Dannenberg fellow - RBD] have been
        making versions available on a variety of machines.  If you call
        to report a problem with a specific version, I may not be able
        to help you if that version runs on a machine to which I don't
        have access.  Please have the version number of the version that
        you are running readily accessible before calling me.
<p>
        If you find a bug in XLISP, first try to fix the bug yourself
        using the source code provided.  If you are successful in fixing
        the bug, send the bug report along with the fix to me.  If you
        don't have access to a C compiler or are unable to fix a bug,
        please send the bug report to me and I'll try to fix it.
<p>
        Any suggestions for improvements will be welcomed.  Feel free to
        extend the language in whatever way suits your needs.  However,
        PLEASE DO NOT RELEASE ENHANCED VERSIONS WITHOUT CHECKING WITH ME
        FIRST!!  I would like to be the clearing house for new features
        added to XLISP.  If you want to add features for your own
        personal use, go ahead.  But, if you want to distribute your
        enhanced version, contact me first.  Please remember that the
        goal of XLISP is to provide a language to learn and experiment
        with LISP and object-oriented programming on small computers.  I
        don't want it to get so big that it requires megabytes of memory
        to run.
<p>
        <a name = "212"><h3>XLISP Command Loop</h3></a><a name="index1310"><a name="index1311">        When XLISP is started, it first tries to load the workspace
        <code>xlisp.wks</code> from the current directory.  If that file doesn't
        exist, XLISP builds an initial workspace, empty except for the
        built-in functions and symbols.
<p>
        Then XLISP attempts to load <code>init.lsp</code> from the current
        directory.  It then loads any files named as parameters on the
        command line (after appending <code>.lsp</code> to their names).
<p>
        XLISP then issues the following prompt:
<pre>
        &gt;
</pre>

        This indicates that XLISP is waiting for an expression to be
        typed.
<p>
        When a complete expression has been entered, XLISP attempts to
        evaluate that expression.  If the expression evaluates
        successfully, XLISP prints the result and then returns to the
        initial prompt waiting for another expression to be typed.
<p>
        <a name = "213"><h3>Special Characters</h3></a><a name="index1312"> When XLISP is running from a console, some control characters invoke operations:
<ul>
<li>
Backspace and Delete characters erase the previous character on the input line (if any).
<li>Control-U erases the entire input line. 
<li>Control-C executes the TOP-LEVEL function.
<li>Control-G executes the CLEAN-UP function.
<li>Control-P executes the CONTINUE function.
<li>Control-B stops execution and enters the break command loop. Execution can be continued by typing Control-P or (CONTINUE).
<li>Control-E turns on character echoing (Linux and Mac OS X only).
<li>Control-F turns off character echoing (Linux and Mac OS X only).
<li>Control-T evaluates the INFO function.
</ul>
<p>
        <a name = "214"><h3>Break Command Loop</h3></a><a name="index1313">        When XLISP encounters an error while evaluating an expression,
        it attempts to handle the error in the following way:
<p>
        If the symbol <code>*breakenable*<a name="index1314"></code> is
        true, the message corresponding to the error is printed.  If
        the error is correctable, the correction message is printed.
<p>
        If the symbol <code>*tracenable*<a name="index1315"></code> is true, a trace back is printed.
        The number of entries printed depends on the value of the symbol
        <code>*tracelimit*<a name="index1316"></code>.  If this symbol is set to something other than a
        number, the entire trace back stack is printed.
<p>
        XLISP then enters a read/eval/print loop to allow the user to
        examine the state of the interpreter in the context of the
        error.  This loop differs from the normal top-level
        read/eval/print loop in that if the user invokes the function
        <code>continue</code>, XLISP will continue from a correctable error.  If
        the user invokes the function <code>clean-up</code>, XLISP will abort the
        break loop and return to the top level or the next lower
        numbered break loop.  When in a break loop, XLISP prefixes the
        break level to the normal prompt.
<p>
        If the symbol <code>*breakenable*<a name="index1317"></code> is <code>nil</code>, XLISP looks for a
        surrounding errset function.  If one is found, XLISP examines
        the value of the print flag.  If this flag is true, the error
        message is printed.  In any case, XLISP causes the errset
        function call to return <code>nil</code>.
<p>
        If there is no surrounding errset function, XLISP prints the
        error message and returns to the top level.
<p>
        <a name = "215"><h3>Data Types</h3></a><a name="index1318"><a name="index1319">        There are several different data types available to XLISP
        programmers.
<p>
<ul>
<li>
lists
<li>symbols
<li>strings
<li>integers
<li>characters
<li>floats
<li>objects
<li>arrays
<li>streams
<li>subrs (built-in functions)
<li>fsubrs (special forms)
<li>closures (user defined functions)
</ul>
<p>
<a name = "216"><h3>The Evaluator</h3></a><a name="index1320"><a name="index1321">        The process of evaluation in XLISP:
<ul>
<li>
        Strings, integers, characters, floats, objects, arrays, streams,
        subrs, fsubrs and closures evaluate to themselves.
<li>        Symbols act as variables and are evaluated by retrieving the
        value associated with their current binding.
<li>        Lists are evaluated by examining the first element of the list
        and then taking one of the following actions:
<ul>
<li>
            If it is a symbol, the functional binding of the symbol is
            retrieved.
<li>            If it is a lambda expression, a closure is constructed for
            the function described by the lambda expression.
<li>            If it is a subr, fsubr or closure, it stands for itself.
<li>            Any other value is an error.
</ul>
        Then, the value produced by the previous step is examined:
<ul>
<li>
            If it is a subr or closure, the remaining list elements are
            evaluated and the subr or closure is called with these
            evaluated expressions as arguments.
<li>            If it is an fsubr, the fsubr is called using the remaining
            list elements as arguments (unevaluated).
<li>            If it is a macro, the macro is expanded using the remaining
            list elements as arguments (unevaluated).  The macro
            expansion is then evaluated in place of the original macro
            call.
</ul>
</ul>
<p>
<a name = "217"><h3>Lexical Conventions</h3></a><a name="index1322"><a name="index1323">        The following conventions must be followed when entering XLISP
        programs:
<p>
        Comments in XLISP code begin with a semi-colon character and
        continue to the end of the line.
<p>
        Symbol names in XLISP can consist of any sequence of non-blank
        printable characters except the following:
<pre>
                ( ) ' ` , " ;
</pre>

        Uppercase and lowercase characters are not distinguished within
        symbol names.  All lowercase characters are mapped to uppercase
        on input.
<p>
        Integer literals consist of a sequence of digits optionally
        beginning with a <code>+</code> or <code>-</code>.  The range of values an integer can
        represent is limited by the size of a C <code>long</code> on the machine on
        which XLISP is running.
<p>
        Floating point literals consist of a sequence of digits
        optionally beginning with a <code>+</code> or <code>-</code> and including an embedded
        decimal point.  The range of values a floating point number can
        represent is limited by the size of a C <code>float</code> (<code>double</code> on
        machines with 32 bit addresses) on the machine on which XLISP is
        running.
<p>
        Literal strings are sequences of characters surrounded by double
        quotes.  Within quoted strings the "<code>\</code>" character is used to
        allow non-printable characters to be included.  The codes
        recognized are:
<ul>
<li>
<code>\\</code>        means the character "<code>\</code>"
<li><code>\n</code>      means newline
<li><code>\t</code>       means tab
<li><code>\r</code>       means return
<li><code>\f</code>       means form feed
<li><code>\nnn</code>    means the character whose octal code is nnn
</ul>
<p>
<a name = "218"><h3>Readtables</h3></a><a name="index1324">        The behavior of the reader is controlled by a data structure
        called a <i>readtable</i>.  The reader uses the symbol <code>*readtable*<a name="index1325"></code> to
        locate the current readtable.  This table controls the
        interpretation of input characters.  It is an array with 128
        entries, one for each of the ASCII character codes.  Each entry
        contains one of the following things:
<ul>
<li>
                <code>NIL</code> -          Indicating an invalid character
<li>                <code>:CONSTITUENT</code> -   Indicating a symbol constituent
<li>                <code>:WHITE-SPACE</code>  -  Indicating a whitespace character
<li>                <code>(:TMACRO . <i>fun</i>)</code> - Terminating readmacro
<li>                <code>(:NMACRO . <i>fun</i>)</code> - Non-terminating readmacro
<li>                <code>:SESCAPE</code> -       Single escape character ('\')
<li>                <code>:MESCAPE</code> -       Multiple escape character ('|')
</ul>
<p>
        In the case of <code>:TMACRO</code> and <code>:NMACRO</code>, the <i>fun</i> component is a
        function.  This can either be a built-in readmacro function or a
        lambda expression.  The function should take two parameters.
        The first is the input stream and the second is the character
        that caused the invocation of the readmacro.  The readmacro
        function should return <code>NIL</code> to indicate that the character should
        be treated as white space or a value consed with <code>NIL</code> to indicate
        that the readmacro should be treated as an occurence of the
        specified value.  Of course, the readmacro code is free to read
        additional characters from the input stream.
<p>
        XLISP defines several useful read macros<a name="index1326">:
<ul>
<li>
                <code>'</code><i>&lt;expr&gt;</i>         == <code>(quote</code> <i>&lt;expr&gt;</i><code>)</code>
<li>                <code>#'</code><i>&lt;expr&gt;</i>        == <code>(function</code> <i>&lt;expr&gt;</i><code>)</code>
<li>                <code>#(</code><i>&lt;expr&gt;</i>...<code>)</code>    == an array of the specified expressions
<li>                <code>#x</code><i>&lt;hdigits&gt;</i>     == a hexadecimal number (0-9,A-F)
<li>                <code>#o</code><i>&lt;odigits&gt;</i>     == an octal number (0-7)
<li>                <code>#b</code><i>&lt;bdigits&gt;</i>     == a binary number (0-1)
<li>                <code>#\</code><i>&lt;char&gt;</i> == the ASCII code of the character
<li>                <code>#|</code> ... <code>|#</code>       == a comment
<li>                <code>#:</code><i>&lt;symbol&gt;</i>      == an uninterned symbol
<li>                <code>`</code><i>&lt;expr&gt;</i>         == <code>(backquote</code> <i>&lt;expr&gt;</i><code>)</code>
<li>                <code>,</code><i>&lt;expr&gt;</i>         == <code>(comma</code> <i>&lt;expr&gt;</i><code>)</code>
<li>                <code>,@</code><i>&lt;expr&gt;</i>        == <code>(comma-at</code> <i>&lt;expr&gt;</i><code>)</code>
<li></ul>
<a name = "219"><h3>Lambda Lists</h3></a><a name="index1327">        There are several forms in XLISP that require that a "lambda
        list" be specified.  A lambda list is a definition of the
        arguments accepted by a function.  There are four different
        types of arguments.
<p>
        The lambda list starts with required arguments.  Required
        arguments must be specified in every call to the function.
<p>
        The required arguments are followed by the <code>&amp;optional</code> arguments.
        Optional arguments may be provided or omitted in a call.  An
        initialization expression may be specified to provide a default
        value for an <code>&amp;optional</code> argument if it is omitted from a call.
        If no initialization expression is specified, an omitted
        argument is initialized to <code>NIL</code>.  It is also possible to provide
        the name of a <code>supplied-p</code> variable that can be used to
        determine if a call provided a value for the argument or if the
        initialization expression was used.  If specified, the supplied-
        p variable will be bound to T if a value was specified in the
        call and <code>NIL</code> if the default value was used.
<p>
        The <code>&amp;optional</code> arguments are followed by the <code>&amp;rest</code> argument.  The
        <code>&amp;rest</code> argument gets bound to the remainder of the argument list
        after the required and <code>&amp;optional</code> arguments have been removed.
<p>
        The <code>&amp;rest</code> argument is followed by the <code>&amp;key</code> arguments.  When a
        keyword argument is passed to a function, a pair of values
        appears in the argument list.  The first expression in the pair
        should evaluate to a keyword symbol (a symbol that begins with a
        "<code>:</code>").  The value of the second expression is the value of the
        keyword argument.  Like <code>&amp;optional</code> arguments, <code>&amp;key</code> arguments can
        have initialization expressions and supplied-p variables.  In
        addition, it is possible to specify the keyword to be used in a
        function call.  If no keyword is specified, the keyword obtained
        by adding a "<code>:</code>" to the beginning of the keyword argument symbol
        is used.  In other words, if the keyword argument symbol is
        <code>foo</code>, the keyword will be <code>:foo</code>.
<p>
        The <code>&amp;key</code> arguments are followed by the <code>&amp;aux</code> variables.  These
        are local variables that are bound during the evaluation of the
        function body.  It is possible to have initialization
        expressions for the <code>&amp;aux</code> variables.
<p>
    Here is the complete syntax for lambda lists:
<blockquote>
                (<i>rarg</i>...<br>

                 [<code>&amp;optional</code> [<i>oarg</i> | (<i>oarg</i> [<i>init</i> [<i>svar</i>]])]...]<br>

                 [<code>&amp;rest</code> <i>rarg</i>]<br>

                 [<code>&amp;key</code><br>

                   [<i>karg</i> | ([<i>karg</i> | (<i>key</i> <i>karg</i>)] [<i>init</i> [<i>svar</i>]])]...<br>

                   <code>&amp;allow</code>-other-keys]<br>

                 [<code>&amp;aux</code><br>

                   [<i>aux</i> | (<i>aux</i> [<i>init</i>])]...])
<p>
            where:
<p>
                <i>rarg</i> is a required argument symbol<br>

                <i>oarg</i> is an <code>&amp;optional</code> argument symbol<br>

                <i>rarg</i> is the <code>&amp;rest</code> argument symbol<br>

                <i>karg</i> is a <code>&amp;key</code> argument symbol<br>

                <i>key</i> is a keyword symbol<br>

                <i>aux</i> is an auxiliary variable symbol<br>

                <i>init</i> is an initialization expression<br>

                <i>svar</i> is a supplied-p variable symbol<br>

</blockquote>
<p>
<a name = "220"><h3>Objects</h3></a><a name="index1328">        Definitions:
<ul>
<li>
selector - a symbol used to select an appropriate method
<li>message - a selector and a list of actual arguments
<li>method - the code that implements a message
</ul>
        Since XLISP was created to provide a simple basis for
        experimenting with object-oriented programming, one of the
        primitive data types included is <i>object</i>.  In XLISP, an object
        consists of a data structure containing a pointer to the
        object's class as well as an array containing the values of the
        object's instance variables.
<p>
        Officially, there is no way to see inside an object (look at the
        values of its instance variables).  The only way to communicate
        with an object is by sending it a message.
<p>
        You can send a message to an object using the <code>send</code> function.
        This function takes the object as its first argument, the
        message selector as its second argument (which must be a symbol)
        and the message arguments as its remaining arguments.
<p>
        The <code>send</code> function determines the class of the receiving object
        and attempts to find a method corresponding to the message
        selector in the set of messages defined for that class.  If the
        message is not found in the object's class and the class has a
        super-class, the search continues by looking at the messages
        defined for the super-class.  This process continues from one
        super-class to the next until a method for the message is found.
        If no method is found, an error occurs.
<p>
        When a method is found, the evaluator binds the receiving object
        to the symbol <code>self</code> and evaluates the method using the
        remaining elements of the original list as arguments to the
        method.  These arguments are always evaluated prior to being
        bound to their corresponding formal arguments.  The result of
        evaluating the method becomes the result of the expression.
<p>
        Within the body of a method, a message can be sent to the current
        object by calling the <code>(send self ...)</code>. The method lookup
        starts with the object's class regardless of the class containing
        the current method.
<p>
        Sometimes it is desirable to invoke a general method in a superclass
        even when it is overridden by a more specific method in a subclass.
        This can be accomplished by calling <code>send-super</code>, which begins
        the method lookup in the superclass of the class defining the current
        method rather than in the class of the current object.
<p>
        The <code>send-super</code> function takes a selector as its first argument
        (which must be a symbol) and the message arguments as its remaining
        arguments. Notice that <code>send-super</code> can only be sent from within
        a method, and the target of the message is always the current object
        (<code>self</code>). <code>(send-super ...)</code> is similar to 
        <code>(send self ...)</code> except that method lookup begins in the 
        superclass of the class containing the current method
        rather than the class of the current object.
<p>
<a name = "221"><h3>The "Object" Class</h3></a><a name="index1329"><code>Object</code><a name="index1330"> - the top of the class hierarchy.
<p>
Messages:
<dl>
<dt>
<code>:show<a name="index1331"></code> - show an object's instance variables.
<dd>
returns -  the object

<br>
<br><dt><code>:class<a name="index1332"></code> - return the class of an object
<dd>
returns -  the class of the object

<br>
<br><dt><code>:isa<a name="index1333"></code> <i>class</i> - test if object inherits from class
<dd>
returns - <code>t</code> if object is an instance of <i>class</i> or a subclass of <i>class</i>, otherwise <code>nil</code>

<br>
<br><dt><code>:isnew<a name="index1334"></code> - the default object initialization routine
<dd>
returns -  the object

</dl>
<p>
<a name = "222"><h3>The "Class" Class</h3></a><a name="index1335"><code>Class<a name="index1336"></code> - class of all object classes (including itself)
<p>
            Messages:
<p>
<dl>
<dt>
                <code>:new<a name="index1337"></code> - create a new instance of a class
<dd>
                    returns -    the new class object

<br>
<br><dt>                <code>:isnew<a name="index1338"></code> <i>ivars</i> [<i>cvars</i> [<i>super</i>]] - initialize a new class
<dd>
                    <i>ivars</i> -    the list of instance variable symbols<br>
                    <i>cvars</i> -    the list of class variable symbols<br>
                    <i>super</i> -    the superclass (default is object)<br>
                    returns -    the new class object

<br>
<br><dt>                <code>:answer<a name="index1339"></code> <i>msg</i> <i>fargs</i> <i>code</i> - add a message to a class
<dd>
                    <i>msg</i> -      the message symbol<br>
                <i>fargs</i> -    the formal argument list (lambda list)<br>
                    <i>code</i> -     a list of executable expressions<br>
                    returns -    the object

<br>
<br><dt>
</dl>
<p>
        When a new instance of a class is created by sending the message
        <code>:new</code> to an existing class, the message <code>:isnew</code> followed by
        whatever parameters were passed to the <code>:new</code> message is sent to
        the newly created object.
<p>
        When a new class is created by sending the <code>:new</code> message to the
        object <code>Class</code>, an optional parameter may be specified
        indicating the superclass of the new class.  If this parameter
        is omitted, the new class will be a subclass of <code>Object</code>.  A
        class inherits all instance variables, class variables, and
        methods from its super-class.
<p>
<a name = "223"><h3>Profiling</h3></a><a name="index1340">
The Xlisp 2.0 release has been extended with a profiling facility, which counts how many times and where <code>eval</code> is executed.  A separate count is maintained for each named function, closure, or macro, and a count indicates an <code>eval</code> in the immediately (lexically) enclosing named function, closure, or macro.  Thus, the count gives an indication of the amount of time spent in a function, not counting nested function calls.  The list of all functions executed is maintained on the global <code>*profile*</code> variable.  These functions in turn have <code>*profile*</code> properties, which maintain the counts.  The profile system merely increments counters and puts symbols on the <code>*profile*</code> list.  It is up to the user to initialize data and gather results.  Profiling is turned on or off with the <code>profile</code> function.  Unfortunately, methods cannot be profiled with this facility.
<p>

<a name = "224"><h3>Symbols</h3></a><a name="index1341">
<ul>
<li>
<code>self</code><a name="index1342"> - the current object (within a method context)
<li><code>*obarray*<a name="index1343"></code> - the object hash table
<li><code>*standard-input*<a name="index1344"></code> - the standard input stream
<li><code>*standard-output*<a name="index1345"></code> - the standard output stream
<li><code>*error-output*<a name="index1346"></code> - the error output stream
<li><code>*trace-output*<a name="index1347"></code> - the trace output stream
<li><code>*debug-io*<a name="index1348"></code> - the debug i/o stream
<li><code>*breakenable*<a name="index1349"></code> - flag controlling entering break loop on errors
<li><code>*tracelist*<a name="index1350"></code> - list of names of functions to trace
<li><code>*tracenable*<a name="index1351"></code> - enable trace back printout on errors
<li><code>*tracelimit*<a name="index1352"></code> - number of levels of trace back information
<li><code>*evalhook*<a name="index1353"></code> - user substitute for the evaluator function
<li><code>*applyhook*<a name="index1354"></code> - (not yet implemented)
<li><code>*readtable*<a name="index1355"></code> - the current readtable
<li><code>*unbound*<a name="index1356"></code> - indicator for unbound symbols
<li><code>*gc-flag*<a name="index1357"></code> - controls the printing of gc messages
<li><code>*gc-hook*<a name="index1358"></code> - function to call after garbage collection
<li><code>*integer-format*<a name="index1359"></code> - format for printing integers ("%d" or "%ld")
<li><code>*float-format*<a name="index1360"></code> - format for printing floats ("%g")
<li><code>*print-case*<a name="index1361"></code> - symbol output case (:upcase or :downcase)
</ul>
<p>
        There are several symbols maintained by the read/eval/print
        loop.  The symbols <code>+</code>, <code>++</code>, and <code>+++</code> are bound to the most
        recent three input expressions.  The symbols <code>*</code>, <code>**</code> and <code>***</code>
        are bound to the most recent three results.  The symbol <code>-</code> is
        bound to the expression currently being evaluated.  It becomes
        the value of <code>+</code> at the end of the evaluation.
<a name = "225"><h3>Evaluation Functions</h3></a><a name="index1362">
<dl>
<dt>
        <code>eval(<i>expr</i>)</code> [SAL]<br>
        <code>(eval<a name="index1363"> <tt><i>expr</i></tt>)</code> [LISP] - evaluate an xlisp expression

<dd>
            <i>expr</i> -     the expression to be evaluated<br>
            returns -     the result of evaluating the expression

<br>
<br><dt>        <code>apply(<i>fun</i>, <i>args</i>)</code> [SAL]<br>
        <code>(apply<a name="index1364"> <tt><i>fun</i></tt> <tt><i>args</i></tt>)</code> [LISP] - apply a function to a list of arguments

<dd>
            <i>fun</i> -      the function to apply (or function symbol)<br>
            <i>args</i> -     the argument list<br>
            returns -    the result of applying the function to the arguments

<br>
<br><dt>        <code>funcall(<i>fun</i>, <i>arg</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(funcall<a name="index1365"> <tt><i>fun</i></tt> <tt><i>arg</i></tt><span style="font-style:normal">...</span>)</code> [LISP] - call a function with arguments

<dd>
            <i>fun</i> -      the function to call (or function symbol)<br>
            <i>arg</i> -      arguments to pass to the function<br>
            returns -    the result of calling the function with the arguments

<br>
<br><dt>        <code>quote(<i>expr</i>)</code> [SAL]<br>
        <code>(quote<a name="index1366"> <tt><i>expr</i></tt>)</code> [LISP] -  return an expression unevaluated

<dd>
            <i>expr</i>  -    the expression to be quoted (quoted)<br>
            returns   -  <i>expr</i> unevaluated

<br>
<br><dt>        <code>function(<i>expr</i>)</code> [SAL]<br>
        <code>(function<a name="index1367"> <tt><i>expr</i></tt>)</code> [LISP] -  get the functional interpretation
<dd>
            <i>expr</i> -     the symbol or lambda expression (quoted)<br>
            returns  -   the functional interpretation<br>

<br><dt>        <code>backquote(<i>expr</i>)</code> [SAL]<br>
        <code>(backquote<a name="index1368"> <tt><i>expr</i></tt>)</code> [LISP] - fill in a template
<dd>
            <i>expr</i> -     the template<br>
            returns  -   a copy of the template with comma and comma-at<br>
             expressions expanded

<br>
<br><dt>        <code>lambda(<i>args</i>, <i>expr</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(lambda<a name="index1369"> <tt><i>args</i></tt> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP] - make a function closure
<dd>
            <i>args</i> -     formal argument list (lambda list) (quoted)<br>
            <i>expr</i> -     expressions of the function body<br>
            returns  -   the function closure<br>

<br><dt>        <code>get-lambda-expression(<i>closure</i>)</code> [SAL]<br>
        <code>(get-lambda-expression<a name="index1370"> <tt><i>closure</i></tt>)</code> [LISP] - get the lambda expression
<dd>
            <i>closure</i> -  the closure<br>
            returns  -   the original lambda expression<br>

<br><dt>        <code>macroexpand(<i>form</i>)</code> [SAL]<br>
        <code>(macroexpand<a name="index1371"> <tt><i>form</i></tt>)</code> [LISP] - recursively expand macro calls
<dd>
            <i>form</i> -     the form to expand<br>
            returns  -   the macro expansion<br>

<br><dt>        <code>macroexpand-1(<i>form</i>)</code> [SAL]<br>
        <code>(macroexpand-1<a name="index1372"> <tt><i>form</i></tt>)</code> [LISP] - expand a macro call
<dd>
            <i>form</i> -     the macro call form<br>
            returns  -   the macro expansion<br>

<br><dt>
</dl><a name = "226"><h3>Symbol Functions</h3></a><a name="index1373">
<dl>
<dt>
        <code>set(<i>sym</i>, <i>expr</i>)</code> [SAL]<br>
        <code>(set<a name="index1374"> <tt><i>sym</i></tt> <tt><i>expr</i></tt>)</code> [LISP] -  set the value of a symbol

<dd>
            <i>sym</i>  -     the symbol being set<br>
            <i>expr</i> -     the new value<br>
            returns  -   the new value<br>

<br><dt>        <code>setq([<i>sym</i>, <i>expr</i>]<span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(setq<a name="index1375"> [<tt><i>sym</i></tt> <tt><i>expr</i></tt>]<span style="font-style:normal">...</span>)</code> [LISP] -  set the value of a symbol

<dd>
            <i>sym</i>  -     the symbol being set (quoted)<br>
            <i>expr</i> -     the new value<br>
            returns  -   the new value<br>

<br><dt>        <code>psetq([<i>sym</i>, <i>expr</i>]<span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(psetq<a name="index1376"> [<tt><i>sym</i></tt> <tt><i>expr</i></tt>]<span style="font-style:normal">...</span>)</code> [LISP]  - parallel version of setq

<dd>
            <i>sym</i>  -     the symbol being set (quoted)<br>
            <i>expr</i> -     the new value<br>
            returns  -   the new value<br>

<br><dt>        <code>setf([<i>place</i>, <i>expr</i>]<span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(setf<a name="index1377"> [<tt><i>place</i></tt> <tt><i>expr</i></tt>]<span style="font-style:normal">...</span>)</code> [LISP]  - set the value of a field

<dd>
            <i>place</i> -     the field specifier (quoted):<br>
<dl><dd>
  <i>sym</i> -                  set value of a symbol<br>
  (car <i>expr</i>)  -          set car of a cons node<br>
  (cdr <i>expr</i>)  -          set cdr of a cons node<br>
  (nth <i>n</i> <i>expr</i>) -       set nth car of a list<br>
  (aref <i>expr</i> <i>n</i>) -       set nth element of an array<br>
  (get <i>sym</i> <i>prop</i>) -      set value of a property<br>
  (symbol-value <i>sym</i>) -   set value of a symbol<br>
  (symbol-function <i>sym</i>) - set functional value of a symbol<br>
  (symbol-plist <i>sym</i>) -    set property list of a symbol<br>
</dl>
        <i>expr</i> -     the new value<br>
        returns  -   the new value<br>

<br><dt>

        <code>(defun<a name="index1378"> <tt><i>sym</i></tt> <tt><i>fargs</i></tt> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - define a function<br>

        <code>(defmacro<a name="index1379"> <tt><i>sym</i></tt> <tt><i>fargs</i></tt> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP] -  define a macro

<dd>
            <i>sym</i> -      symbol being defined (quoted)<br>
            <i>fargs</i> -     formal argument list (lambda list) (quoted)<br>
            <i>expr</i>  -    expressions constituting the body of the<br>
                        function (quoted)
            returns   -  the function symbol<br>

<br><dt>        <code>gensym([<i>tag</i>])</code> [SAL]<br>
        <code>(gensym<a name="index1380"> [<tt><i>tag</i></tt>])</code> [LISP]  - generate a symbol

<dd>
            <i>tag</i>   -    string or number<br>
            returns   -  the new symbol<br>

<br><dt><code>intern(<i>pname</i>)</code> [SAL]<br>
        <code>(intern<a name="index1381"> <tt><i>pname</i></tt>)</code> [LISP]  - make an interned symbol

<dd>
            <i>pname</i> -    the symbol's print name string<br>
            returns   -  the new symbol<br>

<br><dt>        <code>make-symbol(<i>pname</i>)</code> [SAL]<br>
        <code>(make-symbol<a name="index1382"> <tt><i>pname</i></tt>)</code> [LISP]  - make an uninterned symbol

<dd>
            <i>pname</i> -    the symbol's print name string<br>
            returns   -  the new symbol<br>

<br><dt>        <code>symbol-name(<i>sym</i>)</code> [SAL]<br>
        <code>(symbol-name<a name="index1383"> <tt><i>sym</i></tt>)</code> [LISP]  - get the print name of a symbol

<dd>
            <i>sym</i>   -    the symbol<br>
            returns   -  the symbol's print name<br>

<br><dt>    <code>symbol-value(<i>sym</i>)</code> [SAL]<br>
        <code>(symbol-value<a name="index1384"> <tt><i>sym</i></tt>)</code> [LISP]  - get the value of a symbol

<dd>
            <i>sym</i>   -    the symbol<br>
            returns   -  the symbol's value<br>

<br><dt>        <code>symbol-function(<i>sym</i>)</code> [SAL]<br>
        <code>(symbol-function<a name="index1385"> <tt><i>sym</i></tt>)</code> [LISP]  - get the functional value of a symbol

<dd>
            <i>sym</i>   -    the symbol<br>
            returns   -  the symbol's functional value<br>

<br><dt>        <code>symbol-plist(<i>sym</i>)</code> [SAL]<br>
        <code>(symbol-plist<a name="index1386"> <tt><i>sym</i></tt>)</code> [LISP]  - get the property list of a symbol

<dd>
            <i>sym</i>   -    the symbol<br>
            returns   -  the symbol's property list<br>

<br><dt>        <code>hash(<i>sym</i>, <i>n</i>)</code> [SAL]<br>
        <code>(hash<a name="index1387"> <tt><i>sym</i></tt> <tt><i>n</i></tt>)</code> [LISP]  - compute the hash index for a symbol

<dd>
            <i>sym</i>   -    the symbol or string<br>
            <i>n</i>     -    the table size (integer)<br>
            returns   -  the hash index (integer)<br>

<br><dt>
</dl><a name = "227"><h3>Property List Functions</h3></a><a name="index1388">
<dl>
<dt>
        <code>get(<i>sym</i>, <i>prop</i>)</code> [SAL]<br>
        <code>(get<a name="index1389"> <tt><i>sym</i></tt> <tt><i>prop</i></tt>)</code> [LISP]  - get the value of a property

<dd>
            <i>sym</i>   -    the symbol<br>
            <i>prop</i>  -    the property symbol<br>
            returns   -  the property value or <code>nil</code><br>

<br><dt>        <code>putprop(<i>sym</i>, <i>val</i>, <i>prop</i>)</code> [SAL]<br>
        <code>(putprop<a name="index1390"> <tt><i>sym</i></tt> <tt><i>val</i></tt> <tt><i>prop</i></tt>)</code> [LISP]  - put a property onto a property list

<dd>
            <i>sym</i>   -    the symbol<br>
            <i>val</i>   -    the property value<br>
            <i>prop</i>  -    the property symbol<br>
            returns   -  the property value<br>

<br><dt>        <code>remprop(<i>sym</i>, <i>prop</i>)</code> [SAL]<br>
        <code>(remprop<a name="index1391"> <tt><i>sym</i></tt> <tt><i>prop</i></tt>)</code> [LISP]  - remove a property

<dd>
            <i>sym</i>   -    the symbol<br>
            <i>prop</i>  -    the property symbol<br>
            returns   -  <code>nil</code><br>

<br><dt>
</dl><a name = "228"><h3>Array Functions</h3></a><a name="index1392">
<dl>
<dt>
        <code>aref(<i>array</i>, <i>n</i>)</code> [SAL]<br>
        <code>(aref<a name="index1393"> <tt><i>array</i></tt> <tt><i>n</i></tt>)</code> [LISP]  - get the nth element of an array

<dd>
            <i>array</i> -    the array<br>
            <i>n</i>     -    the array index (integer)<br>
            returns   -  the value of the array element<br>

<br><dt>        <code>make-array(<i>size</i>)</code> [SAL]<br>
        <code>(make-array<a name="index1394"> <tt><i>size</i></tt>)</code> [LISP]  - make a new array

<dd>
            <i>size</i>  -    the size of the new array (integer)<br>
            returns   -  the new array<br>

<br><dt>        <code>vector(<i>expr</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(vector<a name="index1395"> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - make an initialized vector

<dd>
            <i>expr</i>  -    the vector elements<br>
            returns   -  the new vector<br>

<br><dt>
</dl><a name = "229"><h3>List Functions</h3></a><a name="index1396">
<dl>
<dt>
        <code>car(<i>expr</i>)</code> [SAL]<br>
        <code>(car<a name="index1397"> <tt><i>expr</i></tt>)</code> [LISP] -  return the car of a list node

<dd>
            <i>expr</i>  -    the list node<br>
            returns   -  the car of the list node<br>

<br><dt>        <code>cdr(<i>expr</i>)</code> [SAL]<br>
        <code>(cdr<a name="index1398"> <tt><i>expr</i></tt>)</code> [LISP]  - return the cdr of a list node

<dd>
            <i>expr</i>  -    the list node<br>
            returns   -  the cdr of the list node<br>

<br><dt>        <code>c<i>xx</i>r(<i>expr</i>)</code> [SAL]<br>
        <code>(c<i>xx</i>r<a name="index1399"> <tt><i>expr</i></tt>)</code> [LISP]  - all c<i>xx</i>r combinations

<dd>

<br>
<br><dt>        <code>c<i>xxx</i>r(<i>expr</i>)</code> [SAL]<br>
        <code>(c<i>xxx</i>r<a name="index1400"> <tt><i>expr</i></tt>)</code> [LISP]  - all c<i>xxx</i>r combinations

<dd>

<br>
<br><dt>        <code>c<i>xxxx</i>r(<i>expr</i>)</code> [SAL]<br>
        <code>(c<i>xxxx</i>r<a name="index1401"> <tt><i>expr</i></tt>)</code> [LISP]  - all c<i>xxxx</i>r combinations

<dd>

<br>
<br><dt>        <code>first(<i>expr</i>)</code> [SAL]<br>
        <code>(first<a name="index1402"> <tt><i>expr</i></tt>)</code> [LISP]  -  a synonym for car

<dd>

<br>
<br><dt>        <code>second(<i>expr</i>)</code> [SAL]<br>
        <code>(second<a name="index1403"> <tt><i>expr</i></tt>)</code> [LISP]  - a synonym for cadr

<dd>

<br>
<br><dt>        <code>third(<i>expr</i>)</code> [SAL]<br>
        <code>(third<a name="index1404"> <tt><i>expr</i></tt>)</code> [LISP]  -  a synonym for caddr

<dd>

<br>
<br><dt>        <code>fourth(<i>expr</i>)</code> [SAL]<br>
        <code>(fourth<a name="index1405"> <tt><i>expr</i></tt>)</code> [LISP]  - a synonym for cadddr

<dd>

<br>
<br><dt>        <code>rest(<i>expr</i>)</code> [SAL]<br>
        <code>(rest<a name="index1406"> <tt><i>expr</i></tt>)</code> [LISP]  -   a synonym for cdr

<dd>

<br>
<br><dt>        <code>cons(<i>expr1</i>, <i>expr2</i>)</code> [SAL]<br>
        <code>(cons<a name="index1407"> <tt><i>expr1</i></tt> <tt><i>expr2</i></tt>)</code> [LISP]  - construct a new list node

<dd>
            <i>expr1</i> -    the car of the new list node<br>
            <i>expr2</i> -    the cdr of the new list node<br>
            returns   -  the new list node<br>

<br><dt>        <code>list(<i>expr</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(list<a name="index1408"> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - create a list of values

<dd>
            <i>expr</i>  -    expressions to be combined into a list<br>
            returns   -  the new list<br>

<br><dt>        <code>append(<i>expr</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(append<a name="index1409"> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - append lists

<dd>
            <i>expr</i>  -    lists whose elements are to be appended<br>
            returns   -  the new list<br>

<br><dt>        <code>reverse(<i>expr</i>)</code> [SAL]<br>
        <code>(reverse<a name="index1410"> <tt><i>expr</i></tt>)</code> [LISP]  - reverse a list

<dd>
            <i>expr</i>  -    the list to reverse<br>
            returns   -  a new list in the reverse order<br>

<br><dt>        <code>last(<i>list</i>)</code> [SAL]<br>
        <code>(last<a name="index1411"> <tt><i>list</i></tt>)</code> [LISP]  - return the last list node of a list

<dd>
            <i>list</i>  -    the list<br>
            returns   -  the last list node in the list<br>

<br><dt>        <code>member(<i>expr</i>, <i>list</i>, test: <i>test</i>, test-not: <i>test-not</i>)</code> [SAL]<br>
        <code>(member<a name="index1412"> <tt><i>expr</i></tt> <tt><i>list</i></tt> <tt>&amp;key </tt><tt>:test</tt> <tt>:test-not</tt>)</code> [LISP]  - find an expression in a list

<dd>
            <i>expr</i>  -    the expression to find<br>
            <i>list</i>  -    the list to search<br>
            :test     -  the test function (defaults to eql)<br>
            :test-not -  the test function (sense inverted)      <br>
            returns   -  the remainder of the list starting with the expression<br>

<br><dt>        <code>assoc(<i>expr</i>, <i>alist</i>, test: <i>test</i>, test-not: <i>test-not</i>)</code> [SAL]<br>
        <code>(assoc<a name="index1413"> <tt><i>expr</i></tt> <tt><i>alist</i></tt> <tt>&amp;key </tt><tt>:test</tt> <tt>:test-not</tt>)</code> [LISP]  - find an expression in an a-list

<dd>
            <i>expr</i>  -    the expression to find<br>
            <i>alist</i> -    the association list<br>
            :test     -  the test function (defaults to eql)<br>
            :test-not -  the test function (sense inverted)      <br>
            returns   -  the alist entry or <code>nil</code><br>

<br><dt>        <code>remove(<i>expr</i>, <i>list</i>, test: <i>test</i>, test-not: <i>test-not</i>)</code> [SAL]<br>
        <code>(remove<a name="index1414"> <tt><i>expr</i></tt> <tt><i>list</i></tt> <tt>&amp;key </tt><tt>:test</tt> <tt>:test-not</tt>)</code> [LISP]  - remove elements from a list

<dd>
            <i>expr</i>  -    the element to remove<br>
            <i>list</i>  -    the list<br>
            :test     -  the test function (defaults to eql)<br>
            :test-not -  the test function (sense inverted)      <br>
            returns   -  copy of list with matching expressions removed<br>

<br><dt>        <code>remove-if(<i>test</i>, <i>list</i>)</code> [SAL]<br>
        <code>(remove-if<a name="index1415"> <tt><i>test</i></tt> <tt><i>list</i></tt>)</code> [LISP]  - remove elements that pass test

<dd>
            <i>test</i>  -    the test predicate<br>
            <i>list</i>  -    the list<br>
            returns   -  copy of list with matching elements removed<br>

<br><dt>        <code>remove-if-not(<i>test</i>, <i>list</i>)</code> [SAL]<br>
        <code>(remove-if-not<a name="index1416"> <tt><i>test</i></tt> <tt><i>list</i></tt>)</code> [LISP]  - remove elements that fail test

<dd>
            <i>test</i>  -    the test predicate<br>
            <i>list</i>  -    the list<br>
            returns   -  copy of list with non-matching elements removed<br>

<br><dt>        <code>length(<i>expr</i>)</code> [SAL]<br>
        <code>(length<a name="index1417"> <tt><i>expr</i></tt>)</code> [LISP]  - find the length of a list, vector or string

<dd>
            <i>expr</i>  -    the list, vector or string<br>
            returns   -  the length of the list, vector or string<br>

<br><dt>        <code>nth(<i>n</i>, <i>list</i>)</code> [SAL]<br>
        <code>(nth<a name="index1418"> <tt><i>n</i></tt> <tt><i>list</i></tt>)</code> [LISP]  - return the nth element of a list

<dd>
            <i>n</i>     -    the number of the element to return (zero origin)<br>
            <i>list</i>  -    the list<br>
            returns   -  the nth element or <code>nil</code> if the list isn't that long<br>

<br><dt>        <code>nthcdr(<i>n</i>, <i>list</i>)</code> [SAL]<br>
        <code>(nthcdr<a name="index1419"> <tt><i>n</i></tt> <tt><i>list</i></tt>)</code> [LISP]  - return the nth cdr of a list

<dd>
            <i>n</i>     -    the number of the element to return (zero origin)<br>
            <i>list</i>  -    the list<br>
            returns   -  the nth cdr or <code>nil</code> if the list isn't that long<br>

<br><dt>        <code>mapc(<i>fcn</i>, <i>list1</i>, <i>list</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(mapc<a name="index1420"> <tt><i>fcn</i></tt> <tt><i>list1</i></tt> <tt><i>list</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - apply function to successive cars

<dd>
            <i>fcn</i>   -    the function or function name<br>
            <i>listn</i> -    a list for each argument of the function<br>
            returns   -  the first list of arguments<br>

<br><dt>        <code>mapcar(<i>fcn</i>, <i>list1</i>, <i>list</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(mapcar<a name="index1421"> <tt><i>fcn</i></tt> <tt><i>list1</i></tt> <tt><i>list</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - apply function to successive cars

<dd>
            <i>fcn</i>   -    the function or function name<br>
            <i>listn</i> -    a list for each argument of the function<br>
            returns   -  a list of the values returned<br>

<br><dt>        <code>mapl(<i>fcn</i>, <i>list1</i>, <i>list</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(mapl<a name="index1422"> <tt><i>fcn</i></tt> <tt><i>list1</i></tt> <tt><i>list</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - apply function to successive cdrs

<dd>
            <i>fcn</i>   -    the function or function name<br>
            <i>listn</i> -    a list for each argument of the function<br>
            returns   -  the first list of arguments<br>

<br><dt>        <code>maplist(<i>fcn</i>, <i>list1</i>, <i>list</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(maplist<a name="index1423"> <tt><i>fcn</i></tt> <tt><i>list1</i></tt> <tt><i>list</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - apply function to successive cdrs

<dd>
            <i>fcn</i>   -    the function or function name<br>
            <i>listn</i> -    a list for each argument of the function<br>
            returns   -  a list of the values returned<br>

<br><dt>       <code>subst(<i>to</i>, <i>from</i>, <i>expr</i>, test: <i>test</i>, test-not: <i>test-not</i>)</code> [SAL]<br>
        <code>(subst<a name="index1424"> <tt><i>to</i></tt> <tt><i>from</i></tt> <tt><i>expr</i></tt> <tt>&amp;key </tt><tt>:test</tt> <tt>:test-not</tt>)</code> [LISP]  - substitute expressions

<dd>
            <i>to</i>    -    the new expression<br>
            <i>from</i>  -    the old expression<br>
            <i>expr</i>  -    the expression in which to do the substitutions<br>
            :test     -  the test function (defaults to eql)<br>
            :test-not -  the test function (sense inverted)      <br>
            returns   -  the expression with substitutions<br>

<br><dt>        <code>sublis(<i>alist</i>, <i>expr</i>, test: <i>test</i>, test-not: <i>test-not</i>)</code> [SAL]<br>
        <code>(sublis<a name="index1425"> <tt><i>alist</i></tt> <tt><i>expr</i></tt> <tt>&amp;key </tt><tt>:test</tt> <tt>:test-not</tt>)</code> [LISP]  - substitute with an a-list

<dd>
            <i>alist</i> -    the association list<br>
            <i>expr</i>  -    the expression in which to do the substitutions<br>
            :test     -  the test function (defaults to eql)<br>
            :test-not -  the test function (sense inverted)      <br>
            returns   -  the expression with substitutions<br>

<br><dt>
</dl><a name = "230"><h3>Destructive List Functions</h3></a><a name="index1426">
<dl>
<dt>
        <code>rplaca(<i>list</i>, <i>expr</i>)</code> [SAL]<br>
        <code>(rplaca<a name="index1427"> <tt><i>list</i></tt> <tt><i>expr</i></tt>)</code> [LISP]  - replace the car of a list node

<dd>
            <i>list</i> -     the list node<br>
            <i>expr</i> -     the new value for the car of the list node<br>
            returns  -   the list node after updating the car<br>

<br><dt>        <code>rplacd(<i>list</i>, <i>expr</i>)</code> [SAL]<br>
        <code>(rplacd<a name="index1428"> <tt><i>list</i></tt> <tt><i>expr</i></tt>)</code> [LISP]  - replace the cdr of a list node

<dd>
            <i>list</i> -     the list node<br>
            <i>expr</i> -     the new value for the cdr of the list node<br>
            returns  -   the list node after updating the cdr<br>

<br><dt>        <code>nconc(<i>list</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(nconc<a name="index1429"> <tt><i>list</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - destructively concatenate lists

<dd>
            <i>list</i> -     lists to concatenate<br>
            returns  -   the result of concatenating the lists<br>

<br><dt>        <code>delete(<i>expr</i>, test: <i>test</i>, test-not: <i>test-not</i>)</code> [SAL]<br>
        <code>(delete<a name="index1430"> <tt><i>expr</i></tt> <tt>&amp;key </tt><tt>:test</tt> <tt>:test-not</tt>)</code> [LISP]  - delete elements from a list

<dd>
            <i>expr</i> -     the element to delete<br>
            <i>list</i> -     the list<br>
            :test    -   the test function (defaults to eql)<br>
            :test-not -   the test function (sense inverted)      <br>
            returns   -  the list with the matching expressions deleted<br>

<br><dt>        <code>delete-if(<i>test</i>, <i>list</i>)</code> [SAL]<br>
        <code>(delete-if<a name="index1431"> <tt><i>test</i></tt> <tt><i>list</i></tt>)</code> [LISP]  - delete elements that pass test

<dd>
            <i>test</i>  -    the test predicate<br>
            <i>list</i>  -    the list<br>
            returns   -  the list with matching elements deleted<br>

<br><dt>        <code>delete-if-not(<i>test</i>, <i>list</i>)</code> [SAL]<br>
        <code>(delete-if-not<a name="index1432"> <tt><i>test</i></tt> <tt><i>list</i></tt>)</code> [LISP]  - delete elements that fail test

<dd>
            <i>test</i>  -    the test predicate<br>
            <i>list</i>  -    the list<br>
            returns   -  the list with non-matching elements deleted<br>

<br><dt>        <code>sort(<i>list</i>, <i>test</i>)</code> [SAL]<br>
        <code>(sort<a name="index1433"> <tt><i>list</i></tt> <tt><i>test</i></tt>)</code> [LISP]  - sort a list

<dd>
            <i>list</i>  -    the list to sort<br>
            <i>test</i>  -    the comparison function<br>
            returns   -  the sorted list<br>

<br><dt>
</dl><a name = "231"><h3>Predicate Functions</h3></a><a name="index1434">
<dl>
<dt>
	<code>atom(<i>expr</i>)</code> [SAL]<br>
        <code>(atom<a name="index1435"> <tt><i>expr</i></tt>)</code> [LISP]  - is this an atom?

<dd>
            <i>expr</i>  -    the expression to check<br>
            returns   - <code>t</code> if the value is an atom, <code>nil</code> otherwise<br>

<br><dt>        <code>symbolp(<i>expr</i>)</code> [SAL]<br>
        <code>(symbolp<a name="index1436"> <tt><i>expr</i></tt>)</code> [LISP]  - is this a symbol?

<dd>
            <i>expr</i>  -    the expression to check<br>
            returns   - <code>t</code> if the expression is a symbol, <code>nil</code> otherwise<br>

<br><dt>        <code>numberp(<i>expr</i>)</code> [SAL]<br>
        <code>(numberp<a name="index1437"> <tt><i>expr</i></tt>)</code> [LISP]  - is this a number?

<dd>
            <i>expr</i>  -    the expression to check<br>
            returns   - <code>t</code> if the expression is a number, <code>nil</code> otherwise<br>

<br><dt>        <code>null(<i>expr</i>)</code> [SAL]<br>
        <code>(null<a name="index1438"> <tt><i>expr</i></tt>)</code> [LISP]  - is this an empty list?

<dd>
            <i>expr</i>  -    the list to check<br>
            returns   - <code>t</code> if the list is empty, <code>nil</code> otherwise<br>

<br><dt>        <code>not(<i>expr</i>)</code> [SAL]<br>
        <code>(not<a name="index1439"> <tt><i>expr</i></tt>)</code> [LISP]  - is this false?

<dd>
            <i>expr</i>  -    the expression to check<br>
            return    - <code>t</code> if the value is <code>nil</code>, <code>nil</code> otherwise<br>

<br><dt>        <code>listp(<i>expr</i>)</code> [SAL]<br>
        <code>(listp<a name="index1440"> <tt><i>expr</i></tt>)</code> [LISP]  - is this a list?

<dd>
            <i>expr</i>  -    the expression to check<br>
            returns   - <code>t</code> if the value is a cons or <code>nil</code>, <code>nil</code> otherwise<br>

<br><dt>        <code>endp(<i>list</i>)</code> [SAL]<br>
        <code>(endp<a name="index1441"> <tt><i>list</i></tt>)</code> [LISP]  - is this the end of a list

<dd>
            <i>list</i>  -    the list<br>
            returns   - <code>t</code> if the value is <code>nil</code>, <code>nil</code> otherwise<br>

<br><dt>        <code>consp(<i>expr</i>)</code> [SAL]<br>
        <code>(consp<a name="index1442"> <tt><i>expr</i></tt>)</code> [LISP]  - is this a non-empty list?

<dd>
            <i>expr</i>  -    the expression to check<br>
            returns   - <code>t</code> if the value is a cons, <code>nil</code> otherwise<br>

<br><dt>        <code>integerp(<i>expr</i>)</code> [SAL]<br>
        <code>(integerp<a name="index1443"> <tt><i>expr</i></tt>)</code> [LISP]  - is this an integer?

<dd>
            <i>expr</i>  -    the expression to check<br>
            returns   - <code>t</code> if the value is an integer, <code>nil</code> otherwise<br>

<br><dt>        <code>floatp(<i>expr</i>)</code> [SAL]<br>
        <code>(floatp<a name="index1444"> <tt><i>expr</i></tt>)</code> [LISP]  - is this a float?

<dd>
            <i>expr</i>  -    the expression to check<br>
            returns   - <code>t</code> if the value is a float, <code>nil</code> otherwise<br>

<br><dt>        <code>stringp(<i>expr</i>)</code> [SAL]<br>
        <code>(stringp<a name="index1445"> <tt><i>expr</i></tt>)</code> [LISP]  - is this a string?

<dd>
            <i>expr</i>  -    the expression to check<br>
            returns   - <code>t</code> if the value is a string, <code>nil</code> otherwise<br>

<br><dt>        <code>characterp(<i>expr</i>)</code> [SAL]<br>
        <code>(characterp<a name="index1446"> <tt><i>expr</i></tt>)</code> [LISP]  - is this a character?

<dd>
            <i>expr</i>  -    the expression to check<br>
            returns   - <code>t</code> if the value is a character, <code>nil</code> otherwise<br>

<br><dt>        <code>arrayp(<i>expr</i>)</code> [SAL]<br>
        <code>(arrayp<a name="index1447"> <tt><i>expr</i></tt>)</code> [LISP]  - is this an array?

<dd>
            <i>expr</i>  -    the expression to check<br>
            returns   - <code>t</code> if the value is an array, <code>nil</code> otherwise<br>

<br><dt>        <code>streamp(<i>expr</i>)</code> [SAL]<br>
        <code>(streamp<a name="index1448"> <tt><i>expr</i></tt>)</code> [LISP]  - is this a stream?

<dd>
            <i>expr</i>  -    the expression to check<br>
            returns   - <code>t</code> if the value is a stream, <code>nil</code> otherwise<br>

<br><dt>        <code>objectp(<i>expr</i>)</code> [SAL]<br>
        <code>(objectp<a name="index1449"> <tt><i>expr</i></tt>)</code> [LISP]  - is this an object?

<dd>
            <i>expr</i>  -    the expression to check<br>
            returns   - <code>t</code> if the value is an object, <code>nil</code> otherwise<br>

<br><dt>        <code>filep(<i>expr</i>)</code> [SAL]<br>
        <code>(filep<a name="index1450"> <tt><i>expr</i></tt>)</code> [LISP] <a href = "foot.html#foot5">(Footnote 5)</a>   - is this a file? 

<dd>
            <i>expr</i>  -    the expression to check<br>
            returns   - <code>t</code> if the value is an object, <code>nil</code> otherwise<br>

<br><dt>        <code>boundp(<i>sym</i>)</code> [SAL]<br>
        <code>(boundp<a name="index1451"> <tt><i>sym</i></tt>)</code> [LISP]  - is a value bound to this symbol?

<dd>
            <i>sym</i>   -    the symbol<br>
            returns   - <code>t</code> if a value is bound to the symbol, <code>nil</code> otherwise<br>

<br><dt>        <code>fboundp(<i>sym</i>)</code> [SAL]<br>
        <code>(fboundp<a name="index1452"> <tt><i>sym</i></tt>)</code> [LISP]  - is a functional value bound to this symbol?

<dd>
            <i>sym</i>   -    the symbol<br>
            returns   - <code>t</code> if a functional value is bound to the symbol,<br>
                        <code>nil</code> otherwise

<br>
<br><dt>        <code>minusp(<i>expr</i>)</code> [SAL]<br>
        <code>(minusp<a name="index1453"> <tt><i>expr</i></tt>)</code> [LISP]  - is this number negative?

<dd>
            <i>expr</i>  -    the number to test<br>
            returns   - <code>t</code> if the number is negative, <code>nil</code> otherwise<br>

<br><dt>        <code>zerop(<i>expr</i>)</code> [SAL]<br>
        <code>(zerop<a name="index1454"> <tt><i>expr</i></tt>)</code> [LISP]  - is this number zero?

<dd>
            <i>expr</i>  -    the number to test<br>
            returns   - <code>t</code> if the number is zero, <code>nil</code> otherwise<br>

<br><dt>        <code>plusp(<i>expr</i>)</code> [SAL]<br>
        <code>(plusp<a name="index1455"> <tt><i>expr</i></tt>)</code> [LISP]  - is this number positive?

<dd>
            <i>expr</i>  -    the number to test<br>
            returns   - <code>t</code> if the number is positive, <code>nil</code> otherwise<br>

<br><dt>        <code>evenp(<i>expr</i>)</code> [SAL]<br>
        <code>(evenp<a name="index1456"> <tt><i>expr</i></tt>)</code> [LISP]  - is this integer even?

<dd>
            <i>expr</i>  -    the integer to test<br>
            returns   - <code>t</code> if the integer is even, <code>nil</code> otherwise<br>

<br><dt>        <code>oddp(<i>expr</i>)</code> [SAL]<br>
        <code>(oddp<a name="index1457"> <tt><i>expr</i></tt>)</code> [LISP]  - is this integer odd?

<dd>
            <i>expr</i>  -    the integer to test<br>
            returns   - <code>t</code> if the integer is odd, <code>nil</code> otherwise<br>

<br><dt>        <code>eq(<i>expr1</i>, <i>expr2</i>)</code> [SAL]<br>
        <code>(eq<a name="index1458"> <tt><i>expr1</i></tt> <tt><i>expr2</i></tt>)</code> [LISP]  - are the expressions identical?

<dd>
            <i>expr1</i> -    the first expression<br>
            <i>expr2</i> -    the second expression<br>
            returns   - <code>t</code> if they are equal, <code>nil</code> otherwise<br>

<br><dt><code>eql(<i>expr1</i>, <i>expr2</i>)</code> [SAL]<br>
        <code>(eql<a name="index1459"> <tt><i>expr1</i></tt> <tt><i>expr2</i></tt>)</code> [LISP]  - are the expressions identical? (works with all numbers)

<dd>
            <i>expr1</i> -    the first expression<br>
            <i>expr2</i> -    the second expression<br>
            returns   - <code>t</code> if they are equal, <code>nil</code> otherwise<br>

<br><dt>        <code>equal(<i>expr1</i>, <i>expr2</i>)</code> [SAL]<br>
        <code>(equal<a name="index1460"> <tt><i>expr1</i></tt> <tt><i>expr2</i></tt>)</code> [LISP]  - are the expressions equal?

<dd>
            <i>expr1</i> -    the first expression<br>
            <i>expr2</i> -    the second expression<br>
            returns   - <code>t</code> if they are equal, <code>nil</code> otherwise<br>

<br><dt>
</dl><a name = "232"><h3>Control Constructs</h3></a><a name="index1461">
<dl>
<dt>
        <code>(cond<a name="index1462"> <tt><i>pair</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - evaluate conditionally
<dd>
            <i>pair</i>  -    pair consisting of:<br>
<dl><dd>
                            (<i>pred</i> <i>expr</i>...)
</dl>
                          where:
<dl><dd>
                            <i>pred</i> -     is a predicate expression<br>
                            <i>expr</i> -     evaluated if the predicate
 is not <code>nil</code>
</dl>
returns  -   the value of the first expression whose predicate is not
<code>nil</code>

<br>
<br><dt>        <code>and(<i>expr</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(and<a name="index1463"> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - the logical and of a list of expressions

<dd>
            <i>expr</i> -     the expressions to be anded<br>
            returns  -   <code>nil</code> if any expression evaluates to <code>nil</code>,
                        otherwise the value of the last expression
                        (evaluation of expressions stops after the first
                         expression that evaluates to <code>nil</code>)

<br>
<br><dt>        <code>or(<i>expr</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(or<a name="index1464"> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - the logical or of a list of expressions

<dd>
            <i>expr</i> -     the expressions to be ored<br>
            returns  -   <code>nil</code> if all expressions evaluate to <code>nil</code>,
                  otherwise the value of the first non-<code>nil</code> expression
                        (evaluation of expressions stops after the first
                         expression that does not evaluate to <code>nil</code>)

<br>
<br><dt>        <code>if(<i>texpr</i>, <i>expr1</i> [, <i>expr2</i>])</code> [SAL]<br>
        <code>(if<a name="index1465"> <tt><i>texpr</i></tt> <tt><i>expr1</i></tt> [<tt><i>expr2</i></tt>])</code> [LISP]  - evaluate expressions conditionally

<dd>
            <i>texpr</i> -    the test expression<br>
            <i>expr1</i> -    the expression to be evaluated if texpr is non-<code>nil</code><br>
            <i>expr2</i> -    the expression to be evaluated if texpr is <code>nil</code><br>
            returns   -  the value of the selected expression<br>

<br><dt>        <code>when(<i>texpr</i>, <i>expr</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(when<a name="index1466"> <tt><i>texpr</i></tt> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - evaluate only when a condition is true

<dd>
            <i>texpr</i> -    the test expression<br>
            <i>expr</i>  -    the expression(s) to be evaluated if texpr is non-<code>nil</code><br>
            returns - the value of the last expression or <code>nil</code>

<br>
<br><dt>        <code>unless(<i>texpr</i>, <i>expr</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(unless<a name="index1467"> <tt><i>texpr</i></tt> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - evaluate only when a condition is false

<dd>
            <i>texpr</i> -    the test expression<br>
            <i>expr</i>  -    the expression(s) to be evaluated if texpr is <code>nil</code><br>
            returns   -  the value of the last expression or <code>nil</code><br>

<br><dt>          <code>(case<a name="index1468"> <tt><i>expr</i></tt> <tt><i>case</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - select by case
<dd>
            <i>expr</i>  -    the selection expression<br>
            <i>case</i>  -    pair consisting of:<br>
<dl><dd>
                            (<i>value</i> <i>expr</i>...)
</dl>
                          where:
<dl><dd>
                            <i>value</i> -     is a single expression or a list of
                                        expressions (unevaluated)<br>
                            <i>expr</i>  -    are expressions to execute if the
                                        case matches
</dl>
            returns -     the value of the last expression of the matching case<br>

<br><dt>

       <code>(let<a name="index1469"> (<tt><i>binding</i></tt><span style="font-style:normal">...</span>) <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - create local bindings<br>

        <code>(let*<a name="index1470"> (<tt><i>binding</i></tt><span style="font-style:normal">...</span>) <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - let with sequential binding

<dd>
            <i>binding</i> -   the variable bindings each of which is either:<br>
<dl><dd>
                        1)  a symbol (which is initialized to <code>nil</code>)<br>
                        2)  a list whose car is a symbol and whose cadr
                                is an initialization expression
</dl>
            <i>expr</i> -     the expressions to be evaluated<br>
            returns  -   the value of the last expression<br>

<br><dt>

        <code>(flet<a name="index1471"> (<tt><i>binding</i></tt><span style="font-style:normal">...</span>) <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - create local functions<br>

        <code>(labels<a name="index1472"> (<tt><i>binding</i></tt><span style="font-style:normal">...</span>) <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP] -  flet with recursive functions<br>

        <code>(macrolet<a name="index1473"> (<tt><i>binding</i></tt><span style="font-style:normal">...</span>) <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP] -  create local macros

<dd>
            <i>binding</i> -  the function bindings each of which is:<br>
<dl><dd>
                          (<i>sym</i> <i>fargs</i> <i>expr</i>...)
</dl>
                        where:
<dl><dd>
                            <i>sym</i> -      the function/macro name<br>
                            <i>fargs</i> -     formal argument list (lambda list)<br>
                            <i>expr</i>  -    expressions constituting the body of
                                        the function/macro
</dl>
            <i>expr</i> -     the expressions to be evaluated<br>
            returns  -   the value of the last expression

<br>
<br><dt>        <code>catch(<i>sym</i>, <i>expr</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(catch<a name="index1474"> <tt><i>sym</i></tt> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - evaluate expressions and catch throws

<dd>
            <i>sym</i>  -     the catch tag<br>
            <i>expr</i> -     expressions to evaluate<br>
            returns  -   the value of the last expression the throw expression<br>

<br><dt>        <code>throw(<i>sym</i> [, <i>expr</i>])</code> [SAL]<br>
        <code>(throw<a name="index1475"> <tt><i>sym</i></tt> [<tt><i>expr</i></tt>])</code> [LISP]  - throw to a catch

<dd>
            <i>sym</i>  -     the catch tag<br>
            <i>expr</i> -     the value for the catch to return (defaults to <code>nil</code>)<br>
            returns  -   never returns<br>

<br><dt>        <code>unwind-protect(<i>expr</i>, <i>cexpr</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(unwind-protect<a name="index1476"> <tt><i>expr</i></tt> <tt><i>cexpr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - protect evaluation of an expression

<dd>
            <i>expr</i> -     the expression to protect<br>
            <i>cexpr</i> -     the cleanup expressions<br>
            returns   -  the value of the expression<br>
          Note:  unwind-protect guarantees to execute the cleanup expressions
                 even if a non-local exit terminates the evaluation of the
                 protected expression

<br>
<br><dt>
</dl>
<p>
<a name = "233"><h3>Looping Constructs</h3></a><a name="index1477">
<dl>
<dt>
        <code>(loop<a name="index1478"> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - basic looping form
<dd>
            <i>expr</i> -     the body of the loop<br>
            returns  -   never returns (must use non-local exit)<br>

<br><dt>

        <code>(do<a name="index1479"> (<tt><i>binding</i></tt><span style="font-style:normal">...</span>) (<tt><i>texpr</i></tt> <tt><i>rexpr</i></tt><span style="font-style:normal">...</span>) <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]

        <code>(do*<a name="index1480"> (<tt><i>binding</i></tt><span style="font-style:normal">...</span>) (<tt><i>texpr</i></tt> <tt><i>rexpr</i></tt><span style="font-style:normal">...</span>) <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]

<dd>
            <i>binding</i> -  the variable bindings each of which is either:<br>
<dl><dd>
                        1)  a symbol (which is initialized to <code>nil</code>)<br>
                        2)  a list of the form: (<i>sym</i> <i>init</i> [<i>step</i>])
                            where:
<dl><dd>
                                <i>sym</i> - is the symbol to bind<br>
                                <i>init</i> - is the initial value of the symbol<br>
                                <i>step</i> - is a step expression<br>
</dl>
</dl>
            <i>texpr</i> -    the termination test expression<br>
            <i>rexpr</i> -    result expressions (the default is <code>nil</code>)<br>
            <i>expr</i>  -    the body of the loop (treated like an implicit prog)<br>
            returns   -  the value of the last result expression<br>

<br><dt>    <code>(dolist<a name="index1481"> (<tt><i>sym</i></tt> <tt><i>expr</i></tt> [<tt><i>rexpr</i></tt>]) <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - loop through a list
<dd>
            <i>sym</i>   -    the symbol to bind to each list element<br>
            <i>expr</i>  -    the list expression<br>
            <i>rexpr</i> -    the result expression (the default is <code>nil</code>)<br>
            <i>expr</i>  -    the body of the loop (treated like an implicit prog)<br>

<br><dt>        <code>(dotimes<a name="index1482"> (<tt><i>sym</i></tt> <tt><i>expr</i></tt> [<tt><i>rexpr</i></tt>]) <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - loop from zero to n-1
<dd>
            <i>sym</i>   -    the symbol to bind to each value from 0 to n-1<br>
            <i>expr</i>  -    the number of times to loop<br>
            <i>rexpr</i> -    the result expression (the default is <code>nil</code>)<br>
            <i>expr</i>  -    the body of the loop (treated like an implicit prog)<br>

<br><dt>
</dl><a name = "234"><h3>The Program Feature</h3></a><a name="index1483">
<dl>
<dt>

<code>(prog<a name="index1484"> (<tt><i>binding</i></tt><span style="font-style:normal">...</span>) <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - the program feature<br>

<code>(prog*<a name="index1485"> (<tt><i>binding</i></tt><span style="font-style:normal">...</span>) <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - prog with sequential binding

<dd>
            <i>binding</i> -  the variable bindings each of which is either:<br>
<dl><dd>
                        1)  a symbol (which is initialized to <code>nil</code>)<br>
                        2)  a list whose car is a symbol and whose cadr
                                is an initialization expression
</dl>
            <i>expr</i>  -    expressions to evaluate or tags (symbols)<br>
            returns   -  <code>nil</code> or the argument passed to the return function<br>

<br><dt>        <code>block(<i>name</i>, <i>expr</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(block<a name="index1486"> <tt><i>name</i></tt> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - named block

<dd>
            <i>name</i>  -    the block name (symbol)<br>
            <i>expr</i>  -    the block body<br>
            returns   -  the value of the last expression<br>

<br><dt>        <code>(return<a name="index1487"> [<tt><i>expr</i></tt>])</code> [LISP]  - cause a prog construct to return a value
<dd>
            <i>expr</i>  -    the value (defaults to <code>nil</code>)<br>
            returns   -  never returns<br>

<br><dt>        <code>return-from(<i>name</i> [, <i>value</i>])</code> [SAL]<br>
        <code>(return-from<a name="index1488"> <tt><i>name</i></tt> [<tt><i>value</i></tt>])</code> [LISP]  - return from a named block

<dd>
            <i>name</i>  -    the block name (symbol)<br>
            <i>value</i> -    the value to return (defaults to <code>nil</code>)<br>
            returns   -  never returns<br>

<br><dt>        <code>tagbody(<i>expr</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(tagbody<a name="index1489"> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - block with labels

<dd>
            <i>expr</i>  -    expression(s) to evaluate or tags (symbols)<br>
            returns   -  <code>nil</code><br>

<br><dt>        <code>go(<i>sym</i>)</code> [SAL]<br>
        <code>(go<a name="index1490"> <tt><i>sym</i></tt>)</code> [LISP]  - go to a tag within a tagbody or prog

<dd>
            <i>sym</i>   -    the tag (quoted)<br>
            returns   -  never returns<br>

<br><dt>        <code>(progv<a name="index1491"> <tt><i>slist</i></tt> <tt><i>vlist</i></tt> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - dynamically bind symbols
<dd>
            <i>slist</i> -    list of symbols<br>
            <i>vlist</i> -    list of values to bind to the symbols<br>
            <i>expr</i>  -    expression(s) to evaluate<br>
            returns   -  the value of the last expression<br>

<br><dt>        <code>prog1(<i>expr1</i>, <i>expr</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(prog1<a name="index1492"> <tt><i>expr1</i></tt> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - execute expressions sequentially

<dd>
            <i>expr1</i> -    the first expression to evaluate<br>
            <i>expr</i>  -    the remaining expressions to evaluate<br>
            returns   -  the value of the first expression<br>

<br><dt>        <code>prog2(<i>expr1</i>, <i>expr2</i>, <i>expr</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(prog2<a name="index1493"> <tt><i>expr1</i></tt> <tt><i>expr2</i></tt> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - execute expressions sequentially

<dd>
            <i>expr1</i> -    the first expression to evaluate<br>
            <i>expr2</i> -    the second expression to evaluate<br>
            <i>expr</i>  -    the remaining expressions to evaluate<br>
            returns   -  the value of the second expression<br>

<br><dt>        <code>progn(<i>expr</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(progn<a name="index1494"> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - execute expressions sequentially

<dd>
            <i>expr</i>  -    the expressions to evaluate<br>
            returns   -  the value of the last expression (or <code>nil</code>)<br>

<br><dt>
</dl><a name = "235"><h3>Debugging and Error Handling</h3></a><a name="index1495"><a name="index1496">
<dl>
<dt>
        <code>trace(<i>sym</i>)</code> [SAL]<br>
        <code>(trace<a name="index1497"> <tt><i>sym</i></tt>)</code> [LISP]  - add a function to the trace list

<dd>
            <i>sym</i>   -    the function to add (quoted)<br>
            returns   -  the trace list<br>

<br><dt>        <code>untrace(<i>sym</i>)</code> [SAL]<br>
        <code>(untrace<a name="index1498"> <tt><i>sym</i></tt>)</code> [LISP]  - remove a function from the trace list

<dd>
            <i>sym</i>   -    the function to remove (quoted)<br>
            returns   -  the trace list<br>

<br><dt>        <code>error(<i>emsg</i> [, <i>arg</i>])</code> [SAL]<br>
        <code>(error<a name="index1499"> <tt><i>emsg</i></tt> [<tt><i>arg</i></tt>])</code> [LISP]  - signal a non-correctable error

<dd>
            <i>emsg</i>  -    the error message string<br>
            <i>arg</i>   -    the argument expression (printed after the message)<br>
            returns   -  never returns<br>

<br><dt>        <code>cerror(<i>cmsg</i>, <i>emsg</i> [, <i>arg</i>])</code> [SAL]<br>
        <code>(cerror<a name="index1500"> <tt><i>cmsg</i></tt> <tt><i>emsg</i></tt> [<tt><i>arg</i></tt>])</code> [LISP]  - signal a correctable error

<dd>
            <i>cmsg</i>  -    the continue message string<br>
            <i>emsg</i>  -    the error message string<br>
            <i>arg</i>   -    the argument expression (printed after the message)<br>
            returns   -  <code>nil</code> when continued from the break loop<br>

<br><dt>        <code>break([<i>bmsg</i> [, <i>arg</i>]])</code> [SAL]<br>
        <code>(break<a name="index1501"> [<tt><i>bmsg</i></tt> [<tt><i>arg</i></tt>]])</code> [LISP]  - enter a break loop

<dd>
            <i>bmsg</i>  -    the break message string (defaults to <code>**break**</code>)<br>
            <i>arg</i>   -    the argument expression (printed after the message)<br>
            returns   -  <code>nil</code> when continued from the break loop<br>

<br><dt>        <code>(clean-up<a name="index1502">)</code> [LISP]  - clean-up after an error
<dd>
            returns   -  never returns<br>

<br><dt>        <code>(top-level<a name="index1503">)</code> [LISP]  - clean-up after an error and return to the top level
<dd>
            returns   -  never returns<br>

<br><dt>        <code>(continue<a name="index1504">)</code> [LISP]  - continue from a correctable error
<dd>
            returns   -  never returns<br>

<br><dt>        <code>(errset<a name="index1505"> <tt><i>expr</i></tt> [<tt><i>pflag</i></tt>])</code> [LISP]  - trap errors
<dd>
            <i>expr</i>  -    the expression to execute<br>
            <i>pflag</i> -    flag to control printing of the error message<br>
            returns   -  the value of the last expression consed with <code>nil</code><br>
                        or <code>nil</code> on error

<br>
<br><dt>        <code>(baktrace<a name="index1506"><a name="index1507"><a name="index1508"> [<tt><i>n</i></tt>])</code> [LISP]  - print n levels of trace back information
<dd>
            <i>n</i>     -    the number of levels (defaults to all levels)<br>
            returns   -  <code>nil</code><br>

<br><dt>        <code>(evalhook<a name="index1509"> <tt><i>expr</i></tt> <tt><i>ehook</i></tt> <tt><i>ahook</i></tt> [<tt><i>env</i></tt>])</code> [LISP]  - evaluate with hooks
<dd>
            <i>expr</i>  -    the expression to evaluate<br>
            <i>ehook</i> -    the value for <code>*evalhook*</code><br>
            <i>ahook</i> -    the value for <code>*applyhook*</code><br>
            <i>env</i>   -    the environment (default is <code>nil</code>)<br>
            returns   -  the result of evaluating the expression<br>

<br><dt>        <code>profile(<i>flag</i>)</code> [SAL]<br>
        <code>(profile<a name="index1510"> <tt><i>flag</i></tt>)</code> [LISP] <a href = "foot.html#foot6">(Footnote 6)</a>   - turn profiling on or off.

<dd>
            <i>flag</i>   -    <code>nil</code> turns profiling off, otherwise on<br>
            returns   -  the previous state of profiling.<br>

<br><dt>
</dl><a name = "236"><h3>Arithmetic Functions</h3></a><a name="index1511">
<dl>
<dt>
        <code>truncate(<i>expr</i>)</code> [SAL]<br>
        <code>(truncate<a name="index1512"> <tt><i>expr</i></tt>)</code> [LISP]  - truncates a floating point number to an integer

<dd>
            <i>expr</i>  -    the number<br>
            returns   -  the result of truncating the number<br>

<br><dt>        <code>float(<i>expr</i>)</code> [SAL]<br>
        <code>(float<a name="index1513"> <tt><i>expr</i></tt>)</code> [LISP]  - converts an integer to a floating point number

<dd>
            <i>expr</i>  -    the number<br>
            returns   -  the result of floating the integer<br>

<br><dt>        <code>(+<a name="index1514"> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - add a list of numbers
<dd>
            <i>expr</i>  -    the numbers<br>
            returns   -  the result of the addition<br>

<br><dt>        <code>(-<a name="index1515"> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - subtract a list of numbers or negate a single number
<dd>
            <i>expr</i>  -    the numbers<br>
            returns   -  the result of the subtraction<br>

<br><dt>        <code>(*<a name="index1516"> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - multiply a list of numbers
<dd>
            <i>expr</i>  -    the numbers<br>
            returns   -  the result of the multiplication<br>

<br><dt>        <code>(/<a name="index1517"> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - divide a list of numbers
<dd>
            <i>expr</i>  -    the numbers<br>
            returns   -  the result of the division<br>

<br><dt>        <code>(1+<a name="index1518"> <tt><i>expr</i></tt>)</code> [LISP]  - add one to a number
<dd>
            <i>expr</i>  -    the number<br>
            returns   -  the number plus one<br>

<br><dt>        <code>(1-<a name="index1519"> <tt><i>expr</i></tt>)</code> [LISP]  - subtract one from a number
<dd>
            <i>expr</i>  -    the number<br>
            returns   -  the number minus one<br>

<br><dt>        <code>rem(<i>expr</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(rem<a name="index1520"><a name="index1521"><a name="index1522"> function) <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - remainder of a list of numbers

<dd>
            <i>expr</i>  -    the numbers<br>
            returns   -  the result of the remainder operation<br>

<br><dt>        <code>min(<i>expr</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(min<a name="index1523"><a name="index1524"> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - the smallest of a list of numbers

<dd>
            <i>expr</i>  -    the expressions to be checked<br>
            returns   -  the smallest number in the list<br>

<br><dt>        <code>max(<i>expr</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(max<a name="index1525"><a name="index1526"> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - the largest of a list of numbers

<dd>
            <i>expr</i>  -    the expressions to be checked<br>
            returns   -  the largest number in the list<br>

<br><dt>        <code>abs(<i>expr</i>)</code> [SAL]<br>
        <code>(abs<a name="index1527"> <tt><i>expr</i></tt>)</code> [LISP]  - the absolute value of a number

<dd>
            <i>expr</i>  -    the number<br>
            returns   -  the absolute value of the number<br>

<br><dt>        <code>gcd(<i>n1</i>, <i>n2</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(gcd<a name="index1528"> <tt><i>n1</i></tt> <tt><i>n2</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - compute the greatest common divisor

<dd>
            <i>n1</i>    -    the first number (integer)<br>
            <i>n2</i>    -    the second number(s) (integer)<br>
            returns   -  the greatest common divisor<br>

<br><dt>       <code>random(<i>n</i>)</code> [SAL]<br>
        <code>(random<a name="index1529"> <tt><i>n</i></tt>)</code>
        [LISP]  - compute a random number between 0 and |n|-1
        inclusive. If n is 0, return 0.

<dd>
            <i>n</i>     -    the upper bound (integer)<br>
            returns   -  a random number<br>

<br><dt>       <code>rrandom()</code> [SAL]<br>
        <code>(rrandom<a name="index1530"><a name="index1531">)</code> [LISP]  - compute a random real number between 0 and 1 inclusive

<dd>
            returns   -  a random floating point number<br>

<br><dt>        <code>sin(<i>expr</i>)</code> [SAL]<br>
        <code>(sin<a name="index1532"> <tt><i>expr</i></tt>)</code> [LISP]  - compute the sine of a number

<dd>
            <i>expr</i>  -    the floating point number<br>
            returns   -  the sine of the number<br>

<br><dt>        <code>cos(<i>expr</i>)</code> [SAL]<br>
        <code>(cos<a name="index1533"> <tt><i>expr</i></tt>)</code> [LISP]  - compute the cosine of a number

<dd>
            <i>expr</i>  -    the floating point number<br>
            returns   -  the cosine of the number<br>

<br><dt>        <code>tan(<i>expr</i>)</code> [SAL]<br>
        <code>(tan<a name="index1534"> <tt><i>expr</i></tt>)</code> [LISP]  - compute the tangent of a number

<dd>
            <i>expr</i>  -    the floating point number<br>
            returns   -  the tangent of the number<br>

<br><dt>        <code>atan(<i>expr</i> [, <i>expr2</i>])</code> [SAL]<br>
        <code>(atan<a name="index1535"> <tt><i>expr</i></tt> [<tt><i>expr2</i></tt>])</code> [LISP] <a href = "foot.html#foot7">(Footnote 7)</a>   - compute the arctangent

<dd>
            <i>expr</i>  -    the value of <i>x</i><br>
            <i>expr2</i> -    the value of <i>y</i> (default value is 1.0)<br>
            returns   -  the arctangent of <i>x</i>/<i>y</i><br>

<br><dt>        <code>expt(<i>x-expr</i>, <i>y-expr</i>)</code> [SAL]<br>
        <code>(expt<a name="index1536"> <tt><i>x-expr</i></tt> <tt><i>y-expr</i></tt>)</code> [LISP]  - compute x to the y power

<dd>
            <i>x-expr</i> -    the floating point number<br>
            <i>y-expr</i> -   the floating point exponent<br>
            returns    - x to the y power<br>

<br><dt>        <code>exp(<i>x-expr</i>)</code> [SAL]<br>
        <code>(exp<a name="index1537"> <tt><i>x-expr</i></tt>)</code> [LISP]  - compute e to the x power

<dd>
            <i>x-expr</i> -   the floating point number<br>
            returns   -  e to the x power<br>

<br><dt>        <code>sqrt(<i>expr</i>)</code> [SAL]<br>
        <code>(sqrt<a name="index1538"> <tt><i>expr</i></tt>)</code> [LISP]  - compute the square root of a number

<dd>
            <i>expr</i>  -    the floating point number<br>
            returns   -  the square root of the number<br>

<br><dt>

<code>(&lt;<a name="index1539"> <tt><i>n1</i></tt> <tt><i>n2</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - test for less than<br>
<code>(&lt;=<a name="index1540"> <tt><i>n1</i></tt> <tt><i>n2</i></tt><span style="font-style:normal">...</span>)</code> [LISP] -  test for less than or equal to<br>
<code>(=<a name="index1541"> <tt><i>n1</i></tt> <tt><i>n2</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - test for equal to<br>
<code>(/=<a name="index1542"> <tt><i>n1</i></tt> <tt><i>n2</i></tt><span style="font-style:normal">...</span>)</code> [LISP] -  test for not equal to<br>
<code>(&gt;=<a name="index1543"> <tt><i>n1</i></tt> <tt><i>n2</i></tt><span style="font-style:normal">...</span>)</code> [LISP] -   test for greater than or equal to<br>
<code>(&gt;<a name="index1544"> <tt><i>n1</i></tt> <tt><i>n2</i></tt><span style="font-style:normal">...</span>)</code> [LISP] -   test for greater than

<dd>
            <i>n1</i>    -    the first number to compare<br>
            <i>n2</i>    -    the second number to compare<br>
returns   -  <code>t</code> if the results of comparing <i>n1</i> with <i>n2</i>,
<i>n2</i> with <i>n3</i>, etc., are all true.<br>

<br><dt>
</dl><a name = "237"><h3>Bitwise Logical Functions</h3></a><a name="index1545">
<dl>
<dt>
        <code>logand(<i>expr</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(logand<a name="index1546"> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP] -  the bitwise and of a list of numbers

<dd>
            <i>expr</i>  -    the numbers<br>
            returns   -  the result of the and operation<br>

<br><dt>        <code>logior(<i>expr</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(logior<a name="index1547"> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - the bitwise inclusive or of a list of numbers

<dd>
            <i>expr</i>  -    the numbers<br>
            returns   -  the result of the inclusive or operation<br>

<br><dt>        <code>logxor(<i>expr</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(logxor<a name="index1548"> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - the bitwise exclusive or of a list of numbers

<dd>
            <i>expr</i>  -    the numbers<br>
            returns   -  the result of the exclusive or operation<br>

<br><dt>        <code>lognot(<i>expr</i>)</code> [SAL]<br>
        <code>(lognot<a name="index1549"> <tt><i>expr</i></tt>)</code> [LISP]  - the bitwise not of a number

<dd>
            <i>expr</i>  -    the number<br>
            returns   -  the bitwise inversion of number<br>

<br><dt>
</dl><a name = "238"><h3>String Functions</h3></a><a name="index1550">
<dl>
<dt>
        <code>string(<i>expr</i>)</code> [SAL]<br>
        <code>(string<a name="index1551"> <tt><i>expr</i></tt>)</code> [LISP] -  make a string from a value

<dd>
            <i>expr</i>  -    an integer (which is first converted into its ASCII character value), string, character, or symbol<br>
            returns   -  the string representation of the argument<br>

<br><dt>        <code>string-search(<i>pat</i>, <i>str</i>, start: <i>start</i>, end: <i>end</i>)</code> [SAL]<br>
        <code>(string-search<a name="index1552"><a name="index1553"> <tt><i>pat</i></tt> <tt><i>str</i></tt> <tt>&amp;key </tt><tt>:start</tt> <tt>:end</tt>)</code> [LISP] <a href = "foot.html#foot8">(Footnote 8)</a>   - search for pattern in string

<dd>
            <i>pat</i>   -    a string to search for<br>
            <i>str</i>   -    the string to be searched<br>
            :start    -  the starting offset in str<br>
            :end      -  the ending offset + 1<br>
            returns   -  index of pat in str or NIL if not found<br>

<br><dt>        <code>string-trim(<i>bag</i>, <i>str</i>)</code> [SAL]<br>
        <code>(string-trim<a name="index1554"> <tt><i>bag</i></tt> <tt><i>str</i></tt>)</code> [LISP]  - trim both ends of a string

<dd>
            <i>bag</i>   -    a string containing characters to trim<br>
            <i>str</i>   -    the string to trim<br>
            returns   -  a trimed copy of the string<br>

<br><dt>        <code>string-left-trim(<i>bag</i>, <i>str</i>)</code> [SAL]<br>
        <code>(string-left-trim<a name="index1555"> <tt><i>bag</i></tt> <tt><i>str</i></tt>)</code> [LISP]  - trim the left end of a string

<dd>
            <i>bag</i>   -    a string containing characters to trim<br>
            <i>str</i>   -    the string to trim<br>
            returns   -  a trimed copy of the string<br>

<br><dt>        <code>string-right-trim(<i>bag</i>, <i>str</i>)</code> [SAL]<br>
        <code>(string-right-trim<a name="index1556"> <tt><i>bag</i></tt> <tt><i>str</i></tt>)</code> [LISP]  - trim the right end of a string

<dd>
            <i>bag</i>   -    a string containing characters to trim<br>
            <i>str</i>   -    the string to trim<br>
            returns   -  a trimed copy of the string<br>

<br><dt>        <code>string-upcase(<i>str</i>, start: <i>start</i>, end: <i>end</i>)</code> [SAL]<br>
        <code>(string-upcase<a name="index1557"> <tt><i>str</i></tt> <tt>&amp;key </tt><tt>:start</tt> <tt>:end</tt>)</code> [LISP]  - convert to uppercase

<dd>
            <i>str</i>   -    the string<br>
            :start    -  the starting offset<br>
            :end      -  the ending offset + 1<br>
            returns   -  a converted copy of the string<br>

<br><dt>        <code>string-downcase(<i>str</i>, start: <i>start</i>, end: <i>end</i>)</code> [SAL]<br>
        <code>(string-downcase<a name="index1558"> <tt><i>str</i></tt> <tt>&amp;key </tt><tt>:start</tt> <tt>:end</tt>)</code> [LISP]  - convert to lowercase

<dd>
            <i>str</i>   -    the string<br>
            :start    -  the starting offset<br>
            :end      -  the ending offset + 1<br>
            returns   -  a converted copy of the string<br>

<br><dt>        <code>nstring-upcase(<i>str</i>, start: <i>start</i>, end: <i>end</i>)</code> [SAL]<br>
        <code>(nstring-upcase<a name="index1559"> <tt><i>str</i></tt> <tt>&amp;key </tt><tt>:start</tt> <tt>:end</tt>)</code> [LISP]  - convert to uppercase

<dd>
            <i>str</i>   -    the string<br>
            :start    -  the starting offset<br>
            :end      -  the ending offset + 1<br>
            returns   -  the converted string (not a copy)<br>

<br><dt>        <code>nstring-downcase(<i>str</i>, start: <i>start</i>, end: <i>end</i>)</code> [SAL]<br>
        <code>(nstring-downcase<a name="index1560"> <tt><i>str</i></tt> <tt>&amp;key </tt><tt>:start</tt> <tt>:end</tt>)</code> [LISP]  - convert to lowercase

<dd>
            <i>str</i>   -    the string<br>
            :start    -  the starting offset<br>
            :end      -  the ending offset + 1<br>
            returns  -   the converted string (not a copy)<br>

<br><dt>        <code>strcat(<i>expr</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(strcat<a name="index1561"><a name="index1562"> <tt><i>expr</i></tt><span style="font-style:normal">...</span>)</code> [LISP]  - concatenate strings

<dd>
            <i>expr</i> -     the strings to concatenate<br>
            returns  -   the result of concatenating the strings<br>

<br><dt>        <code>subseq(<i>string</i>, <i>start</i> [, <i>end</i>])</code> [SAL]<br>
        <code>(subseq<a name="index1563"> <tt><i>string</i></tt> <tt><i>start</i></tt> [<tt><i>end</i></tt>])</code> [LISP]  - extract a substring

<dd>
            <i>string</i> -   the string<br>
            <i>start</i>  -   the starting position (zero origin)<br>
            <i>end</i>    -   the ending position + 1 (defaults to end)<br>
            returns    - substring between <i>start</i> and <i>end</i><br>

<br><dt>

        <code>string&lt;(<i>str1</i>, <i>str2</i>, start1: <i>start1</i>, end1: <i>end1</i>, start2: <i>start2</i>, end2: <i>end2</i>)</code> [SAL]<br>
        <code>(string&lt;<a name="index1564"> <tt><i>str1</i></tt> <tt><i>str2</i></tt> <tt>&amp;key </tt><tt>:start1</tt> <tt>:end1</tt> <tt>:start2</tt> <tt>:end2</tt>)</code> [LISP]


        <code>string&lt;=(<i>str1</i>, <i>str2</i>, start1: <i>start1</i>, end1: <i>end1</i>, start2: <i>start2</i>, end2: <i>end2</i>)</code> [SAL]<br>
        <code>(string&lt;=<a name="index1565"> <tt><i>str1</i></tt> <tt><i>str2</i></tt> <tt>&amp;key </tt><tt>:start1</tt> <tt>:end1</tt> <tt>:start2</tt> <tt>:end2</tt>)</code> [LISP]

<br>
        <code>string=(<i>str1</i>, <i>str2</i>, start1: <i>start1</i>, end1: <i>end1</i>, start2: <i>start2</i>, end2: <i>end2</i>)</code> [SAL]<br>
        <code>(string=<a name="index1566"> <tt><i>str1</i></tt> <tt><i>str2</i></tt> <tt>&amp;key </tt><tt>:start1</tt> <tt>:end1</tt> <tt>:start2</tt> <tt>:end2</tt>)</code> [LISP]

<br>
        <code>string/=(<i>str1</i>, <i>str2</i>, start1: <i>start1</i>, end1: <i>end1</i>, start2: <i>start2</i>, end2: <i>end2</i>)</code> [SAL]<br>
        <code>(string/=<a name="index1567"> <tt><i>str1</i></tt> <tt><i>str2</i></tt> <tt>&amp;key </tt><tt>:start1</tt> <tt>:end1</tt> <tt>:start2</tt> <tt>:end2</tt>)</code> [LISP]

<br>
        <code>string&gt;=(<i>str1</i>, <i>str2</i>, start1: <i>start1</i>, end1: <i>end1</i>, start2: <i>start2</i>, end2: <i>end2</i>)</code> [SAL]<br>
        <code>(string&gt;=<a name="index1568"> <tt><i>str1</i></tt> <tt><i>str2</i></tt> <tt>&amp;key </tt><tt>:start1</tt> <tt>:end1</tt> <tt>:start2</tt> <tt>:end2</tt>)</code> [LISP]

<br>
        <code>string&gt;(<i>str1</i>, <i>str2</i>, start1: <i>start1</i>, end1: <i>end1</i>, start2: <i>start2</i>, end2: <i>end2</i>)</code> [SAL]<br>
        <code>(string&gt;<a name="index1569"> <tt><i>str1</i></tt> <tt><i>str2</i></tt> <tt>&amp;key </tt><tt>:start1</tt> <tt>:end1</tt> <tt>:start2</tt> <tt>:end2</tt>)</code> [LISP]


<dd>
            <i>str1</i> -     the first string to compare<br>
            <i>str2</i> -     the second string to compare<br>
            :start1  -   first substring starting offset<br>
            :end1    -   first substring ending offset + 1<br>
            :start2  -   second substring starting offset<br>
            :end2    -   second substring ending offset + 1<br>
            returns  -   <code>t</code> if predicate is true, <code>nil</code> otherwise<br>
          Note: case is significant with these comparison functions.

<br>
<br><dt>

<code>string-lessp(<i>str1</i>, <i>str2</i>, start1: <i>start1</i>, end1: <i>end1</i>, start2: <i>start2</i>, end2: <i>end2</i>)</code> [SAL]<br>
        <code>(string-lessp<a name="index1570"> <tt><i>str1</i></tt> <tt><i>str2</i></tt> <tt>&amp;key </tt><tt>:start1</tt> <tt>:end1</tt> <tt>:start2</tt> <tt>:end2</tt>)</code> [LISP]

<br>
<code>string-not-greaterp(<i>str1</i>, <i>str2</i>, start1: <i>start1</i>, end1: <i>end1</i>, start2: <i>start2</i>, end2: <i>end2</i>)</code> [SAL]<br>
        <code>(string-not-greaterp<a name="index1571"> <tt><i>str1</i></tt> <tt><i>str2</i></tt> <tt>&amp;key </tt><tt>:start1</tt> <tt>:end1</tt> <tt>:start2</tt> <tt>:end2</tt>)</code> [LISP]

<br>
<code>string-equal(<i>str1</i>, <i>str2</i>, start1: <i>start1</i>, end1: <i>end1</i>, start2: <i>start2</i>, end2: <i>end2</i>)</code> [SAL]<br>
        <code>(string-equal<a name="index1572"> <tt><i>str1</i></tt> <tt><i>str2</i></tt> <tt>&amp;key </tt><tt>:start1</tt> <tt>:end1</tt> <tt>:start2</tt> <tt>:end2</tt>)</code> [LISP]

<br>
<code>string-not-equal(<i>str1</i>, <i>str2</i>, start1: <i>start1</i>, end1: <i>end1</i>, start2: <i>start2</i>, end2: <i>end2</i>)</code> [SAL]<br>
        <code>(string-not-equal<a name="index1573"> <tt><i>str1</i></tt> <tt><i>str2</i></tt> <tt>&amp;key </tt><tt>:start1</tt> <tt>:end1</tt> <tt>:start2</tt> <tt>:end2</tt>)</code> [LISP]

<br>
<code>string-not-lessp(<i>str1</i>, <i>str2</i>, start1: <i>start1</i>, end1: <i>end1</i>, start2: <i>start2</i>, end2: <i>end2</i>)</code> [SAL]<br>
        <code>(string-not-lessp<a name="index1574"> <tt><i>str1</i></tt> <tt><i>str2</i></tt> <tt>&amp;key </tt><tt>:start1</tt> <tt>:end1</tt> <tt>:start2</tt> <tt>:end2</tt>)</code> [LISP]

<br>
<code>string-greaterp(<i>str1</i>, <i>str2</i>, start1: <i>start1</i>, end1: <i>end1</i>, start2: <i>start2</i>, end2: <i>end2</i>)</code> [SAL]<br>
        <code>(string-greaterp<a name="index1575"> <tt><i>str1</i></tt> <tt><i>str2</i></tt> <tt>&amp;key </tt><tt>:start1</tt> <tt>:end1</tt> <tt>:start2</tt> <tt>:end2</tt>)</code> [LISP]


<dd>
            <i>str1</i> -     the first string to compare<br>
            <i>str2</i> -     the second string to compare<br>
            :start1  -   first substring starting offset<br>
            :end1    -   first substring ending offset + 1<br>
            :start2  -   second substring starting offset<br>
            :end2    -   second substring ending offset + 1<br>
    returns  -   <code>t</code> if predicate is true, <code>nil</code> otherwise<br>
          Note: case is not significant with these comparison functions.

<br>
<br><dt>
</dl>
<p>
<a name = "239"><h3>Character Functions</h3></a><a name="index1576">
<dl>
<dt>
        <code>char(<i>string</i>, <i>index</i>)</code> [SAL]<br>
        <code>(char<a name="index1577"> <tt><i>string</i></tt> <tt><i>index</i></tt>)</code> [LISP] -  extract a character from a string

<dd>
            <i>string</i> -   the string<br>
            <i>index</i>  -   the string index (zero relative)<br>
            returns    - the ascii code of the character<br>

<br><dt>        <code>upper-case-p(<i>chr</i>)</code> [SAL]<br>
        <code>(upper-case-p<a name="index1578"> <tt><i>chr</i></tt>)</code> [LISP]  - is this an upper case character?

<dd>
            <i>chr</i> -      the character<br>
            returns -    <code>t</code> if the character is upper case, <code>nil</code> otherwise<br>

<br><dt>        <code>lower-case-p(<i>chr</i>)</code> [SAL]<br>
        <code>(lower-case-p<a name="index1579"> <tt><i>chr</i></tt>)</code> [LISP]  - is this a lower case character?

<dd>
            <i>chr</i> -      the character<br>
            returns -    <code>t</code> if the character is lower case, <code>nil</code> otherwise<br>

<br><dt>        <code>both-case-p(<i>chr</i>)</code> [SAL]<br>
        <code>(both-case-p<a name="index1580"> <tt><i>chr</i></tt>)</code> [LISP]  - is this an alphabetic (either case) character?

<dd>
            <i>chr</i> -      the character<br>
            returns -    <code>t</code> if the character is alphabetic, <code>nil</code> otherwise<br>

<br><dt>        <code>digit-char-p(<i>chr</i>)</code> [SAL]<br>
        <code>(digit-char-p<a name="index1581"> <tt><i>chr</i></tt>)</code> [LISP]  - is this a digit character?

<dd>
            <i>chr</i> -      the character<br>
            returns -    the digit weight if character is a digit, <code>nil</code> otherwise<br>

<br><dt>        <code>char-code(<i>chr</i>)</code> [SAL]<br>
        <code>(char-code<a name="index1582"> <tt><i>chr</i></tt>)</code> [LISP]  - get the ascii code of a character

<dd>
            <i>chr</i> -      the character<br>
            returns -    the ascii character code (integer)<br>

<br><dt>        <code>code-char(<i>code</i>)</code> [SAL]<br>
        <code>(code-char<a name="index1583"> <tt><i>code</i></tt>)</code> [LISP]  - get the character with a specified ascii code

<dd>
            <i>code</i> -     the ascii code (integer)<br>
            returns  -   the character with that code or <code>nil</code><br>

<br><dt>        <code>char-upcase(<i>chr</i>)</code> [SAL]<br>
        <code>(char-upcase<a name="index1584"> <tt><i>chr</i></tt>)</code> [LISP]  - convert a character to upper case

<dd>
            <i>chr</i>  -     the character<br>
            returns  -   the upper case character<br>

<br><dt>        <code>char-downcase(<i>chr</i>)</code> [SAL]<br>
        <code>(char-downcase<a name="index1585"> <tt><i>chr</i></tt>)</code> [LISP]  - convert a character to lower case

<dd>
            <i>chr</i>  -     the character<br>
            returns  -   the lower case character<br>

<br><dt>        <code>digit-char(<i>n</i>)</code> [SAL]<br>
        <code>(digit-char<a name="index1586"> <tt><i>n</i></tt>)</code> [LISP]  - convert a digit weight to a digit

<dd>
            <i>n</i>    -     the digit weight (integer)<br>
            returns  -   the digit character or <code>nil</code><br>

<br><dt>        <code>char-int(<i>chr</i>)</code> [SAL]<br>
        <code>(char-int<a name="index1587"> <tt><i>chr</i></tt>)</code> [LISP]  - convert a character to an integer

<dd>
            <i>chr</i>  -     the character<br>
            returns  -   the ascii character code<br>

<br><dt>        <code>int-char(<i>int</i>)</code> [SAL]<br>
        <code>(int-char<a name="index1588"> <tt><i>int</i></tt>)</code> [LISP]  - convert an integer to a character

<dd>
            <i>int</i>  -     the ascii character code<br>
            returns  -   the character with that code<br>

<br><dt>

       <code>char&lt;(<i>chr1</i>, <i>chr2</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(char&lt;<a name="index1589"> <tt><i>chr1</i></tt> <tt><i>chr2</i></tt><span style="font-style:normal">...</span>)</code> [LISP]

<br>
        <code>char&lt;=(<i>chr1</i>, <i>chr2</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(char&lt;=<a name="index1590"> <tt><i>chr1</i></tt> <tt><i>chr2</i></tt><span style="font-style:normal">...</span>)</code> [LISP]

<br>
        <code>char=(<i>chr1</i>, <i>chr2</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(char=<a name="index1591"> <tt><i>chr1</i></tt> <tt><i>chr2</i></tt><span style="font-style:normal">...</span>)</code> [LISP]

<br>
        <code>char/=(<i>chr1</i>, <i>chr2</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(char/=<a name="index1592"> <tt><i>chr1</i></tt> <tt><i>chr2</i></tt><span style="font-style:normal">...</span>)</code> [LISP]

<br>
        <code>char&gt;=(<i>chr1</i>, <i>chr2</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(char&gt;=<a name="index1593"> <tt><i>chr1</i></tt> <tt><i>chr2</i></tt><span style="font-style:normal">...</span>)</code> [LISP]

<br>
        <code>char&gt;(<i>chr1</i>, <i>chr2</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(char&gt;<a name="index1594"> <tt><i>chr1</i></tt> <tt><i>chr2</i></tt><span style="font-style:normal">...</span>)</code> [LISP]


<dd>
            <i>chr1</i> -     the first character to compare<br>
            <i>chr2</i> -     the second character(s) to compare<br>
            returns  -   <code>t</code> if predicate is true, <code>nil</code> otherwise<br>
          Note: case is significant with these comparison functions.

<br>
<br><dt>

<code>char-lessp(<i>chr1</i>, <i>chr2</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(char-lessp<a name="index1595"> <tt><i>chr1</i></tt> <tt><i>chr2</i></tt><span style="font-style:normal">...</span>)</code> [LISP]

<br>
<code>char-not-greaterp(<i>chr1</i>, <i>chr2</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(char-not-greaterp<a name="index1596"> <tt><i>chr1</i></tt> <tt><i>chr2</i></tt><span style="font-style:normal">...</span>)</code> [LISP]

<br>
<code>char-equal(<i>chr1</i>, <i>chr2</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(char-equal<a name="index1597"> <tt><i>chr1</i></tt> <tt><i>chr2</i></tt><span style="font-style:normal">...</span>)</code> [LISP]

<br>
<code>char-not-equal(<i>chr1</i>, <i>chr2</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(char-not-equal<a name="index1598"> <tt><i>chr1</i></tt> <tt><i>chr2</i></tt><span style="font-style:normal">...</span>)</code> [LISP]

<br>
<code>char-not-lessp(<i>chr1</i>, <i>chr2</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(char-not-lessp<a name="index1599"> <tt><i>chr1</i></tt> <tt><i>chr2</i></tt><span style="font-style:normal">...</span>)</code> [LISP]

<br>
<code>char-greaterp(<i>chr1</i>, <i>chr2</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(char-greaterp<a name="index1600"> <tt><i>chr1</i></tt> <tt><i>chr2</i></tt><span style="font-style:normal">...</span>)</code> [LISP]


<dd>
<i>chr1</i> -     the first string to compare<br>
<i>chr2</i> -     the second string(s) to compare<br>
returns  -   <code>t</code> if predicate is true, <code>nil</code> otherwise<br>
          Note: case is not significant with these comparison functions.

<br>
<br><dt>
</dl>
<p>
<a name = "240"><h3>Input/Output Functions</h3></a><a name="index1601">
<dl>
<dt>
        <code>read([<i>stream</i> [, <i>eof</i> [, <i>rflag</i>]]])</code> [SAL]<br>
        <code>(read<a name="index1602"> [<tt><i>stream</i></tt> [<tt><i>eof</i></tt> [<tt><i>rflag</i></tt>]]])</code> [LISP]  - read an expression

<dd>
            <i>stream</i> -   the input stream (default is standard input)<br>
            <i>eof</i>    -   the value to return on end of file (default is <code>nil</code>)<br>
            <i>rflag</i>  -   recursive read flag (default is <code>nil</code>)<br>
            returns    - the expression read<br>

<br><dt>        <code>(print<a name="index1603"> <tt><i>expr</i></tt> [<tt><i>stream</i></tt>])</code> [LISP]  - print an expression on a new line
<dd>
            <i>expr</i>   -   the expression to be printed<br>
            <i>stream</i> -   the output stream (default is standard output)<br>
            returns    - the expression<br>

<br><dt>        <code>prin1(<i>expr</i> [, <i>stream</i>])</code> [SAL]<br>
        <code>(prin1<a name="index1604"> <tt><i>expr</i></tt> [<tt><i>stream</i></tt>])</code> [LISP]  - print an expression

<dd>
            <i>expr</i>   -   the expression to be printed<br>
            <i>stream</i> -   the output stream (default is standard output)<br>
            returns    - the expression<br>

<br><dt>        <code>princ(<i>expr</i> [, <i>stream</i>])</code> [SAL]<br>
        <code>(princ<a name="index1605"> <tt><i>expr</i></tt> [<tt><i>stream</i></tt>])</code> [LISP]  - print an expression without quoting

<dd>
            <i>expr</i>   -   the expressions to be printed<br>
            <i>stream</i> -   the output stream (default is standard output)<br>
            returns   -  the expression<br>

<br><dt>        <code>pprint(<i>expr</i> [, <i>stream</i>])</code> [SAL]<br>
        <code>(pprint<a name="index1606"> <tt><i>expr</i></tt> [<tt><i>stream</i></tt>])</code> [LISP]  - pretty print an expression

<dd>
            <i>expr</i>  -    the expressions to be printed<br>
            <i>stream</i> -   the output stream (default is standard output)<br>
            returns -    the expression<br>

<br><dt>        <code>terpri([<i>stream</i>])</code> [SAL]<br>
        <code>(terpri<a name="index1607"> [<tt><i>stream</i></tt>])</code> [LISP]  - terminate the current print line

<dd>
            <i>stream</i> -   the output stream (default is standard output)<br>
            returns   -  <code>nil</code><br>

<br><dt>        <code>flatsize(<i>expr</i>)</code> [SAL]<br>
        <code>(flatsize<a name="index1608"> <tt><i>expr</i></tt>)</code> [LISP]  - length of printed representation using prin1

<dd>
            <i>expr</i>  -    the expression<br>
            returns  -   the length<br>

<br><dt>        <code>flatc(<i>expr</i>)</code> [SAL]<br>
        <code>(flatc<a name="index1609"> <tt><i>expr</i></tt>)</code> [LISP]  - length of printed representation using princ

<dd>
            <i>expr</i> -     the expression<br>
            returns  -   the length

<br>
<br><dt>
</dl>
<p>
<a name = "241"><h3>The Format Function</h3></a><a name="index1610">
<dl>
<dt>
<code>format(<i>stream</i>, <i>fmt</i>, <i>arg</i><span style="font-style:normal">...</span>)</code> [SAL]<br>
        <code>(format<a name="index1611"> <tt><i>stream</i></tt> <tt><i>fmt</i></tt> <tt><i>arg</i></tt><span style="font-style:normal">...</span>)</code> [LISP]   - do formated

output
<dd>
            <i>stream</i> -   the output stream<br>
            <i>fmt</i>    -   the format string<br>
            <i>arg</i>    -   the format arguments<br>
            returns   -  output string if <i>stream</i> is <code>nil</code>, <code>nil</code> otherwise<br>

<br><dt>
</dl>
       The format string can contain characters that should be copied
        directly to the output and formatting directives.  The
        formatting directives are:
<blockquote>
<code>~A</code> - print next argument using princ<br>

<code>~S</code> - print next argument using prin1<br>

<code>~%</code> - start a new line<br>

<code>~~</code> - print a tilde character<br>

<code>~</code>&lt;newline&gt; - ignore this one newline and white space on the <br>

next line up to the first non-white-space character or newline. This <br>

allows strings to continue across multiple lines<br>

</blockquote>
<p>
<a name = "242"><h3>File I/O Functions</h3></a><a name="index1612">
Note that files are ordinarily opened as text. Binary files (such as standard midi files) must be opened with <code>open-binary</code> on non-unix systems.
<dl>
<dt>
        <code>open(<i>fname</i>, direction: <i>direction</i>)</code> [SAL]<br>
        <code>(open<a name="index1613"> <tt><i>fname</i></tt> <tt>&amp;key </tt><tt>:direction</tt>)</code> [LISP] -  open a file stream

<dd>
            <i>fname</i> -    the file name string or symbol<br>
            :direction - :input or :output (default is :input)<br>
            returns   -  a stream<br>

<br><dt>
        <code>open-binary(<i>fname</i>, direction: <i>direction</i>)</code> [SAL]<br>
        <code>(open-binary<a name="index1614"><a name="index1615"><a name="index1616"> <tt><i>fname</i></tt> <tt>&amp;key </tt><tt>:direction</tt>)</code> [LISP] -  open a binary file stream

<dd>
            <i>fname</i> -    the file name string or symbol<br>
            :direction - :input or :output (default is :input)<br>
            returns   -  a stream<br>

<br><dt>        <code>close(<i>stream</i>)</code> [SAL]<br>
        <code>(close<a name="index1617"> <tt><i>stream</i></tt>)</code> [LISP]  - close a file stream

<dd>
            <i>stream</i> -   the stream<br>
            returns    - <code>nil</code><br>

<br><dt>        <code>setdir(<i>path</i> [, <i>verbose</i>])</code> [SAL]<br>
        <code>(setdir<a name="index1618"><a name="index1619"> <tt><i>path</i></tt> [<tt><i>verbose</i></tt>])</code> [LISP] <a href = "foot.html#foot9">(Footnote 9)</a>  - set current directory

<dd>
            <i>path</i> -   the path of the new directory<br>
            <i>verbose</i> - print error message if current directory cannot be changed to <i>path</i><br>
            returns   -  the resulting full path, e.g. (setdir ".") gets the current working directory, or <code>nil</code> if an error occurs<br>

<br><dt>        <code>listdir(<i>path</i>)</code> [SAL]<br>
        <code>(listdir<a name="index1620"><a name="index1621"><a name="index1622"><a name="index1623"><a name="index1624"> <tt><i>path</i></tt>)</code> [LISP] <a href = "foot.html#foot10">(Footnote 10)</a>  - get a directory listing

<dd>
            <i>path</i> -   the path of the directory to be listed<br>
            returns   -  list of filenames in the directory<br>

<br><dt>        <code>get-temp-path()</code> [SAL]<br>
        <code>(get-temp-path<a name="index1625"><a name="index1626"><a name="index1627">)</code> [LISP] <a href = "foot.html#foot11">(Footnote 11)</a>  - get a path where a temporary file can be created. Under Windows, this is based on environment variables. If XLISP is running as a sub-process to Java, the environment may not exist, in which case the default result is the unfortunate choice <code>c:\windows\</code>.

<dd>
            returns   -  the resulting full path as a string<br>

<br><dt>        <code>get-user()</code> [SAL]<br>
        <code>(get-user<a name="index1628"><a name="index1629"><a name="index1630">)</code> [LISP] <a href = "foot.html#foot12">(Footnote 12)</a>  - get the user ID. In Unix systems (including OS X and Linux), this is the value of the USER environment variable. In Windows, this is currently just "nyquist", which is also returned if the environment variable cannot be accessed. This function is used to avoid the case of two users creating files of the same name in the same temp directory.

<dd>
            returns   - the string naming the user<br>

<br><dt>
        <code>find-in-xlisp-path(<i>filename</i>)</code> [SAL]<br>
        <code>(find-in-xlisp-path<a name="index1631"> <tt><i>filename</i></tt>)</code> [LISP] <a href = "foot.html#foot13">(Footnote 13)</a>  - search the XLISP search path (e.g. <code>XLISPPATH</code> from the environment) for <i>filename</i>. If <i>filename</i> is not found as is, and there is no file extension, append "<code>.lsp</code>" to <i>filename</i> and search again. The current directory is not searched.

<dd>
            <i>filename</i> - the name of the file to search for<br>
            returns - a full path name to the first occurrence found<br>

<br><dt>        <code>read-char([<i>stream</i>])</code> [SAL]<br>
        <code>(read-char<a name="index1632"><a name="index1633"> [<tt><i>stream</i></tt>])</code> [LISP]  - read a character from a stream

<dd>
            <i>stream</i> -   the input stream (default is standard input)<br>
            returns   -  the character<br>

<br><dt>        <code>peek-char([<i>flag</i> [, <i>stream</i>]])</code> [SAL]<br>
        <code>(peek-char<a name="index1634"> [<tt><i>flag</i></tt> [<tt><i>stream</i></tt>]])</code> [LISP]  - peek at the next character

<dd>
            <i>flag</i>  -    flag for skipping white space (default is <code>nil</code>)<br>
            <i>stream</i> -    the input stream (default is standard input)<br>
            returns   -  the character (integer)<br>

<br><dt>        <code>write-char(<i>ch</i>  [, <i>stream</i>])</code> [SAL]<br>
        <code>(write-char<a name="index1635"> <tt><i>ch</i></tt> [<tt><i>stream</i></tt>])</code> [LISP]  - write a character to a stream

<dd>
            <i>ch</i>    -    the character to write<br>
            <i>stream</i> -   the output stream (default is standard output)<br>
            returns   -  the character<br>

<br><dt>        <code>read-int([<i>stream</i> [, <i>length</i>]])</code> [SAL]<br>
        <code>(read-int<a name="index1636"> [<tt><i>stream</i></tt> [<tt><i>length</i></tt>]])</code> [LISP]  - read a binary integer from a stream

<dd>
            <i>stream</i> -   the input stream (default is standard input)<br>
            <i>length</i> - the length of the integer in bytes (default is 4)<br>
            returns   -  the integer<br>
Note: Integers are assumed to be big-endian (high-order byte first) and 
signed, regardless of the platform. To read little-endian format, use a
negative number for the length, e.g. -4 indicates a 4-bytes, low-order
byte first. The file should be opened in binary mode.<br>

<br><dt>        <code>write-int(<i>ch</i> [, <i>stream</i> [, <i>length</i>]])</code> [SAL]<br>
        <code>(write-int<a name="index1637"> <tt><i>ch</i></tt> [<tt><i>stream</i></tt> [<tt><i>length</i></tt>]])</code> [LISP]  - write a binary integer to a stream

<dd>
            <i>ch</i>    -    the character to write<br>
            <i>stream</i> -   the output stream (default is standard output)<br>
            <i>length</i> - the length of the integer in bytes (default is 4)<br>
            returns   -  the integer<br>
Note: Integers are assumed to be big-endian (high-order byte first) and 
signed, regardless of the platform. To write in little-endian format, use a
negative number for the length, e.g. -4 indicates a 4-bytes, low-order
byte first. The file should be opened in binary mode.<br>

<br><dt>        <code>read-float([<i>stream</i> [, <i>length</i>]])</code> [SAL]<br>
        <code>(read-float<a name="index1638"> [<tt><i>stream</i></tt> [<tt><i>length</i></tt>]])</code> [LISP]  - read a binary floating-point number from a stream

<dd>
            <i>stream</i> -   the input stream (default is standard input)<br>
            <i>length</i> - the length of the float in bytes (default is 4, legal values are -4, -8, 4, and 8)<br>
            returns   -  the integer<br>
Note: Floats are assumed to be big-endian (high-order byte first) and 
signed, regardless of the platform. To read little-endian format, use a
negative number for the length, e.g. -4 indicates a 4-bytes, low-order
byte first. The file should be opened in binary mode.<br>

<br><dt>        <code>write-float(<i>ch</i> [, <i>stream</i> [, <i>length</i>]])</code> [SAL]<br>
        <code>(write-float<a name="index1639"> <tt><i>ch</i></tt> [<tt><i>stream</i></tt> [<tt><i>length</i></tt>]])</code> [LISP]  - write a binary floating-point number to a stream

<dd>
            <i>ch</i>    -    the character to write<br>
            <i>stream</i> -   the output stream (default is standard output)<br>
            <i>length</i> - the length of the float in bytes (default is 4, legal values are -4, -8, 4, and 8)<br>
            returns   -  the integer<br>
Note: Floats are assumed to be big-endian (high-order byte first) and 
signed, regardless of the platform. To write in little-endian format, use a
negative number for the length, e.g. -4 indicates a 4-bytes, low-order
byte first. The file should be opened in binary mode.<br>

<br><dt>        <code>read-line([<i>stream</i>])</code> [SAL]<br>
        <code>(read-line<a name="index1640"> [<tt><i>stream</i></tt>])</code> [LISP]  - read a line from a stream

<dd>
            <i>stream</i> -   the input stream (default is standard input)<br>
            returns   -  the string<br>

<br><dt>        <code>read-byte([<i>stream</i>])</code> [SAL]<br>
        <code>(read-byte<a name="index1641"> [<tt><i>stream</i></tt>])</code> [LISP]  - read a byte from a stream

<dd>
            <i>stream</i> -   the input stream (default is standard input)<br>
            returns    - the byte (integer)<br>

<br><dt>        <code>write-byte(<i>byte</i> [, <i>stream</i>])</code> [SAL]<br>
        <code>(write-byte<a name="index1642"> <tt><i>byte</i></tt> [<tt><i>stream</i></tt>])</code> [LISP]  - write a byte to a stream

<dd>
            <i>byte</i>   -   the byte to write (integer)<br>
            <i>stream</i> -   the output stream (default is standard output)<br>
            returns    - the byte (integer)<br>

<br><dt>
</dl><a name = "243"><h3>String Stream Functions</h3></a><a name="index1643">
        These functions operate on unnamed streams.  An unnamed output
        stream collects characters sent to it when it is used as the
        destination of any output function.  The functions 
<code>get-output-stream-string</code> and <code>get-output-stream-list</code> return a string or a list of characters.
<p>
An unnamed input stream is setup with the 
 <code>make-string-input-stream</code> function and returns each character of the string when
        it is used as the source of any input function.
<p>
<dl>
<dt>
<br><dt>
        <code>make-string-input-stream(<i>str</i> [, <i>start</i> [, <i>end</i>]])</code> [SAL]<br>
        <code>(make-string-input-stream<a name="index1644"> <tt><i>str</i></tt> [<tt><i>start</i></tt> [<tt><i>end</i></tt>]])</code> [LISP]

<dd>
            <i>str</i>    -   the string<br>
            <i>start</i>  -   the starting offset<br>
            <i>end</i>    -   the ending offset + 1<br>
            returns    - an unnamed stream that reads from the string<br>

<br><dt>        <code>make-string-output-stream)()</code> [SAL]<br>
        <code>(make-string-output-stream)</code> [LISP]<a name="index1645">

<dd>
            returns   -  an unnamed output stream<br>

<br><dt>        <code>get-output-stream-string(<i>stream</i>)</code> [SAL]<br>
        <code>(get-output-stream-string<a name="index1646"> <tt><i>stream</i></tt>)</code> [LISP]

<dd>
            <i>stream</i> -    the output stream<br>
            returns    - the output so far as a string<br>
          Note:  the output stream is emptied by this function

<br>
<br><dt>        <code>get-output-stream-list(<i>stream</i>)</code> [SAL]<br>
        <code>(get-output-stream-list<a name="index1647"> <tt><i>stream</i></tt>)</code> [LISP]

<dd>
            <i>stream</i> -   the output stream<br>
            returns   -  the output so far as a list<br>
          Note:  the output stream is emptied by this function

<br>
<br><dt>
</dl>
<p>
<a name = "244"><h3>System Functions</h3></a><a name="index1648">
Note: the <code>load</code> function first tries to load a file from the current directory. A <code>.lsp</code> extension is added if there is not already an alphanumeric extension following  a period.  If that fails, XLISP searches the path, which is obtained from the XLISPPATH environment variable in Unix and  HKEY_LOCAL_MACHINE\SOFTWARE\CMU\Nyquist\XLISPPATH under Win32. (The Macintosh version has no search path.)
<p>
<dl>
<dt>
        <code>get-env(<i>name</i>)</code> [SAL]<br>
        <code>(get-env<a name="index1649"><a name="index1650"><a name="index1651"> <tt><i>name</i></tt>)</code> [LISP] - get from an environment variable

<dd>
           <i>name</i> - the name of the environment variable<br>
           returns  - string value of the environment variable, <code>nil</code> if variable does not exist<br>

<br><dt>        <code>(load<a name="index1652"> <tt><i>fname</i></tt> <tt>&amp;key </tt><tt>:verbose</tt> <tt>:print</tt>)</code> [LISP]   - load a source file
<dd>
            <i>fname</i>   -  the filename string or symbol<br>
            :verbose  -  the verbose flag (default is t)<br>
            :print    -  the print flag (default is <code>nil</code>)<br>
            returns   -  the filename<br>

<br><dt>        <code>save(<i>fname</i>)</code> [SAL]<br>
        <code>(save<a name="index1653"> <tt><i>fname</i></tt>)</code> [LISP] - save workspace to a file

<dd>
            <i>fname</i> -    the filename string or symbol<br>
            returns   - <code>t</code> if workspace was written, <code>nil</code> otherwise<br>

<br><dt>        <code>restore(<i>fname</i>)</code> [SAL]<br>
        <code>(restore<a name="index1654"> <tt><i>fname</i></tt>)</code> [LISP]  - restore workspace from a file

<dd>
            <i>fname</i> -    the filename string or symbol<br>
            returns   -  <code>nil</code> on failure, otherwise never returns<br>

<br><dt>        <code>dribble([<i>fname</i>])</code> [SAL]<br>
        <code>(dribble<a name="index1655"> [<tt><i>fname</i></tt>])</code> [LISP]  - create a file with a transcript of a session

<dd>
            <i>fname</i> -    file name string or symbol
                        (if missing, close current transcript)<br>
            returns   - <code>t</code> if the transcript is opened, <code>nil</code> if it is closed<br>

<br><dt>        <code>gc()</code> [SAL]<br>
        <code>(gc<a name="index1656">)</code> [LISP]  - force garbage collection

<dd>
            returns -    <code>nil</code><br>

<br><dt>        <code>expand(<i>num</i>)</code> [SAL]<br>
        <code>(expand<a name="index1657"> <tt><i>num</i></tt>)</code> [LISP]  - expand memory by adding segments

<dd>
            <i>num</i> -      the number of segments to add<br>
            returns -    the number of segments added<br>

<br><dt>        <code>alloc(<i>num</i>)</code> [SAL]<br>
        <code>(alloc<a name="index1658"> <tt><i>num</i></tt>)</code> [LISP]  - change number of nodes to allocate in each segment

<dd>
            <i>num</i> -      the number of nodes to allocate<br>
            returns -    the old number of nodes to allocate<br>

<br><dt>        <code>info()</code> [SAL]<br>
        <code>(info<a name="index1659">)</code> [LISP]  - show information about memory usage.

<dd>
            returns -    <code>nil</code><br>

<br><dt>        <code>room()</code> [SAL]<br>
        <code>(room<a name="index1660">)</code> [LISP]  - show memory allocation statistics

<dd>
            returns -    <code>nil</code><br>

<br><dt>        <code>type-of(<i>expr</i>)</code> [SAL]<br>
        <code>(type-of<a name="index1661"> <tt><i>expr</i></tt>)</code> [LISP]  - returns the type of the expression

<dd>
            <i>expr</i> -     the expression to return the type of<br>
            returns  -   <code>nil</code> if the value is <code>nil</code> otherwise one of the symbols:<br>
<dl><dd>
                          SYMBOL      -    for symbols<br>
                          OBJECT      -    for objects<br>
                          CONS        -    for conses<br>
                          SUBR        -    for built-in functions<br>
                          FSUBR       -    for special forms<br>
                          CLOSURE     -    for defined functions<br>
                          STRING      -    for strings<br>
                          FIXNUM      -    for integers<br>
                          FLONUM      -    for floating point numbers<br>
                          CHARACTER   -    for characters<br>
                          FILE-STREAM -    for file pointers<br>
                          UNNAMED-STREAM - for unnamed streams<br>
                          ARRAY          - for arrays<br>
</dl>

<br><dt>        <code>peek(<i>addrs</i>)</code> [SAL]<br>
        <code>(peek<a name="index1662"> <tt><i>addrs</i></tt>)</code> [LISP]   - peek at a location in memory

<dd>
            <i>addrs</i>  -   the address to peek at (integer)<br>
            returns    - the value at the specified address (integer)<br>

<br><dt>        <code>poke(<i>addrs</i>, <i>value</i>)</code> [SAL]<br>
        <code>(poke<a name="index1663"> <tt><i>addrs</i></tt> <tt><i>value</i></tt>)</code> [LISP] -  poke a value into memory

<dd>
            <i>addrs</i>  -   the address to poke (integer)<br>
            <i>value</i>  -   the value to poke into the address (integer)<br>
            returns    - the value<br>

<br><dt>        <code>bigendianp()</code> [SAL]<br>
        <code>(bigendianp<a name="index1664"><a name="index1665"><a name="index1666"><a name="index1667">)</code> [LISP] -  is this a big-endian machine?

<dd>
            returns    - T if this a big-endian architecture, storing the high-order byte of an integer at the lowest byte address of the integer; otherwise, NIL.
 <a href = "foot.html#foot14">(Footnote 14)</a> <br>

<br><dt>        <code>address-of(<i>expr</i>)</code> [SAL]<br>
        <code>(address-of<a name="index1668"> <tt><i>expr</i></tt>)</code> [LISP]  - get the address of an xlisp node

<dd>
            <i>expr</i>   -   the node<br>
            returns    - the address of the node (integer)<br>

<br><dt>        <code>exit()</code> [SAL]<br>
        <code>(exit<a name="index1669">)</code> [LISP]  -
        exit xlisp. (Note: in Audacity plug-ins, <code>exit</code> is
        undefined because exiting would terminate Audacity.)

<dd>
            returns    - never returns<br>

<br><dt>        <code>setup-console()</code> [SAL]<br>
        <code>(setup-console<a name="index1670"><a name="index1671">)</code> [LISP]  - set default console attributes

<dd>
            returns    - NIL<br>
Note: Under Windows, Nyquist normally starts up in a medium-sized console window with black text and a white background, with a window title of "Nyquist." This is normally accomplished by calling <code>setup-console</code> in <code>system.lsp</code>. In Nyquist, you can avoid this behavior by setting <code>*setup-console*</code> to NIL in your <code>init.lsp</code> file. If <code>setup-console</code> is not called, Nyquist uses standard input and output as is. This is what you want if you are running Nyquist inside of emacs, for example.<a name="index1672"><br>

<br><dt>        <code>echoenabled(<i>flag</i>)</code> [SAL]<br>
        <code>(echoenabled<a name="index1673"><a name="index1674"> <tt><i>flag</i></tt>)</code> [LISP]  - turn console input echoing on or off

<dd>
            <i>flag</i>   - T to enable echo, NIL to disable<br>
            returns    - NIL<br>
Note: This function is only implemented under Linux and Mac OS X. If Nyquist I/O is redirected through pipes,
the Windows version does not echo the input, but the Linux and Mac versions do. You can turn off echoing with
this function. Under windows it is defined to do nothing.<br>

</dl><a name = "245"><h3>File I/O Functions</h3></a><a name="index1675"><a name = "246"><h4>Input from a File</h4></a><a name="index1676">To open a file for input, use the <code>open</code> function with the keyword
argument <code>:direction</code> set to <code>:input</code>.  To open a file for output,
use the <code>open</code> function with the keyword argument <code>:direction</code> set
to <code>:output</code>.  The <code>open</code> function takes a single required argument which
is the name of the file to be opened.  This name can be in the form of a
string or a symbol.  The <code>open</code> function returns an object of type
<code>FILE-STREAM</code> if it succeeds in opening the specified file.  It returns the
value <code>nil</code> if it fails.  In order to manipulate the file, it is
necessary to save the value returned by the <code>open</code> function.  This is
usually done by assigning it to a variable with the <code>setq</code> special form or by
binding it using <code>let</code> or <code>let*</code>.  Here is an example:
<pre>
(setq fp (open "init.lsp" :direction :input))
</pre>

        Evaluating this expression will result in the file <code>init.lsp</code>
        being opened.  The file object that will be returned by the <code>open</code>
        function will be assigned to the variable <code>fp</code>.
<p>
        It is now possible to use the file for input.  To read an
        expression from the file, just supply the value of the <code>fp</code>
        variable as the optional <i>stream</i> argument to <code>read</code>.
<pre>
(read fp)
</pre>

        Evaluating this expression will result in reading the first
        expression from the file <code>init.lsp</code>.  The expression will be
        returned as the result of the <code>read</code> function.  More expressions
        can be read from the file using further calls to the <code>read</code>
        function.  When there are no more expressions to read, the <code>read</code>
        function will return <code>nil</code> (or whatever value was supplied as the
        second argument to <code>read</code>).
<p>
        Once you are done reading from the file, you should close it.
        To close the file, use the following expression:
<pre>
(close fp)
</pre>

        Evaluating this expression will cause the file to be closed.
<p>
<a name = "247"><h4>Output to a File</h4></a><a name="index1677">        Writing to a file is pretty much the same as reading from one.
        You need to open the file first.  This time you should use the
        <code>open</code> function to indicate that you will do output to the file.
        For example:
<pre>
(setq fp (open "test.dat" :direction :output))
</pre>

        Evaluating this expression will open the file <code>test.dat</code> for
        output.  If the file already exists, its current contents will
        be discarded.  If it doesn't already exist, it will be created.
        In any case, a <code>FILE-STREAM</code> object will be returned by the <code>OPEN</code>
        function.  This file object will be assigned to the <code>fp</code>
        variable.
<p>
        It is now possible to write to this file by supplying the value
        of the <code>fp</code> variable as the optional <i>stream</i> parameter in the  <code>print</code> function.
<pre>
(print "Hello there" fp)
</pre>

        Evaluating this expression will result in the string "Hello
        there" being written to the file <code>test.dat</code>.  More data can be
        written to the file using the same technique.
<p>
        Once you are done writing to the file, you should close it.
        Closing an output file is just like closing an input file.
<pre>
(close fp)
</pre>

        Evaluating this expression will close the output file and make
        it permanent.
<p>
<a name = "248"><h4>A Slightly More Complicated File Example</h4></a>        This example shows how to open a file, read each Lisp expression
        from the file and print it.  It demonstrates the use of files
        and the use of the optional <i>stream</i> argument to the <code>read</code>
        function.
<pre>
(do* ((fp (open "test.dat" :direction :input))
      (ex (read fp) (read fp)))
     ((null ex) nil)
  (print ex))
</pre>

<p>

<hr>
<a href = "part18.html">Previous Section</a> | <a href = "indx.html">Next Section (Index)</a> | <a href = "title.html#toc">Table of Contents</a> | <a href = "title.html">Title Page</a>
</body></html>
